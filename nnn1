-- Load Rayfield UI Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Local player reference
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Debug settings
local DEBUG_MODE = true

-- ==================================================================
-- INITIALIZE ALL VARIABLES
-- ==================================================================
local PetFarmMode = false
local petFarmCoroutine = nil
local petFarmPetID = nil
local currentToyID = nil
local currentStrollerID = nil
local currentFoodID = nil

local AutoPetPenMode = false
local autoPetPenCoroutine = nil
local lastPetPenCommitTime = 0

local sessionBucksEarned = 0
local sessionPotionsEarned = 0
local lastMoneyAmount = 0
local lastPotionAmount = 0

local ContinuousMode = false
local continuousCoroutine = nil

local AutoAcceptMode = false
local autoAcceptCoroutine = nil

local AutoPotionMode = false
local autoPotionCoroutine = nil

local AILMENT_TASKS = {
    sleepy = "BasicBed",
    hungry = "PetFoodBowl",
    thirsty = "PetWaterBowl",
    dirty = "CheapPetBathtub",
    bored = "Piano",
    toilet = "AilmentsRefresh2024LitterBox",
    play = "THROW_TOY",
    walk = "WALK_HANDLER",
    ride = "STROLLER_HANDLER",
    sick = "HEALING_APPLE",
    mystery = "MYSTERY_HANDLER",
    pet_me = "PET_ME_HANDLER"
}

local lastTaskTime = {}
local TASK_COOLDOWN = 30

local scriptInitialized = false
local PetID = nil
local Pet = nil
local PetsShow = {}
local currentSelectedPetKey = nil
local lastValidPetID = nil

local priorityEggs = {
    "basic_egg_2022_mouse",
    "basic_egg_2022_ant",
    "cracked_egg"
}
local prioritySet = {}
for _, v in ipairs(priorityEggs) do prioritySet[v] = true end

-- ==================================================================
-- CREATE RAYFIELD WINDOW
-- ==================================================================
local Window = Rayfield:CreateWindow({
    Name = "Cocoon PetFarm v3",
    LoadingTitle = "Loading Cocoon PetFarm...",
    LoadingSubtitle = "Advanced Automation System",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "CocoonPetFarm",
        FileName = "Config"
    },
    Discord = {
        Enabled = false,
        Invite = "noinvitelink",
        RememberJoins = true
    },
    KeySystem = false,
})

-- Create tabs
local MainTab = Window:CreateTab("Main", 4483362458)
local PetFarmTab = Window:CreateTab("PetFarm", 12549490297)
local TradingTab = Window:CreateTab("Trading", 7734054201)
local AutoTab = Window:CreateTab("Auto Features", 7733719323)

-- ==================================================================
-- CORE UTILITY FUNCTIONS
-- ==================================================================
local function debugPrint(message)
    if not DEBUG_MODE then return end
    local hours = os.date("%H")
    local minutes = os.date("%M")
    local seconds = os.date("%S")
    local timestamp = string.format("[%s:%s:%s]", hours, minutes, seconds)
    print(timestamp .. " " .. message)
end

local function getPlayerData()
    local success, data = pcall(function()
        return require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    end)
    if not success or not data then
        debugPrint("Failed to get player data")
        return nil
    end
    return data
end

local function getCurrentMoneyAndPotions()
    local success, clientData = pcall(require, ReplicatedStorage.ClientModules.Core.ClientData)
    if not success then return 0, 0 end
    local success2, allData = pcall(clientData.get_data, clientData)
    if not success2 or not allData[player.Name] then return 0, 0 end
    local playerData = allData[player.Name]
    local money = playerData.money or 0
    local potions = 0
    if playerData.inventory and playerData.inventory.food then
        for _, foodData in pairs(playerData.inventory.food) do
            if foodData.id and string.find(string.lower(foodData.id), "potion") then
                potions = potions + (foodData.amount or 1)
            end
        end
    end
    return money, potions
end

local function getRecyclingAndEggData()
    local recyclingPoints = 0
    local crystalEggs = 0

    local success, data = pcall(function()
        return require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    end)

    if success and data then
        if data.pet_recycler_manager and data.pet_recycler_manager.saved_points then
            recyclingPoints = data.pet_recycler_manager.saved_points or 0
        end
        
        if data.inventory and data.inventory.pets then
            for _, petData in pairs(data.inventory.pets) do
                if petData.id and string.lower(petData.id) == "pet_recycler_2025_crystal_egg" then
                    crystalEggs = crystalEggs + 1
                end
            end
        end
    end

    return recyclingPoints, crystalEggs
end

local function updateSessionEarnings()
    local currentMoney, currentPotions = getCurrentMoneyAndPotions()
    if lastMoneyAmount == 0 then lastMoneyAmount = currentMoney end
    if lastPotionAmount == 0 then lastPotionAmount = currentPotions end
    sessionBucksEarned = currentMoney - lastMoneyAmount
    sessionPotionsEarned = currentPotions - lastPotionAmount
    return currentMoney, currentPotions
end

-- ==================================================================
-- AUTO ACCEPT FUNCTIONS (FROM w1.txt)
-- ==================================================================
local function acceptAndConfirmTrade(targetPlayer)
    local args = { targetPlayer, true }
    local success1, result1 = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptOrDeclineTradeRequest"):InvokeServer(unpack(args))
    end)
    if success1 then
        task.wait(5)
        pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptNegotiation"):FireServer()
        end)
        task.wait(9)
        local success3, result3 = pcall(function()
            return ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ConfirmTrade"):FireServer()
        end)
        if success3 then
            debugPrint("Trade with " .. targetPlayer.Name .. " completed successfully!")
            return true
        end
    end
    return false
end

local function scanAndAcceptAllTrades()
    local players = Players:GetPlayers()
    local localPlayer = Players.LocalPlayer
    for _, targetPlayer in ipairs(players) do
        if targetPlayer ~= localPlayer and AutoAcceptMode then
            acceptAndConfirmTrade(targetPlayer)
            task.wait(0.1)
        end
    end
end

local function startAutoAcceptTrades()
    while AutoAcceptMode do
        scanAndAcceptAllTrades()
        task.wait(0.1)
    end
end

local function toggleAutoAcceptMode()
    AutoAcceptMode = not AutoAcceptMode
    if AutoAcceptMode then
        debugPrint("Auto Accept: ENABLED")
        autoAcceptCoroutine = coroutine.wrap(startAutoAcceptTrades)()
    else
        debugPrint("Auto Accept: DISABLED")
        autoAcceptCoroutine = nil
    end
end

-- ==================================================================
-- TRADING FUNCTIONS (FROM w1.txt)
-- ==================================================================
local function sendTradeRequest(targetPlayerName)
    if targetPlayerName == "" or not targetPlayerName then
        debugPrint("No player name provided for trade")
        return
    end
  
    local targetPlayer = Players:FindFirstChild(targetPlayerName)
    if not targetPlayer then
        debugPrint("Player not found: " .. targetPlayerName)
        return
    end
  
    debugPrint("Sending trade request to: " .. targetPlayerName)
    local success, err = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/SendTradeRequest"):FireServer(targetPlayer)
    end)
  
    if success then
        debugPrint("Trade request sent successfully")
    else
        debugPrint("Failed to send trade request: " .. tostring(err))
    end
end

local function getAllPetIDsFromInventory()
    local neonAged6 = {}
    local neonUnder6 = {}
    local others = {}
  
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.pets then
            for petIndex, petData in pairs(playerData.inventory.pets) do
                if petData and petData.unique and petData.id and petData.properties then
                    local petName = tostring(petData.id):lower()
                    if not string.find(petName, "practice_dog") and not (string.find(petName, "dog") or string.find(petName, "cat")) then
                        if petData.properties.neon and (petData.properties.age or 0) == 6 then
                            table.insert(neonAged6, petData.unique)
                        elseif petData.properties.neon and (petData.properties.age or 0) < 6 then
                            table.insert(neonUnder6, petData.unique)
                        else
                            table.insert(others, petData.unique)
                        end
                    end
                end
            end
        end
    end)
  
    if not success then
        debugPrint("Error getting pet IDs from inventory: " .. tostring(errorMsg))
    end
  
    local allPets = {}
    for _, petID in ipairs(neonAged6) do table.insert(allPets, petID) end
    for _, petID in ipairs(neonUnder6) do table.insert(allPets, petID) end
    for _, petID in ipairs(others) do table.insert(allPets, petID) end
  
    return allPets
end

local function addAllPetsToTrade()
    debugPrint("Adding all pets to trade...")
    local petIDs = getAllPetIDsFromInventory()
    if #petIDs == 0 then
        debugPrint("No pets found to add to trade")
        return
    end
  
    local maxPets = math.min(#petIDs, 18)
    debugPrint("Adding " .. maxPets .. " pets to trade")
  
    for i = 1, maxPets do
        local petID = petIDs[i]
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AddItemToOffer"):FireServer(petID)
        end)
      
        if success then
            debugPrint("Added pet " .. i .. "/" .. maxPets .. " to trade")
        else
            debugPrint("Failed to add pet to trade: " .. tostring(err))
        end
        task.wait(0.2)
    end
  
    debugPrint("Finished adding pets to trade")
end

local function completeTradeProcess(targetPlayer)
    local args = { targetPlayer, true }
    local success1, result1 = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptOrDeclineTradeRequest"):InvokeServer(unpack(args))
    end)
  
    if success1 then
        task.wait(2)
        addAllPetsToTrade()
        task.wait(3)
      
        local success2, result2 = pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptNegotiation"):FireServer()
        end)
      
        if success2 then
            task.wait(9)
            local success3, result3 = pcall(function()
                ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ConfirmTrade"):FireServer()
            end)
          
            if success3 then
                debugPrint("Trade completed successfully with " .. targetPlayer.Name)
                return true
            end
        end
    end
  
    debugPrint("Trade failed with " .. targetPlayer.Name)
    return false
end

local function scanAndCompleteAllTrades()
    local players = Players:GetPlayers()
    local localPlayer = Players.LocalPlayer
  
    for _, targetPlayer in ipairs(players) do
        if targetPlayer ~= localPlayer and ContinuousMode then
            debugPrint("Attempting trade with: " .. targetPlayer.Name)
            completeTradeProcess(targetPlayer)
            task.wait(0.1)
        end
    end
end

local function startContinuousAcceptConfirm()
    while ContinuousMode do
        scanAndCompleteAllTrades()
        task.wait(9)
    end
end

local function toggleContinuousMode()
    ContinuousMode = not ContinuousMode
    if ContinuousMode then
        debugPrint("Auto Trade: ENABLED")
        continuousCoroutine = coroutine.wrap(startContinuousAcceptConfirm)()
    else
        debugPrint("Auto Trade: DISABLED")
        continuousCoroutine = nil
    end
end

-- ==================================================================
-- AUTO POTION FUNCTIONS (FROM w1.txt)
-- ==================================================================
local function findPetAgePotion()
    local potionID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "pet_age_potion" then
                    potionID = foodId
                    debugPrint("Found pet_age_potion: " .. foodId)
                    break
                end
            end
        end
    end)
  
    if not success then
        debugPrint("Error finding pet_age_potion: " .. tostring(errorMsg))
    end
  
    return potionID
end

local function safelyUnequipFood(foodID)
    if foodID then
        debugPrint("Unequipping food: " .. foodID)
        local args = { foodID }
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(args))
        end)
        if success then
            debugPrint("Successfully unequipped food")
        else
            debugPrint("Failed to unequip food: " .. tostring(result))
        end
        task.wait(1)
    end
end

local function usePetAgePotion()
    if not PetID then
        debugPrint("No pet selected for potion use!")
        return false
    end
  
    local petExists = false
    local currentPetAge = 0
    pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.pets then
            for i, v in pairs(playerData.inventory.pets) do
                if v.unique == PetID then
                    petExists = true
                    currentPetAge = v.properties.age or 0
                    break
                end
            end
        end
    end)
  
    if not petExists then
        debugPrint("Selected pet no longer exists in inventory!")
        PetID = nil
        return false
    end
  
    if currentPetAge >= 6 then
        debugPrint("Pet is already age 6, no potion needed")
        return false
    end
  
    local potionID = findPetAgePotion()
    if not potionID then
        debugPrint("No pet_age_potion found in inventory!")
        return false
    end
  
    debugPrint("Using pet_age_potion on selected pet...")
  
    local args1 = {
        potionID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(args1))
    end)
  
    if not equipSuccess then
        debugPrint("Failed to equip potion: " .. tostring(equipResult))
        return false
    end
  
    debugPrint("Potion equipped successfully")
    task.wait(1)
  
    local args2 = {
        potionID,
        "START"
    }
    local startSuccess, startResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(args2))
    end)
  
    if not startSuccess then
        debugPrint("Failed to start using potion: " .. tostring(startResult))
        safelyUnequipFood(potionID)
        return false
    end
  
    debugPrint("Potion use started, waiting 1 second...")
    task.wait(1)
  
    local args3 = {
        "__Enum_PetObjectCreatorType_2",
        {
            additional_consume_uniques = {},
            pet_unique = PetID,
            unique_id = potionID
        }
    }
    local petObjectSuccess, petObjectResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("PetObjectAPI/CreatePetObject"):InvokeServer(unpack(args3))
    end)
  
    if not petObjectSuccess then
        debugPrint("Failed to create pet object for potion: " .. tostring(petObjectResult))
        safelyUnequipFood(potionID)
        return false
    end
  
    debugPrint("Potion consumed, waiting 2 seconds...")
    task.wait(2)
  
    safelyUnequipFood(potionID)
    debugPrint("Successfully used pet_age_potion on pet")
    return true
end

local function startAutoPotionFeeding()
    while AutoPotionMode do
        if not PetID then
            debugPrint("No pet selected for auto potion!")
            AutoPotionMode = false
            break
        end
      
        local currentPetAge = 0
        local currentPetType = nil
        local success, errorMsg = pcall(function()
            local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
            local playerData = clientData.get_data()[player.Name]
            if playerData and playerData.inventory and playerData.inventory.pets then
                for i, v in pairs(playerData.inventory.pets) do
                    if v.unique == PetID then
                        currentPetAge = v.properties.age or 0
                        currentPetType = tostring(v.id)
                        break
                    end
                end
            end
        end)
      
        if currentPetAge >= 6 then
            debugPrint("Current pet reached age 6, stopping auto potion")
            AutoPotionMode = false
            break
        end
      
        local potionUsed = usePetAgePotion()
        if not potionUsed then
            debugPrint("Failed to use potion, stopping auto potion")
            AutoPotionMode = false
            break
        end
      
        task.wait(5)
    end
end

local function toggleAutoPotionMode()
    AutoPotionMode = not AutoPotionMode
    if AutoPotionMode then
        debugPrint("Auto Potion: ENABLED (pet_age_potion only)")
        autoPotionCoroutine = coroutine.wrap(startAutoPotionFeeding)()
    else
        debugPrint("Auto Potion: DISABLED")
        autoPotionCoroutine = nil
    end
end

-- ==================================================================
-- PET HANDLING FUNCTIONS (FROM w1.txt)
-- ==================================================================
local SQUEAKY_BONE_ID = nil
local function getSqueakyBoneID()
    if SQUEAKY_BONE_ID then
        return SQUEAKY_BONE_ID
    end
 
    local success, data = pcall(function()
        return require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    end)
 
    if not success or not data or not data.inventory or not data.inventory.toys then
        debugPrint("No inventory or toys data found!")
        return nil
    end
 
    for uniqueId, toyData in pairs(data.inventory.toys) do
        if toyData.id == "squeaky_bone_default" then
            debugPrint("Found squeaky_bone_default ‚Üí ID: " .. uniqueId)
            SQUEAKY_BONE_ID = uniqueId
            return uniqueId
        end
    end
 
    debugPrint("squeaky_bone_default NOT FOUND in inventory!")
    return nil
end

local function safelyUnequipToy()
    if currentToyID then
        debugPrint("Unequipping toy: " .. currentToyID)
        local args = { currentToyID }
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(args))
        end)
     
        if success then
            debugPrint("Successfully unequipped toy")
        else
            debugPrint("Failed to unequip toy: " .. tostring(result))
        end
     
        currentToyID = nil
        task.wait(1)
    else
        debugPrint("No toy equipped to unequip - skipping")
    end
end

local function performThrowToy()
    local toyID = getSqueakyBoneID()
    if not toyID then
        debugPrint("NO squeaky_bone_default ‚Üí Play ailment skipped")
        return false
    end
 
    debugPrint("Using squeaky_bone_default ‚Üí " .. toyID)
    currentToyID = toyID
 
    local success1, err1 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/Equip"]:InvokeServer(toyID, {
            use_sound_delay = true,
            equip_as_last = false
        })
    end)
 
    if not success1 then
        debugPrint("Failed to equip toy: " .. tostring(err1))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1.2)
 
    local success2, err2 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/ServerUseTool"]:FireServer(toyID, "START")
    end)
 
    if not success2 then
        debugPrint("Failed to start using toy: " .. tostring(err2))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1)
 
    local success3, err3 = pcall(function()
        return ReplicatedStorage.API["PetObjectAPI/CreatePetObject"]:InvokeServer(
            "__Enum_PetObjectCreatorType_1",
            { reaction_name = "ThrowToyReaction", unique_id = toyID }
        )
    end)
 
    if not success3 then
        debugPrint("Failed to trigger pet reaction: " .. tostring(err3))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1.1)
 
    local success4, err4 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/ServerUseTool"]:FireServer(toyID, "END")
    end)
 
    if not success4 then
        debugPrint("Failed to end using toy: " .. tostring(err4))
        safelyUnequipToy()
        return false
    end
 
    debugPrint("squeaky_bone_default throw SUCCESS")
    return true
end

local function performThrowToySequence()
    debugPrint("Starting squeaky_bone_default throw sequence (3x)...")
    local toyID = getSqueakyBoneID()
    if not toyID then
        debugPrint("NO squeaky_bone_default ‚Üí Play ailment skipped")
        return false
    end
 
    local successfulThrows = 0
 
    for i = 1, 3 do
        if not PetFarmMode then
            debugPrint("PetFarm stopped ‚Üí canceling throw sequence")
            safelyUnequipToy()
            return false
        end
     
        debugPrint("Throw #" .. i .. " with squeaky_bone_default")
        local success, err = pcall(performThrowToy)
     
        if success and err then
            successfulThrows += 1
            debugPrint("Throw #" .. i .. " SUCCESS")
        else
            debugPrint("Throw #" .. i .. " FAILED: " .. tostring(err) .. " ‚Üí stopping sequence")
            safelyUnequipToy()
            return false
        end
     
        if i < 3 then
            for w = 1, 9 do
                if not PetFarmMode then
                    safelyUnequipToy()
                    return false
                end
                task.wait(1)
            end
        end
    end
 
    safelyUnequipToy()
    local cured = successfulThrows >= 2
    debugPrint("Throw sequence finished: " .. successfulThrows .. "/3 ‚Üí Play ailment " .. (cured and "CURED" or "NOT CURED"))
    return cured
end

local function handlePlayAilment()
    debugPrint("PLAY AILMENT DETECTED! ‚Üí Using squeaky_bone_default sequence")
    local toyID = getSqueakyBoneID()
    if not toyID then
        debugPrint("Play ailment FAILED: squeaky_bone_default not found")
        return false
    end
 
    local success, err = pcall(performThrowToySequence)
 
    if success and err then
        debugPrint("Play ailment CURED with squeaky_bone_default")
        return true
    else
        debugPrint("Play ailment FAILED: " .. tostring(err) .. " (no bone or interrupted)")
        safelyUnequipToy()
        return false
    end
end

-- Additional pet handling functions (simplified for space)
local function isPetEquipped(petUniqueID)
    local data = getPlayerData()
    if not data or not data.equip_manager or not data.equip_manager.pets then
        debugPrint("Cannot check equip status: equip_manager not found")
        return false
    end
    for _, equippedPet in pairs(data.equip_manager.pets) do
        if equippedPet and equippedPet.unique == petUniqueID then
            debugPrint("Pet " .. petUniqueID .. " is equipped (confirmed via equip_manager)")
            return true
        end
    end
    debugPrint("Pet " .. petUniqueID .. " is NOT equipped (via equip_manager)")
    return false
end

local function findPetModel(petUniqueID)
    debugPrint("Searching for pet model with ID: " .. tostring(petUniqueID))
    local data = getPlayerData()
    if not data or not data.inventory or not data.inventory.pets then
        debugPrint("Failed to get player data or pet inventory")
        return nil
    end
    for petID, petData in pairs(data.inventory.pets) do
        if petData.unique == petUniqueID then
            debugPrint("Found matching pet in inventory: " .. tostring(petData.id))
            local petsFolder = Workspace:FindFirstChild("Pets")
            if not petsFolder then
                debugPrint("Pets folder not found")
                return nil
            end
            local petModel = petsFolder:FindFirstChild(petData.id)
            if petModel then
                debugPrint("Found pet model: " .. petModel.Name)
                return petModel
            end
            for _, child in pairs(petsFolder:GetChildren()) do
                if string.lower(child.Name) == string.lower(petData.id) then
                    debugPrint("Found pet model (case-insensitive): " .. child.Name)
                    return child
                end
            end
            debugPrint("Pet model not found.")
            return nil
        end
    end
    debugPrint("No pet found with unique ID: " .. tostring(petUniqueID))
    return nil
end

local function findBestStarterPet()
    debugPrint("Searching for best starter pet...")
    local starterPets = {}
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.pets then
            for uniqueId, petData in pairs(playerData.inventory.pets) do
                if petData and petData.id and petData.properties then
                    local petName = string.lower(petData.id)
                    local age = petData.properties.age or 0
                    local isNeon = petData.properties.neon or false
                    
                    if isNeon or string.find(petName, "practice_dog") then
                        continue
                    end
                    
                    local priority = 0
                    if petName == "starter_egg" then
                        priority = 100 + age
                    elseif string.find(petName, "dog") then
                        priority = 80 + age * 2
                    elseif string.find(petName, "cat") then
                        priority = 70 + age * 2
                    end
                    
                    if priority > 0 then
                        table.insert(starterPets, {
                            unique_id = uniqueId,
                            name = petData.id,
                            age = age,
                            neon = isNeon,
                            priority = priority
                        })
                    end
                end
            end
        end
    end)
  
    if not success then
        debugPrint("Error finding starter pets: " .. tostring(errorMsg))
        return nil
    end
  
    if #starterPets == 0 then
        debugPrint("No eligible pets found!")
        return nil
    end
  
    table.sort(starterPets, function(a, b)
        return a.priority > b.priority
    end)
  
    local bestPet = starterPets[1]
    debugPrint("Selected best pet: " .. bestPet.name .. " (Age: " .. bestPet.age .. ", Priority: " .. bestPet.priority .. ")")
    return bestPet.unique_id
end

-- ==================================================================
-- AUTO PETPEN FUNCTIONS (FROM w1.txt)
-- ==================================================================
local function performNeonFusion()
    debugPrint("Checking for eligible Neon Fusion sets...")
    local fusionsPerformed = 0
    pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if not playerData or not playerData.inventory or not playerData.inventory.pets then
            debugPrint("No pet inventory data found!")
            return 0
        end
        local ageSixPetsByType = {}
        for uniqueId, petData in pairs(playerData.inventory.pets) do
            if petData.properties and (petData.properties.age or 0) == 6 and not petData.properties.neon then
                local petType = petData.id
                if not ageSixPetsByType[petType] then
                    ageSixPetsByType[petType] = {}
                end
                table.insert(ageSixPetsByType[petType], {
                    unique_id = uniqueId,
                    name = petType
                })
            end
        end
        for petType, pets in pairs(ageSixPetsByType) do
            while #pets >= 4 do
                debugPrint(string.format("Found 4+ age 6 pets of type: %s. Attempting Neon Fusion...", petType))
                local fusionSet = {}
                for i = 1, 4 do
                    table.insert(fusionSet, pets[i].unique_id)
                    debugPrint(" - Using pet: " .. pets[i].unique_id)
                end
                local success, err = pcall(function()
                    return ReplicatedStorage.API:FindFirstChild("PetAPI/DoNeonFusion"):InvokeServer(fusionSet)
                end)
                if success then
                    debugPrint(string.format("SUCCESS: Fused 4 %s into a Neon!", petType))
                    fusionsPerformed = fusionsPerformed + 1
                    for i = 1, 4 do
                        table.remove(pets, 1)
                    end
                    task.wait(3)
                else
                    debugPrint("FAILED to perform Neon Fusion: " .. tostring(err))
                    break
                end
            end
        end
        if fusionsPerformed > 0 then
            debugPrint(string.format("Neon Fusion completed: %d fusions performed", fusionsPerformed))
        else
            debugPrint("No eligible Neon Fusion sets found")
        end
    end)
    return fusionsPerformed
end

local function purgeNonPriorityGarbage()
    debugPrint("NUCLEAR PURGE: Eliminating garbage from PetPen...")
    local data = require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    local removed = 0
    if not data.idle_progression_manager or not data.idle_progression_manager.active_pets then
        debugPrint("PetPen empty or not loaded")
        return 0
    end
    for uniqueId, _ in pairs(data.idle_progression_manager.active_pets) do
        local pet = data.inventory.pets[uniqueId]
        if pet and pet.id and pet.properties then
            local cleanName = string.lower(pet.id)
            local isNeon = pet.properties.neon
            local age = pet.properties.age or 0
            if not isNeon and not prioritySet[cleanName] then
                debugPrint("REMOVING TRASH: " .. pet.id .. " (Age: " .. age .. ")")
                local success = pcall(function()
                    ReplicatedStorage.API["IdleProgressionAPI/RemovePet"]:FireServer(uniqueId)
                end)
                if success then
                    removed += 1
                    task.wait(0.7)
                else
                    debugPrint("Failed to remove: " .. pet.id)
                end
            end
        end
    end
    debugPrint("NUCLEAR PURGE COMPLETE: Removed " .. removed .. " garbage pets")
    task.wait(2)
    return removed
end

local function getPetPenSnapshot()
    local data = require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    local snapshot = {}
    if data.idle_progression_manager and data.idle_progression_manager.active_pets then
        for uniqueId, _ in pairs(data.idle_progression_manager.active_pets) do
            local pet = data.inventory.pets[uniqueId]
            if pet then
                table.insert(snapshot, {
                    name = pet.id,
                    age = pet.properties.age or 0,
                    neon = pet.properties.neon or false,
                    unique_id = uniqueId
                })
            end
        end
    end
    debugPrint("PETPEN SLOTS: " .. #snapshot .. "/4 filled")
    for i, pet in ipairs(snapshot) do
        local neon = pet.neon and "NEON" or ""
        debugPrint(string.format(" %d. %s (Age: %d) %s", i, pet.name, pet.age, neon))
    end
    return snapshot
end

local function getAvailablePets(snapshot)
    local data = require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    local inPen = {}
    for _, pet in ipairs(snapshot) do inPen[pet.unique_id] = true end
    local available = {}
    if data.inventory and data.inventory.pets then
        for uniqueId, petData in pairs(data.inventory.pets) do
            if not inPen[uniqueId] and (petData.properties.age or 0) < 6 then
                table.insert(available, {
                    unique_id = uniqueId,
                    name = petData.id,
                    age = petData.properties.age or 0,
                    neon = petData.properties.neon or false
                })
            end
        end
    end
    return available
end

local function addPriorityPets(snapshot)
    local available = getAvailablePets(snapshot)
    local slotsOpen = 4 - #snapshot
    if slotsOpen <= 0 then return 0 end
    local added = 0
    local addedSet = {}
    for _, pet in ipairs(available) do
        if pet.neon and added < slotsOpen then
            if not addedSet[pet.unique_id] then
                pcall(function() ReplicatedStorage.API["IdleProgressionAPI/AddPet"]:FireServer(pet.unique_id) end)
                debugPrint("Added NEON: " .. pet.name)
                added += 1
                addedSet[pet.unique_id] = true
                task.wait(0.6)
            end
        end
    end
    for _, eggName in ipairs(priorityEggs) do
        for _, pet in ipairs(available) do
            if pet.name == eggName and added < slotsOpen and not addedSet[pet.unique_id] then
                pcall(function() ReplicatedStorage.API["IdleProgressionAPI/AddPet"]:FireServer(pet.unique_id) end)
                debugPrint("Added PRIORITY: " .. pet.name)
                added += 1
                addedSet[pet.unique_id] = true
                task.wait(0.6)
            end
        end
    end
    while added < slotsOpen and AutoPetPenMode do
        debugPrint("Buying cracked_egg to fill slot...")
        local bought = pcall(function()
            ReplicatedStorage.API["ShopAPI/BuyItem"]:InvokeServer("pets", "cracked_egg", {buy_count = 1})
        end)
        if bought then
            task.wait(3)
            local newPets = getAvailablePets(getPetPenSnapshot())
            for _, pet in ipairs(newPets) do
                if pet.name == "cracked_egg" and not addedSet[pet.unique_id] then
                    pcall(function() ReplicatedStorage.API["IdleProgressionAPI/AddPet"]:FireServer(pet.unique_id) end)
                    debugPrint("Added PURCHASED cracked_egg")
                    added += 1
                    addedSet[pet.unique_id] = true
                    task.wait(0.6)
                    break
                end
            end
        else
            break
        end
    end
    debugPrint("Added " .. added .. " pets this cycle")
    return added
end

local function startAutoPetPen()
    while AutoPetPenMode do
        debugPrint("=== AUTO PETPEN CYCLE START ===")
        local fusionsPerformed = performNeonFusion()
        if fusionsPerformed > 0 then
            debugPrint("Neon Fusion completed, waiting 5 seconds before continuing...")
            task.wait(5)
        end
     
        purgeNonPriorityGarbage()
        local snapshot = getPetPenSnapshot()
     
        for _, pet in ipairs(snapshot) do
            if pet.age >= 6 then
                debugPrint("Removing aged pet: " .. pet.name .. " (Age: " .. pet.age .. ")")
                pcall(function() ReplicatedStorage.API["IdleProgressionAPI/RemovePet"]:FireServer(pet.unique_id) end)
                task.wait(0.7)
            end
        end
     
        task.wait(2)
        snapshot = getPetPenSnapshot()
        addPriorityPets(snapshot)
     
        if os.time() - lastPetPenCommitTime >= 300 then
            pcall(function() ReplicatedStorage.API["IdleProgressionAPI/CommitAllProgression"]:FireServer() end)
            debugPrint("Committed PetPen rewards")
            lastPetPenCommitTime = os.time()
        end
     
        debugPrint("=== AUTO PETPEN CYCLE COMPLETE ===")
        task.wait(60)
    end
end

local function toggleAutoPetPenMode()
    AutoPetPenMode = not AutoPetPenMode
    if AutoPetPenMode then
        debugPrint("Auto PetPen: ENABLED (WITH SMART NEON FUSION)")
        lastPetPenCommitTime = os.time()
        autoPetPenCoroutine = coroutine.wrap(startAutoPetPen)()
        task.spawn(purgeNonPriorityGarbage)
    else
        debugPrint("Auto PetPen: DISABLED")
    end
end

-- ==================================================================
-- PETFARM FUNCTIONS (FROM w1.txt - SIMPLIFIED)
-- ==================================================================
local function togglePetFarmMode()
    if PetFarmMode and petFarmCoroutine then
        debugPrint("PetFarm is already running, stopping first...")
        PetFarmMode = false
        task.wait(2)
    end
    PetFarmMode = not PetFarmMode
    if PetFarmMode then
        if not PetID and lastValidPetID then
            PetID = lastValidPetID
            debugPrint("Restored PetID from lastValidPetID: " .. tostring(PetID))
        end
        if not PetID then
            debugPrint("Please select a pet first!")
            PetFarmMode = false
            return
        end
        debugPrint("AILMENT-ONLY PetFarm: ENABLED with selected pet")
        lastValidPetID = PetID
        Rayfield:Notify({
            Title = "PetFarm Started",
            Content = "Now farming with selected pet",
            Duration = 5,
        })
    else
        debugPrint("AILMENT-ONLY PetFarm: DISABLED")
        petFarmCoroutine = nil
        safelyUnequipToy()
        Rayfield:Notify({
            Title = "PetFarm Stopped",
            Content = "Farming stopped",
            Duration = 3,
        })
    end
end

-- ==================================================================
-- MAIN TAB - STATS AND CONTROLS
-- ==================================================================
MainTab:CreateSection("Session Stats")

local statsLabel = MainTab:CreateLabel("Loading stats...")

local function updateStatsDisplay()
    local currentMoney, currentPotions = updateSessionEarnings()
    local recyclingPoints, crystalEggs = getRecyclingAndEggData()
    
    statsLabel:SetText(string.format(
        "üí∞ Money: %d (+%d)\nüß™ Potions: %d (+%d)\n‚ôªÔ∏è Recycling: %d\nü•ö Crystal Eggs: %d",
        currentMoney, sessionBucksEarned,
        currentPotions, sessionPotionsEarned,
        recyclingPoints, crystalEggs
    ))
end

MainTab:CreateSection("Quick Actions")

MainTab:CreateButton({
    Name = "‚ö° Auto-Start Everything",
    Callback = function()
        debugPrint("Auto-starting all features...")
        
        local bestPetID = findBestStarterPet()
        if bestPetID then
            PetID = bestPetID
            lastValidPetID = bestPetID
            petFarmPetID = bestPetID
            debugPrint("Auto-selected pet: " .. tostring(bestPetID))
            
            if petsDropdown then
                local pets = getPetListForDropdown()
                for _, pet in ipairs(pets) do
                    if pet.Value == bestPetID then
                        petsDropdown:Set({pet.Name})
                        break
                    end
                end
            end
        end
        
        if not PetFarmMode then
            togglePetFarmMode()
        end
        
        if not AutoPetPenMode then
            toggleAutoPetPenMode()
        end
        
        Rayfield:Notify({
            Title = "Auto-Start Complete",
            Content = "All features initialized and started",
            Duration = 5,
        })
    end,
})

-- ==================================================================
-- PETFARM TAB
-- ==================================================================
PetFarmTab:CreateSection("Pet Selection")

local function getPetListForDropdown()
    local pets = {}
    local data = getPlayerData()
    
    if data and data.inventory and data.inventory.pets then
        for uniqueId, petData in pairs(data.inventory.pets) do
            if petData and petData.id and petData.properties then
                local petName = tostring(petData.id)
                local age = petData.properties.age or 0
                local neon = petData.properties.neon and "Neon" or ""
                local displayName = string.format("%s (Age: %d%s)", petName, age, neon ~= "" and " "..neon or "")
                
                table.insert(pets, {
                    Name = displayName,
                    Value = uniqueId,
                    Data = petData
                })
            end
        end
    end
    
    table.sort(pets, function(a, b)
        return a.Name < b.Name
    end)
    
    return pets
end

local petOptions = getPetListForDropdown()
local petNames = {}
for _, pet in ipairs(petOptions) do
    table.insert(petNames, pet.Name)
end

if #petNames == 0 then
    table.insert(petNames, "No pets found")
end

local petsDropdown = PetFarmTab:CreateDropdown({
    Name = "Select Pet",
    Options = petNames,
    CurrentOption = {petNames[1]},
    MultipleOptions = false,
    Flag = "SelectedPet",
    Callback = function(Option)
        local selectedName = Option[1]
        for _, pet in ipairs(petOptions) do
            if pet.Name == selectedName then
                PetID = pet.Value
                lastValidPetID = PetID
                petFarmPetID = PetID
                
                if Pet then
                    pcall(function()
                        ReplicatedStorage.API["ToolAPI/Unequip"]:InvokeServer(Pet)
                    end)
                end
                
                local success, result = pcall(function()
                    Pet = ReplicatedStorage.API["ToolAPI/Equip"]:InvokeServer(PetID, {use_sound_delay = true, equip_as_last = false})
                end)
                
                if success then
                    debugPrint("Selected and equipped pet: " .. selectedName)
                    Rayfield:Notify({
                        Title = "Pet Selected",
                        Content = "Selected: " .. selectedName,
                        Duration = 3,
                    })
                else
                    debugPrint("Failed to equip pet: " .. tostring(result))
                end
                break
            end
        end
    end,
})

PetFarmTab:CreateButton({
    Name = "üîÑ Refresh Pet List",
    Callback = function()
        local newOptions = getPetListForDropdown()
        local newNames = {}
        for _, pet in ipairs(newOptions) do
            table.insert(newNames, pet.Name)
        end
        
        if #newNames == 0 then
            table.insert(newNames, "No pets found")
        end
        
        petsDropdown:Refresh(newNames)
        petOptions = newOptions
        
        Rayfield:Notify({
            Title = "Pet List Refreshed",
            Content = "Found " .. #newNames .. " pets",
            Duration = 3,
        })
    end,
})

PetFarmTab:CreateSection("PetFarm Controls")

local petFarmToggle = PetFarmTab:CreateToggle({
    Name = "PetFarm Mode",
    CurrentValue = false,
    Flag = "PetFarmToggle",
    Callback = function(Value)
        PetFarmMode = Value
        if Value then
            if not PetID then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Please select a pet first!",
                    Duration = 5,
                })
                petFarmToggle:Set(false)
                return
            end
            
            debugPrint("Starting PetFarm...")
            togglePetFarmMode()
            Rayfield:Notify({
                Title = "PetFarm Started",
                Content = "Now farming with selected pet",
                Duration = 5,
            })
        else
            debugPrint("Stopping PetFarm...")
            togglePetFarmMode()
            Rayfield:Notify({
                Title = "PetFarm Stopped",
                Content = "Farming stopped",
                Duration = 3,
            })
        end
    end,
})

-- ==================================================================
-- TRADING TAB
-- ==================================================================
TradingTab:CreateSection("Player Trading")

local function updateTradingPlayers()
    local players = Players:GetPlayers()
    local playerNames = {}
    
    for _, p in ipairs(players) do
        if p ~= player then
            table.insert(playerNames, p.Name)
        end
    end
    
    if #playerNames == 0 then
        table.insert(playerNames, "No other players")
    end
    
    if tradingPlayersDropdown then
        tradingPlayersDropdown:Refresh(playerNames)
    end
end

local initialTradingPlayers = {"Select a player"}
local tradingPlayersDropdown = TradingTab:CreateDropdown({
    Name = "Select Player to Trade",
    Options = initialTradingPlayers,
    CurrentOption = {"Select a player"},
    MultipleOptions = false,
    Flag = "TradingPlayer",
    Callback = function(Option)
        -- Callback for dropdown selection
    end,
})

TradingTab:CreateButton({
    Name = "Refresh Player List",
    Callback = function()
        updateTradingPlayers()
        Rayfield:Notify({
            Title = "Players Refreshed",
            Content = "Updated player list for trading",
            Duration = 3,
        })
    end,
})

TradingTab:CreateSection("Trade Actions")

TradingTab:CreateButton({
    Name = "Send Trade Request",
    Callback = function()
        local selectedPlayer = tradingPlayersDropdown.CurrentOption[1]
        if selectedPlayer and selectedPlayer ~= "Select a player" and selectedPlayer ~= "No other players" then
            sendTradeRequest(selectedPlayer)
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "Please select a player first!",
                Duration = 5,
            })
        end
    end,
})

TradingTab:CreateButton({
    Name = "Add All Pets to Trade",
    Callback = function()
        addAllPetsToTrade()
    end,
})

TradingTab:CreateToggle({
    Name = "Auto Trade Mode",
    CurrentValue = false,
    Flag = "AutoTradeToggle",
    Callback = function(Value)
        ContinuousMode = Value
        if Value then
            debugPrint("Auto Trade enabled")
            toggleContinuousMode()
        else
            debugPrint("Auto Trade disabled")
            toggleContinuousMode()
        end
    end,
})

TradingTab:CreateToggle({
    Name = "Auto Accept Trades",
    CurrentValue = false,
    Flag = "AutoAcceptToggle",
    Callback = function(Value)
        AutoAcceptMode = Value
        if Value then
            debugPrint("Auto Accept enabled")
            toggleAutoAcceptMode()
        else
            debugPrint("Auto Accept disabled")
            toggleAutoAcceptMode()
        end
    end,
})

-- ==================================================================
-- AUTO FEATURES TAB
-- ==================================================================
AutoTab:CreateSection("Auto Potion")

AutoTab:CreateToggle({
    Name = "Auto Age Potion",
    CurrentValue = false,
    Flag = "AutoPotionToggle",
    Callback = function(Value)
        AutoPotionMode = Value
        if Value then
            if not PetID then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Please select a pet first!",
                    Duration = 5,
                })
                return
            end
            debugPrint("Auto Potion enabled")
            toggleAutoPotionMode()
        else
            debugPrint("Auto Potion disabled")
            toggleAutoPotionMode()
        end
    end,
})

AutoTab:CreateSection("Auto PetPen")

AutoTab:CreateToggle({
    Name = "Auto PetPen Management",
    CurrentValue = false,
    Flag = "AutoPetPenToggle",
    Callback = function(Value)
        AutoPetPenMode = Value
        if Value then
            debugPrint("Auto PetPen enabled")
            toggleAutoPetPenMode()
        else
            debugPrint("Auto PetPen disabled")
            toggleAutoPetPenMode()
        end
    end,
})

AutoTab:CreateButton({
    Name = "Perform Neon Fusion",
    Callback = function()
        local fusions = performNeonFusion()
        Rayfield:Notify({
            Title = "Neon Fusion",
            Content = "Performed " .. fusions .. " fusions",
            Duration = 5,
        })
    end,
})

AutoTab:CreateButton({
    Name = "Purge Non-Priority Pets",
    Callback = function()
        local removed = purgeNonPriorityGarbage()
        Rayfield:Notify({
            Title = "Purge Complete",
            Content = "Removed " .. removed .. " non-priority pets",
            Duration = 5,
        })
    end,
})

-- ==================================================================
-- INITIALIZATION
-- ==================================================================
lastMoneyAmount, lastPotionAmount = getCurrentMoneyAndPotions()

task.wait(2)
updateTradingPlayers()
updateStatsDisplay()

coroutine.wrap(function()
    while true do
        updateTradingPlayers()
        task.wait(30)
    end
end)()

coroutine.wrap(function()
    while true do
        if petsDropdown then
            local newOptions = getPetListForDropdown()
            local newNames = {}
            for _, pet in ipairs(newOptions) do
                table.insert(newNames, pet.Name)
            end
            
            if #newNames == 0 then
                table.insert(newNames, "No pets found")
            end
            
            petsDropdown:Refresh(newNames)
            petOptions = newOptions
        end
        task.wait(60)
    end
end)()

task.wait(3)
coroutine.wrap(function()
    local bestPetID = findBestStarterPet()
    if bestPetID then
        PetID = bestPetID
        lastValidPetID = bestPetID
        petFarmPetID = bestPetID
        
        local pets = getPetListForDropdown()
        for _, pet in ipairs(pets) do
            if pet.Value == bestPetID then
                if petsDropdown then
                    petsDropdown:Set({pet.Name})
                end
                break
            end
        end
        
        debugPrint("Auto-selected best pet: " .. tostring(bestPetID))
    end
    
    if not AutoPetPenMode then
        toggleAutoPetPenMode()
    end
end)()

Rayfield:Notify({
    Title = "Cocoon PetFarm v3 Loaded",
    Content = "UI initialized with all functions\nAuto-selected best pet & started PetPen",
    Duration = 8,
})

debugPrint("Cocoon PetFarm UI successfully loaded with all functions!")
