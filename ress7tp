local function safeWaitForChild(parent, childName, timeout)
    local child = parent:FindFirstChild(childName)
    if child then return child end
    local startTime = tick()
    repeat
        child = parent:FindFirstChild(childName)
        if child then return child end
        task.wait(0.1)
    until tick() - startTime > (timeout or 5)
    warn("safeWaitForChild: Timeout waiting for " .. childName .. " in " .. parent:GetFullName())
    return nil
end

local function isNear(position, radius)
    local char = getChar()
    if not char or not char:FindFirstChild("HumanoidRootPart") then
        warn("isNear: Character or HumanoidRootPart not found!")
        return false
    end
    local hrp = char.HumanoidRootPart
    return (hrp.Position - position).Magnitude <= radius
end

local function safeTp(position)
    if not position then
        warn("safeTp: Position is nil!")
        return false
    end
    -- Replace with your actual teleport logic
    local success, err = pcall(function()
        -- Example: game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(position))
        -- Use your game's teleport method here
    end)
    if not success then
        warn("safeTp failed:", err)
        return false
    end
    return true
end

local function goToNursery()
    for attempt = 1, 3 do
        log("Teleport attempt " .. attempt .. "/3")

        -- === 1. POSITION-BASED HOUSE DETECT ===
        local char = getChar()
        if not char or not char:FindFirstChild("HumanoidRootPart") then
            warn("goToNursery: Character or HumanoidRootPart not found!")
            task.wait(2)
            continue
        end

        local hrp = char.HumanoidRootPart
        local yPos = hrp.Position.Y
        local inHouse = yPos > 100
        log("Position check: Y=" .. math.floor(yPos) .. " ‚Üí In house? " .. tostring(inHouse))

        -- === 1B. EXIT HOUSE ONLY IF DETECTED ===
        if inHouse then
            log("üè† In house ‚Üí attempting safe exit...")
            local api = safeWaitForChild(ReplicatedStorage, "API", 5)
            if api then
                local housingAPI = safeWaitForChild(api, "HousingAPI", 5)
                if housingAPI then
                    -- Try modern API first (2025)
                    local leave = housingAPI:FindFirstChild("LeaveHouse")
                    if leave then
                        local success, err = pcall(function()
                            if leave:IsA("RemoteFunction") then
                                leave:InvokeServer()
                            elseif leave:IsA("RemoteEvent") then
                                leave:FireServer()
                            end
                        end)
                        if not success then
                            warn("Failed to leave house:", err)
                        end
                    end
                    -- Fallback: Old API
                    local unsubscribe = housingAPI:FindFirstChild("UnsubscribeFromHouse")
                    if unsubscribe then
                        local success, err = pcall(function()
                            if unsubscribe:IsA("RemoteFunction") then
                                unsubscribe:InvokeServer(game.Players.LocalPlayer, true)
                            elseif unsubscribe:IsA("RemoteEvent") then
                                unsubscribe:FireServer(game.Players.LocalPlayer, true)
                            end
                        end)
                        if not success then
                            warn("Failed to unsubscribe from house:", err)
                        end
                    end
                end
            end
            task.wait(math.random(3, 5)) -- Jitter: 3-5s
        else
            log("üåç Already in public/Adoption Island ‚Üí skipping house exit")
        end

        -- === 2. TP1: Safe Midpoint ===
        local MIDPOINT = Vector3.new(-3023.66, 6529.58 + math.random(-2,2), -8975.54 + math.random(-2,2))
        if safeTp(MIDPOINT) and isNear(MIDPOINT, 10) then
            log("‚úÖ TP1: Midpoint reached")
            setCam(MIDPOINT + Vector3.new(0, 7, 0), MIDPOINT + Vector3.new(0, 0, -100))
            pressW()
        else
            log("‚ö†Ô∏è TP1 failed, retrying...")
            task.wait(2)
            continue
        end

        -- === 3. DYNAMIC WALK TO ENTRANCE ===
        local ENTRANCE = Vector3.new(-255.10, 30.89, -1831.46)
        local startTime = tick()
        local timeout = 25
        log("üö∂ Simulating walk to Nursery Entrance...")
        repeat
            task.wait(0.5 + math.random(-0.1, 0.1))
            if isNear(ENTRANCE, 55) then
                local timeTaken = tick() - startTime
                log("‚úÖ Entrance reached! (took " .. string.format("%.1f", timeTaken) .. "s)")
                task.wait(5 + math.random(-1, 1))
                break
            end
        until tick() - startTime > timeout

        if not isNear(ENTRANCE, 55) then
            log("‚è∞ Entrance timeout ‚Äî force TP2")
            -- Emergency direct TP if walk fails
        end

        -- === 4. TP2: Doorway/Interior Entry ===
        local DOORWAY = Vector3.new(-247.17, 31.50 + math.random(-1,1), -1481.08 + math.random(-1,1))
        if safeTp(DOORWAY) and isNear(DOORWAY, 10) then
            log("‚úÖ TP2: Doorway entered")
            setCam(DOORWAY + Vector3.new(0, 8, 0), DOORWAY + Vector3.new(0, 0, -100))
            pressW()
            task.wait(8 + math.random(1,3))
        end

        -- === 5. FINAL VERIFY: Pet Recycler Room ===
        local RECYCLER = Vector3.new(8975.76, 6933.83, 11953.16)
        if isNear(RECYCLER, 120) then
            resetCam()
            log("üéâ SUCCESS: Inside Nursery! Proceeding to release/claim.")
            return true
        else
            log("‚ùå Not in recycler room ‚Äî retrying attempt")
            resetCam()
            task.wait(math.random(2,4))
        end
    end

    log("üí• FAILED: Couldn't reach Nursery after 3 attempts. Check connection/anti-cheat.")
    resetCam()
    return false
end
