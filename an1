-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualUser = game:GetService("VirtualUser")
local RunService = game:GetService("RunService")

-- Local player
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

-- Create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MouseRecorderUI"
screenGui.Parent = playerGui
screenGui.ResetOnSpawn = false

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 320, 0, 200)
mainFrame.Position = UDim2.new(0.5, -160, 0, 20)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
mainFrame.BorderSizePixel = 0
mainFrame.BackgroundTransparency = 0.1
mainFrame.Parent = screenGui
local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 12)
mainCorner.Parent = mainFrame

-- Title
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 28)
title.Position = UDim2.new(0, 0, 0, 0)
title.BackgroundTransparency = 1
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Text = "üéÆ Mouse Recorder"
title.Font = Enum.Font.SourceSansBold
title.TextSize = 20
title.Parent = mainFrame

-- Status Display
local statusDisplay = Instance.new("Frame")
statusDisplay.Size = UDim2.new(1, -20, 0, 60)
statusDisplay.Position = UDim2.new(0, 10, 0, 35)
statusDisplay.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
statusDisplay.Parent = mainFrame
local statusCorner = Instance.new("UICorner")
statusCorner.CornerRadius = UDim.new(0, 8)
statusCorner.Parent = statusDisplay

-- Status Text
local statusText = Instance.new("TextLabel")
statusText.Size = UDim2.new(1, -10, 0.7, 0)
statusText.Position = UDim2.new(0, 5, 0, 5)
statusText.BackgroundTransparency = 1
statusText.TextColor3 = Color3.fromRGB(255, 255, 255)
statusText.Text = "Status: Ready"
statusText.Font = Enum.Font.SourceSansBold
statusText.TextSize = 16
statusText.TextXAlignment = Enum.TextXAlignment.Left
statusText.Parent = statusDisplay

-- Info Text
local infoText = Instance.new("TextLabel")
infoText.Size = UDim2.new(1, -10, 0.3, 0)
infoText.Position = UDim2.new(0, 5, 0.7, 0)
infoText.BackgroundTransparency = 1
infoText.TextColor3 = Color3.fromRGB(200, 200, 200)
infoText.Text = "Clicks: 0 | Position: (0, 0)"
infoText.Font = Enum.Font.SourceSans
infoText.TextSize = 14
infoText.TextXAlignment = Enum.TextXAlignment.Left
infoText.Parent = statusDisplay

-- Control Buttons Frame
local buttonsFrame = Instance.new("Frame")
buttonsFrame.Size = UDim2.new(1, -20, 0, 80)
buttonsFrame.Position = UDim2.new(0, 10, 0, 105)
buttonsFrame.BackgroundTransparency = 1
buttonsFrame.Parent = mainFrame

-- Create button template function
local function createControlButton(name, text, color, positionX)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = UDim2.new(0, 70, 0, 36)
    button.Position = UDim2.new(positionX, 0, 0, 0)
    button.BackgroundColor3 = color
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Text = text
    button.Font = Enum.Font.SourceSansBold
    button.TextSize = 14
    button.Parent = buttonsFrame
    
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = button
    
    return button
end

-- Create control buttons
local recordButton = createControlButton("Record", "‚è∫ REC", Color3.fromRGB(255, 50, 50), 0)
local playButton = createControlButton("Play", "‚ñ∂ PLAY", Color3.fromRGB(50, 200, 50), 0.25)
local stopButton = createControlButton("Stop", "‚èπ STOP", Color3.fromRGB(100, 100, 100), 0.5)
local pauseButton = createControlButton("Pause", "‚è∏ PAUSE", Color3.fromRGB(255, 180, 0), 0.75)

-- Mouse click functions
local mouse1press, mouse1release
if mousemoverel then
    mouse1press = mouse1press or (function()
        VirtualUser:ClickButton1(Vector2.new(0, 0))
    end)
    mouse1release = mouse1release or (function()
        -- Some exploits may have mouse1release, if not we'll just use a delay
    end)
end

-- Recorder Variables
local recordedClicks = {}
local isRecording = false
local isPlaying = false
local isPaused = false
local recordingStartTime = 0
local playStartTime = 0
local currentPlayIndex = 1
local mouseClickConnection = nil
local playThread = nil

-- Function to get current mouse position
local function getMousePosition()
    if UserInputService.MouseEnabled then
        return UserInputService:GetMouseLocation()
    end
    return Vector2.new(0, 0)
end

-- Function to simulate click at position
local function clickAtPosition(position)
    print("Clicking at position:", position.X, position.Y)
    
    -- First move mouse to position (if mousemoverel is available)
    if mousemoverel then
        local currentPos = getMousePosition()
        mousemoverel(position.X - currentPos.X, position.Y - currentPos.Y)
        task.wait(0.01)
    end
    
    -- Then click
    if mouse1press and mouse1release then
        mouse1press()
        task.wait(0.05)
        mouse1release()
    else
        VirtualUser:ClickButton1(position)
    end
    return position
end

-- Function to update status display
local function updateStatus()
    local status = "Ready"
    local statusColor = Color3.fromRGB(100, 255, 100)
    
    if isRecording then
        status = "Recording..."
        statusColor = Color3.fromRGB(255, 100, 100)
    elseif isPlaying then
        if isPaused then
            status = string.format("Paused (%d/%d)", currentPlayIndex - 1, #recordedClicks)
            statusColor = Color3.fromRGB(255, 200, 0)
        else
            status = string.format("Playing (%d/%d)", currentPlayIndex - 1, #recordedClicks)
            statusColor = Color3.fromRGB(100, 255, 100)
        end
    end
    
    statusText.Text = "Status: " .. status
    statusText.TextColor3 = statusColor
    
    local mousePos = getMousePosition()
    infoText.Text = string.format("Clicks: %d | Position: (%d, %d)", #recordedClicks, mousePos.X, mousePos.Y)
end

-- Function to start recording
local function startRecording()
    if isPlaying then 
        stopPlayback()
        task.wait(0.1)
    end
    
    recordedClicks = {}
    isRecording = true
    recordingStartTime = tick()
    
    -- Disconnect previous connection if exists
    if mouseClickConnection then
        mouseClickConnection:Disconnect()
        mouseClickConnection = nil
    end
    
    -- Connect mouse click listener
    mouseClickConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton1 then
            local currentTime = tick() - recordingStartTime
            local position = getMousePosition()
            
            table.insert(recordedClicks, {
                time = currentTime,
                position = position,
                x = position.X,
                y = position.Y
            })
            
            print(string.format("Recorded click at %.2fs: (%d, %d)", currentTime, position.X, position.Y))
            updateStatus()
        end
    end)
    
    print("Recording started...")
    updateStatus()
end

-- Function to stop recording
local function stopRecording()
    if isRecording then
        isRecording = false
        if mouseClickConnection then
            mouseClickConnection:Disconnect()
            mouseClickConnection = nil
        end
        print("Recording stopped. Total clicks: " .. #recordedClicks)
        updateStatus()
    end
end

-- Function to play recorded clicks
local function playRecording()
    if isRecording or #recordedClicks == 0 then 
        if #recordedClicks == 0 then
            print("No clicks recorded!")
        end
        return 
    end
    
    if isPlaying and not isPaused then
        print("Already playing!")
        return
    end
    
    -- If paused, resume from current position
    if not isPaused then
        currentPlayIndex = 1
        playStartTime = tick()
    end
    
    isPlaying = true
    isPaused = false
    
    -- Kill previous play thread if exists
    if playThread then
        coroutine.close(playThread)
        playThread = nil
    end
    
    -- Create new play thread
    playThread = coroutine.create(function()
        print("Starting playback of " .. #recordedClicks .. " clicks...")
        
        while currentPlayIndex <= #recordedClicks and isPlaying do
            local click = recordedClicks[currentPlayIndex]
            local currentTime = tick() - playStartTime
            
            -- Check if we need to wait
            if currentTime < click.time then
                local waitTime = click.time - currentTime
                task.wait(waitTime)
            end
            
            -- Check again if still playing after waiting
            if not isPlaying or isPaused then
                if isPaused then
                    print("Playback paused at click " .. currentPlayIndex)
                end
                break
            end
            
            -- Click at the recorded position
            local clickedPos = clickAtPosition(click.position)
            print(string.format("Playing click %d/%d at (%.2fs): (%d, %d)", 
                currentPlayIndex, #recordedClicks, click.time, clickedPos.X, clickedPos.Y))
            
            currentPlayIndex += 1
            updateStatus()
        end
        
        -- Check if we finished normally
        if currentPlayIndex > #recordedClicks and isPlaying then
            print("Playback completed!")
            isPlaying = false
            currentPlayIndex = 1
        end
        
        updateStatus()
    end)
    
    -- Start the play thread
    coroutine.resume(playThread)
    updateStatus()
end

-- Function to stop playback/recording
local function stopPlayback()
    isRecording = false
    isPlaying = false
    isPaused = false
    currentPlayIndex = 1
    
    -- Disconnect recording connection
    if mouseClickConnection then
        mouseClickConnection:Disconnect()
        mouseClickConnection = nil
    end
    
    -- Kill play thread
    if playThread then
        coroutine.close(playThread)
        playThread = nil
    end
    
    print("Stopped")
    updateStatus()
end

-- Function to pause/resume playback
local function togglePause()
    if not isPlaying then return end
    
    isPaused = not isPaused
    
    if isPaused then
        print("Playback paused")
    else
        print("Playback resumed")
        playStartTime = tick() - recordedClicks[currentPlayIndex - 1].time
        playRecording()  -- Resume playback
    end
    
    updateStatus()
end

-- Button click handlers
recordButton.MouseButton1Click:Connect(function()
    if not isRecording then
        startRecording()
    else
        stopRecording()
    end
end)

playButton.MouseButton1Click:Connect(function()
    if not isPlaying then
        playRecording()
    elseif isPaused then
        togglePause()  -- This will resume
    else
        print("Already playing!")
    end
end)

stopButton.MouseButton1Click:Connect(function()
    stopPlayback()
end)

pauseButton.MouseButton1Click:Connect(function()
    togglePause()
end)

-- Update mouse position in real-time
spawn(function()
    while true do
        if not isRecording then
            updateStatus()
        end
        task.wait(0.1)
    end
end)

-- Initial status update
updateStatus()

print("Mouse Recorder UI Loaded!")
print("Controls:")
print("‚è∫ REC - Start/Stop recording mouse clicks")
print("‚ñ∂ PLAY - Play recorded clicks")
print("‚èπ STOP - Stop playback/recording")
print("‚è∏ PAUSE - Pause/Resume playback")

-- Function to export recorded clicks
local function exportClicks()
    if #recordedClicks == 0 then
        print("No clicks to export!")
        return ""
    end
    
    local exportStr = "-- Recorded Mouse Clicks\n"
    exportStr = exportStr .. "local recordedClicks = {\n"
    for i, click in ipairs(recordedClicks) do
        exportStr = exportStr .. string.format("    {time = %.3f, x = %d, y = %d},\n", click.time, click.x, click.y)
    end
    exportStr = exportStr .. "}\n\n"
    exportStr = exportStr .. "-- Function to play clicks\n"
    exportStr = exportStr .. "local function playClicks()\n"
    exportStr = exportStr .. "    for i, click in ipairs(recordedClicks) do\n"
    exportStr = exportStr .. "        if i > 1 then\n"
    exportStr = exportStr .. "            local waitTime = click.time - recordedClicks[i-1].time\n"
    exportStr = exportStr .. "            if waitTime > 0 then\n"
    exportStr = exportStr .. "                wait(waitTime)\n"
    exportStr = exportStr .. "            end\n"
    exportStr = exportStr .. "        else\n"
    exportStr = exportStr .. "            wait(click.time)\n"
    exportStr = exportStr .. "        end\n"
    exportStr = exportStr .. "        clickAtPosition(Vector2.new(click.x, click.y))\n"
    exportStr = exportStr .. "    end\n"
    exportStr = exportStr .. "end\n"
    
    print("\n=== EXPORTED CLICKS ===")
    print(exportStr)
    print("=== END EXPORT ===")
    
    return exportStr
end

-- Optional: Add export button
local exportButton = Instance.new("TextButton")
exportButton.Name = "Export"
exportButton.Size = UDim2.new(0, 100, 0, 28)
exportButton.Position = UDim2.new(0.5, -50, 0, 190)
exportButton.BackgroundColor3 = Color3.fromRGB(80, 80, 180)
exportButton.TextColor3 = Color3.fromRGB(255, 255, 255)
exportButton.Text = "üìã Export"
exportButton.Font = Enum.Font.SourceSans
exportButton.TextSize = 14
exportButton.Parent = mainFrame

local exportCorner = Instance.new("UICorner")
exportCorner.CornerRadius = UDim.new(0, 6)
exportCorner.Parent = exportButton

exportButton.MouseButton1Click:Connect(function()
    if #recordedClicks > 0 then
        exportClicks()
        statusText.Text = "Exported to console!"
        task.wait(2)
        updateStatus()
    else
        statusText.Text = "No clicks to export!"
        task.wait(1)
        updateStatus()
    end
end)

-- Test function to add some sample clicks
local function addTestClicks()
    recordedClicks = {
        {time = 0.5, x = 100, y = 100, position = Vector2.new(100, 100)},
        {time = 1.0, x = 200, y = 200, position = Vector2.new(200, 200)},
        {time = 1.5, x = 300, y = 300, position = Vector2.new(300, 300)},
        {time = 2.0, x = 400, y = 400, position = Vector2.new(400, 400)},
    }
    updateStatus()
    print("Added 4 test clicks for debugging")
end

-- Uncomment to add test clicks for debugging
-- addTestClicks()
