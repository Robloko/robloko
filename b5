-- Baby Farm Script
-- Place this as a LocalScript in StarterPlayerScripts or similar
-- This script monitors and handles baby ailments using furniture logic from the main PetFarm

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Player
local player = Players.LocalPlayer

-- Debug settings
local DEBUG_MODE = true

-- Baby Farm variables
local BabyFarmMode = false
local babyFarmCoroutine = nil

-- Ailment to Furniture Mapping (simplified for babies, only basic furniture and special for hungry/thirsty/sick)
local BABY_AILMENT_TASKS = {
    sleepy = "BasicBed",
    hungry = "teachers_apple", 
    thirsty = "water",
    dirty = "CheapPetBathtub",
    bored = "Piano",
    sick = "healing_apple"
}

-- Task cooldowns to prevent spam
local lastTaskTime = {}
local TASK_COOLDOWN = 30 -- seconds

-- Debug function
local function debugPrint(message)
    if not DEBUG_MODE then return end
    local hours = os.date("%H")
    local minutes = os.date("%M")
    local seconds = os.date("%S")
    local timestamp = string.format("[%s:%s:%s]", hours, minutes, seconds)
    print(timestamp .. " [BabyFarm] " .. message)
end

-- Function to safely get player data (from provided snippet)
local function getPlayerData()
    local clientModules = ReplicatedStorage:WaitForChild("ClientModules", 10)
    if not clientModules then return nil end
    local coreModule = clientModules:WaitForChild("Core", 5)
    if not coreModule then return nil end
    local clientDataModule = coreModule:WaitForChild("ClientData", 5)
    if not clientDataModule then return nil end
    
    local clientData
    local success, err = pcall(function()
        clientData = require(clientDataModule)
    end)
    if not success or not clientData then return nil end
    
    local playerData
    success, err = pcall(function()
        playerData = clientData.get_data()[player.Name]
    end)
    if not success or not playerData then return nil end
    
    return playerData
end

-- Enhanced helper to extract ailment key from potentially table-structured ailment
local function extractAilmentKey(ailment)
    if type(ailment) == "table" then
        -- Try common fields first
        local candidates = {"type", "name", "ailment", "id", "key", "kind"}
        for _, field in ipairs(candidates) do
            local val = ailment[field]
            if type(val) == "string" then
                local lowerVal = val:lower()
                if BABY_AILMENT_TASKS[lowerVal] then
                    debugPrint("Extracted ailment '" .. lowerVal .. "' from field '" .. field .. "'")
                    return lowerVal
                end
            end
        end
        -- If no direct match, search all string values for known ailments
        for k, v in pairs(ailment) do
            if type(v) == "string" then
                local lowerV = v:lower()
                if BABY_AILMENT_TASKS[lowerV] then
                    debugPrint("Found matching ailment string '" .. lowerV .. "' in table key '" .. tostring(k) .. "'")
                    return lowerV
                end
            elseif type(v) == "table" then
                -- Recurse into sub-tables if needed
                local subKey = extractAilmentKey(v)
                if subKey ~= "unknown" then
                    return subKey
                end
            end
        end
        -- If still unknown, debug the structure
        debugPrint("Unknown ailment table structure for debugging:")
        for k, v in pairs(ailment) do
            debugPrint(" Key: " .. tostring(k) .. " = " .. tostring(v) .. " (type: " .. type(v) .. ")")
        end
        return "unknown"
    else
        local str = tostring(ailment):lower()
        if BABY_AILMENT_TASKS[str] then
            return str
        end
        return str
    end
end

-- Function to print available baby ailments in compact form
local function printAvailableBabyAilmentsCompact()
    debugPrint("üîç BABY AILMENTS (COMPACT)")
    debugPrint("=========================")
    local playerData = getPlayerData()
    if not playerData or not playerData.ailments_manager or not playerData.ailments_manager.baby_ailments then
        debugPrint("No baby ailments found.")
        return
    end
    
    local babyAilments = playerData.ailments_manager.baby_ailments
    local count = 0
    local actionableCount = 0
    
    debugPrint(string.format("%-5s %-36s %-15s %-10s", "No.", "Pet Unique ID", "Ailment", "Actionable"))
    debugPrint(string.rep("-", 70))
    
    for petUniqueID, ailment in pairs(babyAilments) do
        local ailmentKey = extractAilmentKey(ailment)
        local isActionable = BABY_AILMENT_TASKS[ailmentKey] and ailmentKey ~= "unknown"
        if isActionable then actionableCount = actionableCount + 1 end
        count = count + 1
        local status = isActionable and "YES" or "NO"
        debugPrint(string.format("%-5d %-36s %-15s %-10s", count, petUniqueID:sub(1, 36), ailmentKey, status))
    end
    
    debugPrint(string.rep("-", 70))
    debugPrint(string.format("Total baby ailments: %d (Actionable: %d)", count, actionableCount))
end

-- Character validation
local function getValidCharacter()
    local currentChar = player.Character
    if currentChar and currentChar.Parent and currentChar:FindFirstChild("HumanoidRootPart") then
        return currentChar
    end
    debugPrint("Character not found or invalid, waiting for CharacterAdded...")
    local character = player.CharacterAdded:Wait()
    local startTime = os.time()
    while os.time() - startTime < 10 do
        if character and character.Parent and character:FindFirstChild("HumanoidRootPart") then
            debugPrint("Character loaded successfully")
            return character
        end
        task.wait(0.5)
    end
    debugPrint("Failed to load valid character after waiting")
    return nil
end

-- Ensure character is spawned and valid
local function ensureCharacterSpawned()
    local char = getValidCharacter()
    if not char then
        debugPrint("Respawning character...")
        pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("TeamAPI/Spawn"):InvokeServer()
        end)
        task.wait(5)
        char = getValidCharacter()
    end
    return char
end

-- Select Baby team
local function selectBabyTeam()
    debugPrint("Selecting Baby team...")
    local args = {
        "Babies",
        {
            dont_respawn = true,
            source_for_logging = "avatar_editor"
        }
    }
    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("TeamAPI/ChooseTeam"):InvokeServer(unpack(args))
    end)
    if success then
        debugPrint("Successfully selected Baby team")
        return true
    else
        debugPrint("Failed to select Baby team: " .. tostring(result))
        return false
    end
end

-- Check if player is at home
local function isPlayerAtHome()
    local hi = Workspace:FindFirstChild("HouseInteriors")
    if not hi then
        return false
    end
    local playerLower = string.lower(player.Name)
    for _, folder in ipairs(hi:GetChildren()) do
        local folderLower = string.lower(folder.Name)
        if string.find(folderLower, playerLower) then
            debugPrint("DEBUG: Found home folder matching player name: " .. folder.Name .. " (contains '" .. playerLower .. "')")
            return true
        end
    end
    debugPrint("DEBUG: No home folder found for player '" .. player.Name .. "' (" .. playerLower .. "). Available folders:")
    for _, folder in ipairs(hi:GetChildren()) do
        debugPrint("DEBUG: Available folder: '" .. folder.Name .. "'")
    end
    return false
end

-- Dynamic function to find player's home folder (case insensitive)
local function findHomeFolder()
    local hi = Workspace:FindFirstChild("HouseInteriors")
    if not hi then
        debugPrint("HouseInteriors folder not found")
        return nil
    end
    
    local playerLower = string.lower(player.Name)
    for _, folder in ipairs(hi:GetChildren()) do
        local folderLower = string.lower(folder.Name)
        if string.find(folderLower, playerLower) then
            debugPrint("Found home folder: " .. folder.Name .. " (matched '" .. playerLower .. "' in '" .. folderLower .. "')")
            return folder
        end
    end
    
    debugPrint("No home folder found containing player name '" .. player.Name .. "' (" .. playerLower .. "). Available folders:")
    for _, folder in ipairs(hi:GetChildren()) do
        debugPrint("Available folder: '" .. folder.Name .. "'")
    end
    return nil
end

-- Extract furniture data (from w1.txt)
local function extractFurnitureData(model, folderName)
    local activationParts = {"UseBlock", "Seat1"}
    local folderId = string.match(folderName, "f%-%d+") or folderName
    
    for _, partName in ipairs(activationParts) do
        local useBlocksFolder = model:FindFirstChild("UseBlocks")
        if useBlocksFolder then
            local part = useBlocksFolder:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                debugPrint("Using " .. partName .. " in UseBlocks folder")
                return {
                    folderId = folderId,
                    partName = partName,
                    position = part.Position,
                    cframe = part.CFrame,
                    model = model
                }
            end
        end
        
        local part = model:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            debugPrint("Using " .. partName .. " directly in model")
            return {
                folderId = folderId,
                partName = partName,
                position = part.Position,
                cframe = part.CFrame,
                model = model
            }
        end
    end
    
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            debugPrint("Using fallback part: " .. part.Name)
            return {
                folderId = folderId,
                partName = part.Name,
                position = part.Position,
                cframe = part.CFrame,
                model = model
            }
        end
    end
    
    return nil
end

-- Find furniture by name (from w1.txt)
local function findFurnitureByName(name)
    debugPrint("Searching for furniture: " .. name)
    local hi = Workspace:FindFirstChild("HouseInteriors")
    if hi then
        for _, folder in ipairs(hi:GetChildren()) do
            if string.find(folder.Name, player.Name) or string.find(folder.Name, "f%-%d+") then
                local model = folder:FindFirstChild(name)
                if model and model:IsA("Model") then
                    debugPrint("Found " .. name .. " in " .. folder.Name)
                    return extractFurnitureData(model, folder.Name)
                end
            end
        end
    end
    
    local model = Workspace:FindFirstChild(name, true)
    if model and model:IsA("Model") then
        debugPrint("Found " .. name .. " in workspace (fallback)")
        local folderId = model.Parent and string.match(model.Parent.Name, "f%-%d+") or "unknown"
        return extractFurnitureData(model, folderId)
    end
    
    debugPrint("Furniture not found: " .. name)
    return nil
end

-- Enhanced ExitSeatStates call with retry logic
local function callExitSeatStatesForLocalPlayer()
    debugPrint("Calling ExitSeatStates for localPlayer to reset seat states...")
    
    -- Try multiple times with delays
    for i = 1, 3 do
        local success, result = pcall(function()
            return game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("AdoptAPI/ExitSeatStates"):FireServer()
        end)
        if success then
            debugPrint("Successfully called ExitSeatStates for localPlayer (attempt " .. i .. ")")
        else
            debugPrint("Failed to call ExitSeatStates for localPlayer (attempt " .. i .. "): " .. tostring(result))
        end
        task.wait(0.5)
    end
    
    -- Also force character to stand up locally
    local char = player.Character
    if char and char:FindFirstChild("Humanoid") then
        char.Humanoid.Sit = false
        debugPrint("Forced local character to stand up")
    end
end

-- Activate furniture with localPlayer (updated to use HousingAPI/ActivateFurniture)
local function activateFurniture(furnitureName)
    local furnitureData = findFurnitureByName(furnitureName)
    if not furnitureData then
        debugPrint("Cannot activate furniture: " .. furnitureName .. " - not found")
        return false
    end
    
    local char = player.Character
    if not char then
        debugPrint("Cannot activate furniture: No character found")
        return false
    end
    
    local args = {
        player,
        furnitureData.folderId,
        furnitureData.partName,
        {
            cframe = furnitureData.cframe
        },
        char  -- Use localPlayer character instead of pet
    }
    
    debugPrint("Activating " .. furnitureName .. " in folder " .. furnitureData.folderId .. " with part " .. furnitureData.partName)
    
    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("HousingAPI/ActivateFurniture"):InvokeServer(unpack(args))
    end)
    
    if success then
        debugPrint("Successfully activated: " .. furnitureName)
        return true
    else
        debugPrint("Failed to activate: " .. furnitureName .. " - " .. tostring(result))
        return false
    end
end

-- Alternative furniture activation method using different API
local function activateFurnitureAlternative(furnitureName)
    local furnitureData = findFurnitureByName(furnitureName)
    if not furnitureData then
        debugPrint("Cannot activate furniture: " .. furnitureName .. " - not found")
        return false
    end
    
    local char = player.Character
    if not char then
        debugPrint("Cannot activate furniture: No character found")
        return false
    end
    
    -- Try alternative activation method
    debugPrint("Trying alternative activation for: " .. furnitureName)
    
    local success, result = pcall(function()
        -- Sometimes furniture can be activated by touching the part directly
        local humanoidRootPart = char:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart and furnitureData.model then
            -- Move character to furniture
            humanoidRootPart.CFrame = furnitureData.cframe * CFrame.new(0, 0, 3)
            task.wait(1)
            
            -- Try interacting with the furniture
            for _, part in ipairs(furnitureData.model:GetDescendants()) do
                if part:IsA("BasePart") and (part.Name == "UseBlock" or part.Name == "Seat1" or part.Name == "TouchInterest") then
                    -- Fire touch events if possible
                    if part:FindFirstChildOfClass("TouchTransmitter") then
                        debugPrint("Found TouchTransmitter, attempting interaction")
                    end
                end
            end
        end
        
        return true
    end)
    
    if success then
        debugPrint("Alternative activation completed for: " .. furnitureName)
        return true
    else
        debugPrint("Alternative activation failed: " .. tostring(result))
        return false
    end
end

-- FIXED: Furniture usage with PROPER exit after activation
local function useFurnitureWithLocalPlayer(furnitureName)
    debugPrint("Using FIXED furniture method for: " .. furnitureName)
    
    -- First ensure clean state
    callExitSeatStatesForLocalPlayer()
    task.wait(2)
    
    local char = player.Character
    if char and char:FindFirstChild("Humanoid") then
        char.Humanoid.Sit = false
    end
    task.wait(1)
    
    -- Try primary method first
    local success = activateFurniture(furnitureName)
    
    if not success then
        debugPrint("Primary activation failed, trying alternative method...")
        success = activateFurnitureAlternative(furnitureName)
    end
    
    if success then
        debugPrint("Furniture activation successful, waiting for cure completion...")
        
        -- Wait for the furniture action to complete (shorter wait since we'll exit manually)
        local waitTime = 8  -- Reduced from 15 to 8 seconds
        local checkInterval = 1
        local checks = waitTime / checkInterval
        
        for i = 1, checks do
            -- Check if we're in sitting state (which means we're using the furniture)
            if char and char:FindFirstChild("Humanoid") and char.Humanoid.Sit then
                debugPrint("Character is sitting in furniture (" .. i .. "/" .. checks .. ")")
            else
                debugPrint("Character not sitting, furniture use may be complete")
            end
            task.wait(checkInterval)
        end
        
        -- FORCE EXIT after furniture use - THIS IS THE KEY FIX
        debugPrint("FORCING EXIT from furniture after completion...")
        callExitSeatStatesForLocalPlayer()
        task.wait(2)
        
        -- Additional forced standing
        if char and char:FindFirstChild("Humanoid") then
            char.Humanoid.Sit = false
            debugPrint("Forced character to stand up after furniture use")
        end
        
        -- Wait a bit more to ensure the ailment is cured
        task.wait(2)
        
        debugPrint("Furniture use cycle completed for: " .. furnitureName)
        return true
    else
        debugPrint("All activation methods failed for: " .. furnitureName)
        return false
    end
end

-- [Rest of the functions remain the same - buyTeachersApple, findTeachersApple, useTeachersApple, handleHungryAilment, etc.]

-- Main monitoring loop for baby ailments
local function monitorAndHandleBabyAilments()
    debugPrint("Starting baby ailment monitoring...")
    local lastScanTime = 0
    local SCAN_INTERVAL = 10 -- seconds
    local currentTime = os.time()
    
    while BabyFarmMode do
        currentTime = os.time()
        local playerData = getPlayerData()
        
        if playerData and playerData.ailments_manager and playerData.ailments_manager.baby_ailments then
            local foundActionable = false
            
            for petUniqueID, ailmentType in pairs(playerData.ailments_manager.baby_ailments) do
                local ailmentKey = extractAilmentKey(ailmentType)
                local furnitureName = BABY_AILMENT_TASKS[ailmentKey]
                
                if furnitureName then
                    foundActionable = true
                    -- Check cooldown
                    if not lastTaskTime[ailmentKey] or (currentTime - lastTaskTime[ailmentKey]) >= TASK_COOLDOWN then
                        if ailmentKey == "hungry" then
                            debugPrint("Baby hungry ailment detected for pet: " .. petUniqueID .. " ‚Üí Using teachers_apple on localPlayer")
                            local success = handleHungryAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "thirsty" then
                            debugPrint("Baby thirsty ailment detected for pet: " .. petUniqueID .. " ‚Üí Using water on localPlayer")
                            local success = handleThirstyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "sick" then
                            debugPrint("Baby sick ailment detected for pet: " .. petUniqueID .. " ‚Üí Using healing_apple on localPlayer")
                            local success = handleSickAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        else
                            debugPrint("Baby " .. ailmentKey .. " ailment detected for pet: " .. petUniqueID .. " ‚Üí Using " .. furnitureName .. " on localPlayer")
                            local success = useFurnitureWithLocalPlayer(furnitureName)
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        end
                        break -- Handle one at a time
                    else
                        debugPrint(ailmentKey .. " on cooldown (" .. (TASK_COOLDOWN - (currentTime - lastTaskTime[ailmentKey])) .. "s remaining)")
                    end
                end
            end
            
            if not foundActionable and currentTime - lastScanTime >= 60 then
                debugPrint("No actionable baby ailments detected")
                lastScanTime = currentTime
            end
        else
            if currentTime - lastScanTime >= 60 then
                debugPrint("No baby ailments data found")
                lastScanTime = currentTime
            end
        end
        
        task.wait(SCAN_INTERVAL)
    end
end

-- [Rest of the script remains the same - toggleBabyFarmMode, createSimpleUI, etc.]

-- Initialize
createSimpleUI()
debugPrint("Baby Farm Script Loaded! Toggle via UI button.")
debugPrint("FIXED: Now properly exits furniture after activation with forced ExitSeatStates calls.")
debugPrint("UPDATED: Shorter wait times (8s) with active monitoring and guaranteed exit.")
