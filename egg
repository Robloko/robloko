-- ==================================================================
-- TEST FUNCTION: CONTINUOUS EGG TRADING WITH AUTO ACCEPT/CONFIRM
-- ==================================================================

-- Egg trading variables for testing
local TestEggMode = false
local testEggCoroutine = nil
local lastTestTradeTime = 0
local TRADE_COOLDOWN = 10 -- seconds between trade attempts

-- Function to get all egg IDs from inventory (TEST VERSION)
local function getAllEggIDsFromInventory_TEST()
    local targetEggs = {
        "pet_recycler_2025_basic_egg",
        "pet_recycler_2025_crystal_egg"
    }
    
    local eggIDs = {}
    
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.pets then
            for petIndex, petData in pairs(playerData.inventory.pets) do
                if petData and petData.unique and petData.id then
                    local petName = tostring(petData.id):lower()
                    for _, targetEgg in ipairs(targetEggs) do
                        if petName == targetEgg then
                            table.insert(eggIDs, petData.unique)
                            debugPrint("[TEST] Found egg: " .. petName .. " (" .. petData.unique .. ")")
                            break
                        end
                    end
                end
            end
        end
    end)
    
    if not success then
        debugPrint("[TEST] Error getting egg IDs: " .. tostring(errorMsg))
    end
    
    debugPrint("[TEST] Total eggs found: " .. #eggIDs)
    return eggIDs
end

-- Function to add eggs to current trade (TEST VERSION)
local function addAllEggsToCurrentTrade_TEST()
    debugPrint("[TEST] Adding eggs to current trade...")
    local eggIDs = getAllEggIDsFromInventory_TEST()
    if #eggIDs == 0 then 
        debugPrint("[TEST] No eggs found to add to trade")
        return 0
    end
    
    -- Limit to 16 eggs per trade
    local maxEggs = math.min(#eggIDs, 16)
    debugPrint("[TEST] Adding " .. maxEggs .. " eggs to trade")
    
    local addedCount = 0
    for i = 1, maxEggs do
        local eggID = eggIDs[i]
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AddItemToOffer"):FireServer(eggID)
        end)
        
        if success then
            addedCount = addedCount + 1
            debugPrint("[TEST] Added egg " .. i .. "/" .. maxEggs .. " to trade")
        else
            debugPrint("[TEST] Failed to add egg: " .. tostring(err))
        end
        task.wait(0.2)
    end
    
    debugPrint("[TEST] Finished adding " .. addedCount .. " eggs to trade")
    return addedCount
end

-- Function to find any online player for testing
local function findAnyOnlinePlayer_TEST()
    local players = Players:GetPlayers()
    local localPlayer = Players.LocalPlayer
    
    for _, targetPlayer in ipairs(players) do
        if targetPlayer ~= localPlayer then
            debugPrint("[TEST] Found online player: " .. targetPlayer.Name)
            return targetPlayer
        end
    end
    
    debugPrint("[TEST] No other players online")
    return nil
end

-- Function to send trade request to any player (TEST VERSION)
local function sendTradeRequestToAnyPlayer_TEST()
    local targetPlayer = findAnyOnlinePlayer_TEST()
    if not targetPlayer then
        debugPrint("[TEST] No target player available")
        return nil
    end
    
    debugPrint("[TEST] Sending trade request to: " .. targetPlayer.Name)
    
    local success, err = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/SendTradeRequest"):FireServer(targetPlayer)
    end)
    
    if success then
        debugPrint("[TEST] Trade request sent successfully")
        return targetPlayer
    else
        debugPrint("[TEST] Failed to send trade request: " .. tostring(err))
        return nil
    end
end

-- Complete trade process with auto accept/confirm (TEST VERSION)
local function completeTradeProcess_TEST(targetPlayer)
    if not targetPlayer then
        debugPrint("[TEST] No target player for trade")
        return false
    end
    
    debugPrint("[TEST] Starting complete trade process with: " .. targetPlayer.Name)
    
    -- STEP 1: Accept trade request automatically
    local args = { targetPlayer, true }
    local success1, result1 = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptOrDeclineTradeRequest"):InvokeServer(unpack(args))
    end)
    
    if not success1 then
        debugPrint("[TEST] Failed to accept trade request: " .. tostring(result1))
        return false
    end
    
    debugPrint("[TEST] Trade request accepted, waiting 3 seconds...")
    task.wait(3)
    
    -- STEP 2: Add all eggs to trade
    local eggsAdded = addAllEggsToCurrentTrade_TEST()
    if eggsAdded == 0 then
        debugPrint("[TEST] No eggs added, cancelling trade")
        return false
    end
    
    debugPrint("[TEST] Waiting 3 seconds after adding eggs...")
    task.wait(3)
    
    -- STEP 3: Accept negotiation automatically
    local success2, result2 = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptNegotiation"):FireServer()
    end)
    
    if not success2 then
        debugPrint("[TEST] Failed to accept negotiation: " .. tostring(result2))
        return false
    end
    
    debugPrint("[TEST] Negotiation accepted, waiting 9 seconds for confirmation...")
    task.wait(9)
    
    -- STEP 4: Confirm trade automatically
    local success3, result3 = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ConfirmTrade"):FireServer()
    end)
    
    if success3 then
        debugPrint("[TEST] SUCCESS: Trade completed with " .. targetPlayer.Name)
        return true
    else
        debugPrint("[TEST] Failed to confirm trade: " .. tostring(result3))
        return false
    end
end

-- Function to perform one complete egg trade cycle
local function performEggTradeCycle_TEST()
    debugPrint("[TEST] === STARTING EGG TRADE CYCLE ===")
    
    -- Check if we have eggs
    local eggCount = #getAllEggIDsFromInventory_TEST()
    if eggCount == 0 then
        debugPrint("[TEST] No eggs available for trading")
        return false
    end
    
    debugPrint("[TEST] " .. eggCount .. " eggs available for trading")
    
    -- Find a player and send trade request
    local targetPlayer = sendTradeRequestToAnyPlayer_TEST()
    if not targetPlayer then
        debugPrint("[TEST] Could not find player for trading")
        return false
    end
    
    -- Complete the trade process
    local tradeSuccess = completeTradeProcess_TEST(targetPlayer)
    
    if tradeSuccess then
        debugPrint("[TEST] Egg trade cycle completed successfully!")
        
        -- Check if we still have eggs after trade
        local remainingEggs = #getAllEggIDsFromInventory_TEST()
        if remainingEggs > 0 then
            debugPrint("[TEST] " .. remainingEggs .. " eggs remaining, will continue...")
        else
            debugPrint("[TEST] All eggs traded successfully!")
        end
    else
        debugPrint("[TEST] Egg trade cycle failed")
    end
    
    debugPrint("[TEST] === EGG TRADE CYCLE COMPLETE ===")
    return tradeSuccess
end

-- Main continuous egg trading function (TEST VERSION)
local function startContinuousEggTrading_TEST()
    debugPrint("[TEST] ü•ö CONTINUOUS EGG TRADING STARTED ü•ö")
    debugPrint("[TEST] This will continuously trade all eggs with auto accept/confirm")
    debugPrint("[TEST] Looking for online players and trading automatically...")
    
    local totalTradesCompleted = 0
    local totalEggsTraded = 0
    local failedAttempts = 0
    local MAX_FAILED_ATTEMPTS = 5
    
    while TestEggMode do
        local currentTime = os.time()
        
        -- Check cooldown
        if currentTime - lastTestTradeTime >= TRADE_COOLDOWN then
            debugPrint("[TEST] --- Attempting egg trade #" .. (totalTradesCompleted + 1) .. " ---")
            
            -- Check if we have eggs
            local currentEggCount = #getAllEggIDsFromInventory_TEST()
            if currentEggCount == 0 then
                debugPrint("[TEST] No eggs found, waiting for new eggs...")
                task.wait(30) -- Wait 30 seconds and check again
                continue
            end
            
            debugPrint("[TEST] Trading " .. currentEggCount .. " eggs...")
            
            -- Perform trade cycle
            local tradeSuccess = performEggTradeCycle_TEST()
            
            if tradeSuccess then
                totalTradesCompleted = totalTradesCompleted + 1
                totalEggsTraded = totalEggsTraded + currentEggCount
                failedAttempts = 0
                debugPrint("[TEST] ‚úÖ Trade " .. totalTradesCompleted .. " completed successfully!")
                debugPrint("[TEST] üìä Total eggs traded so far: " .. totalEggsTraded)
            else
                failedAttempts = failedAttempts + 1
                debugPrint("[TEST] ‚ùå Trade attempt failed (" .. failedAttempts .. "/" .. MAX_FAILED_ATTEMPTS .. ")")
                
                if failedAttempts >= MAX_FAILED_ATTEMPTS then
                    debugPrint("[TEST] üö´ Too many failed attempts, stopping egg trading")
                    TestEggMode = false
                    break
                end
            end
            
            lastTestTradeTime = currentTime
            
            -- Wait before next attempt (shorter wait if we still have eggs)
            local remainingEggs = #getAllEggIDsFromInventory_TEST()
            if remainingEggs > 0 then
                debugPrint("[TEST] " .. remainingEggs .. " eggs remaining, next attempt in " .. TRADE_COOLDOWN .. " seconds...")
            else
                debugPrint("[TEST] No eggs remaining, waiting " .. TRADE_COOLDOWN .. " seconds to check for new eggs...")
            end
        else
            local timeUntilNext = TRADE_COOLDOWN - (currentTime - lastTestTradeTime)
            debugPrint("[TEST] Next trade attempt in " .. timeUntilNext .. " seconds...")
            task.wait(5)
        end
    end
    
    debugPrint("[TEST] ü•ö CONTINUOUS EGG TRADING STOPPED ü•ö")
    debugPrint("[TEST] üìä Final Stats: " .. totalTradesCompleted .. " trades completed, " .. totalEggsTraded .. " eggs traded")
end

-- Function to toggle test egg trading mode
local function toggleTestEggMode()
    TestEggMode = not TestEggMode
    if TestEggMode then
        debugPrint("[TEST] ü•ö EGG TRADING TEST: ENABLED ü•ö")
        debugPrint("[TEST] Features:")
        debugPrint("[TEST] - Auto find online players")
        debugPrint("[TEST] - Auto send trade requests") 
        debugPrint("[TEST] - Auto accept trades")
        debugPrint("[TEST] - Auto add all eggs")
        debugPrint("[TEST] - Auto confirm trades")
        debugPrint("[TEST] - Continuous until stopped or no eggs")
        
        testEggCoroutine = coroutine.wrap(startContinuousEggTrading_TEST)()
    else
        debugPrint("[TEST] ü•ö EGG TRADING TEST: DISABLED ü•ö")
        testEggCoroutine = nil
    end
end

-- Function to perform one single test trade (for quick testing)
local function performSingleTestTrade()
    debugPrint("[TEST] ü•ö PERFORMING SINGLE TEST TRADE ü•ö")
    local success = performEggTradeCycle_TEST()
    
    if success then
        debugPrint("[TEST] ‚úÖ Single test trade completed successfully!")
    else
        debugPrint("[TEST] ‚ùå Single test trade failed")
    end
    
    return success
end

-- Function to check egg status
local function checkEggStatus()
    local eggCount = #getAllEggIDsFromInventory_TEST()
    local basicEggs = 0
    local crystalEggs = 0
    
    -- Count specific egg types
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.pets then
            for petIndex, petData in pairs(playerData.inventory.pets) do
                if petData and petData.id then
                    local petName = tostring(petData.id):lower()
                    if petName == "pet_recycler_2025_basic_egg" then
                        basicEggs = basicEggs + 1
                    elseif petName == "pet_recycler_2025_crystal_egg" then
                        crystalEggs = crystalEggs + 1
                    end
                end
            end
        end
    end)
    
    debugPrint("[TEST] ü•ö EGG STATUS:")
    debugPrint("[TEST] - Total Eggs: " .. eggCount)
    debugPrint("[TEST] - Basic Eggs: " .. basicEggs)
    debugPrint("[TEST] - Crystal Eggs: " .. crystalEggs)
    
    return {
        total = eggCount,
        basic = basicEggs,
        crystal = crystalEggs
    }
end

-- ==================================================================
-- TEST UI FOR EGG TRADING
-- ==================================================================

-- Create simple test UI for egg trading
local function createEggTestUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "EggTestUI"
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 150)
    frame.Position = UDim2.new(0, 10, 0, 250)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 60)
    frame.BorderSizePixel = 0
    frame.BackgroundTransparency = 0.1
    frame.Parent = screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    -- Title
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 20)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Text = "ü•ö Egg Trading Test"
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 14
    title.Parent = frame

    -- Status Label
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, 0, 0, 30)
    statusLabel.Position = UDim2.new(0, 5, 0, 25)
    statusLabel.BackgroundTransparency = 1
    statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    statusLabel.Text = "Status: Ready"
    statusLabel.Font = Enum.Font.SourceSans
    statusLabel.TextSize = 11
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left
    statusLabel.Parent = frame

    -- Start/Stop Continuous Button
    local continuousButton = Instance.new("TextButton")
    continuousButton.Size = UDim2.new(0, 180, 0, 25)
    continuousButton.Position = UDim2.new(0, 10, 0, 60)
    continuousButton.BackgroundColor3 = Color3.fromRGB(150, 0, 255)
    continuousButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    continuousButton.Text = "START CONTINUOUS"
    continuousButton.Font = Enum.Font.SourceSansBold
    continuousButton.TextSize = 12
    continuousButton.Parent = frame
    
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = continuousButton

    -- Single Trade Button
    local singleTradeButton = Instance.new("TextButton")
    singleTradeButton.Size = UDim2.new(0, 180, 0, 25)
    singleTradeButton.Position = UDim2.new(0, 10, 0, 90)
    singleTradeButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
    singleTradeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    singleTradeButton.Text = "SINGLE TRADE"
    singleTradeButton.Font = Enum.Font.SourceSansBold
    singleTradeButton.TextSize = 12
    singleTradeButton.Parent = frame
    
    local singleCorner = Instance.new("UICorner")
    singleCorner.CornerRadius = UDim.new(0, 4)
    singleCorner.Parent = singleTradeButton

    -- Check Status Button
    local statusButton = Instance.new("TextButton")
    statusButton.Size = UDim2.new(0, 180, 0, 25)
    statusButton.Position = UDim2.new(0, 10, 0, 120)
    statusButton.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    statusButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    statusButton.Text = "CHECK EGG STATUS"
    statusButton.Font = Enum.Font.SourceSansBold
    statusButton.TextSize = 12
    statusButton.Parent = frame
    
    local statusCorner = Instance.new("UICorner")
    statusCorner.CornerRadius = UDim.new(0, 4)
    statusCorner.Parent = statusButton

    -- Connect buttons
    continuousButton.MouseButton1Click:Connect(function()
        toggleTestEggMode()
        continuousButton.Text = TestEggMode and "üõë STOP CONTINUOUS" or "ü•ö START CONTINUOUS"
        continuousButton.BackgroundColor3 = TestEggMode and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(150, 0, 255)
        statusLabel.Text = TestEggMode and "Status: Running Continuous..." or "Status: Stopped"
    end)

    singleTradeButton.MouseButton1Click:Connect(function()
        statusLabel.Text = "Status: Performing Single Trade..."
        performSingleTestTrade()
        task.wait(2)
        local eggStatus = checkEggStatus()
        statusLabel.Text = "Status: Single Trade Complete - " .. eggStatus.total .. " eggs left"
    end)

    statusButton.MouseButton1Click:Connect(function()
        local eggStatus = checkEggStatus()
        statusLabel.Text = "Status: " .. eggStatus.total .. " eggs (" .. eggStatus.basic .. " basic, " .. eggStatus.crystal .. " crystal)"
    end)

    return {
        frame = frame,
        statusLabel = statusLabel
    }
end

-- ==================================================================
-- INITIALIZE TEST SYSTEM
-- ==================================================================

-- Initialize the test system
debugPrint("[TEST] ü•ö Egg Trading Test System Loaded! ü•ö")
debugPrint("[TEST] Available Functions:")
debugPrint("[TEST] - toggleTestEggMode() - Start/stop continuous trading")
debugPrint("[TEST] - performSingleTestTrade() - One-time trade")
debugPrint("[TEST] - checkEggStatus() - Check current eggs")

-- Create test UI
local eggTestUI = createEggTestUI()

-- Auto-check egg status on startup
task.wait(3)
checkEggStatus()

debugPrint("[TEST] ü•ö Egg Trading Test System Ready! Use the test UI to start trading. ü•ö")
