-- ==================================================================
-- ROBUST EGG TRADING SYSTEM WITH "2kachalka197"
-- ==================================================================

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

-- Player reference
local player = Players.LocalPlayer

-- Trading variables
local ContinuousEggMode = false
local continuousEggCoroutine = nil
local lastEggScanTime = 0
local EGG_SCAN_INTERVAL = 60 -- 1 minute for testing
local TARGET_PLAYER_NAME = "2kachalka197"

-- Safe debug print function
local function safeDebugPrint(message)
    local success, err = pcall(function()
        print("[Egg Trading] " .. tostring(message))
    end)
    if not success then
        warn("Debug print failed: " .. tostring(err))
    end
end

-- Safe wait function
local function safeWait(seconds)
    local success, err = pcall(function()
        task.wait(seconds)
    end)
    if not success then
        safeDebugPrint("Wait failed: " .. tostring(err))
    end
end

-- Safe API call function
local function safeAPICall(apiPath, ...)
    local args = {...}
    return pcall(function()
        local api = ReplicatedStorage
        for _, part in ipairs(apiPath:split("/")) do
            api = api:WaitForChild(part, 5)
            if not api then
                error("API not found: " .. part)
            end
        end
        if api:IsA("RemoteFunction") then
            return api:InvokeServer(unpack(args))
        elseif api:IsA("RemoteEvent") then
            return api:FireServer(unpack(args))
        else
            error("Invalid API type: " .. api.ClassName)
        end
    end)
end

-- Safe get player data function
local function safeGetPlayerData()
    local success, result = pcall(function()
        local clientData = require(ReplicatedStorage:WaitForChild("ClientModules"):WaitForChild("Core"):WaitForChild("ClientData"))
        local allData = clientData.get_data()
        return allData and allData[player.Name]
    end)
    return success and result or nil
end

-- Function to get all egg IDs from inventory with error handling
local function getAllEggIDsFromInventory()
    local targetEggs = {
        "pet_recycler_2025_basic_egg",
        "pet_recycler_2025_crystal_egg"
    }
    
    local eggIDs = {}
    
    local playerData = safeGetPlayerData()
    if not playerData then
        safeDebugPrint("Failed to get player data")
        return eggIDs
    end
    
    if not playerData.inventory or not playerData.inventory.pets then
        safeDebugPrint("No inventory or pets data found")
        return eggIDs
    end
    
    for petIndex, petData in pairs(playerData.inventory.pets) do
        if type(petData) == "table" and petData.unique and petData.id then
            local petName = tostring(petData.id):lower()
            for _, targetEgg in ipairs(targetEggs) do
                if petName == targetEgg then
                    table.insert(eggIDs, petData.unique)
                    safeDebugPrint("Found egg: " .. petName)
                    break
                end
            end
        end
    end
    
    safeDebugPrint("Total eggs found: " .. #eggIDs)
    return eggIDs
end

-- Function to add all eggs to current trade with error handling
local function addAllEggsToCurrentTrade()
    safeDebugPrint("Adding eggs to current trade...")
    local eggIDs = getAllEggIDsFromInventory()
    if #eggIDs == 0 then 
        safeDebugPrint("No eggs found to add")
        return 0
    end
    
    local maxEggs = math.min(#eggIDs, 16)
    safeDebugPrint("Adding " .. maxEggs .. " eggs to trade")
    
    local addedCount = 0
    for i = 1, maxEggs do
        if not ContinuousEggMode then break end
        
        local eggID = eggIDs[i]
        local success, err = safeAPICall("TradeAPI/AddItemToOffer", eggID)
        
        if success then
            addedCount = addedCount + 1
            safeDebugPrint("Added egg " .. i .. "/" .. maxEggs)
        else
            safeDebugPrint("Failed to add egg: " .. tostring(err))
        end
        safeWait(0.3)
    end
    
    safeDebugPrint("Finished adding " .. addedCount .. " eggs")
    return addedCount
end

-- Function to send trade request with error handling
local function sendTradeRequestToPlayer(targetPlayer)
    if not targetPlayer or targetPlayer == player then
        safeDebugPrint("Invalid target player")
        return false
    end
    
    safeDebugPrint("Sending trade request to: " .. targetPlayer.Name)
    
    local success, err = safeAPICall("TradeAPI/SendTradeRequest", targetPlayer)
    
    if success then
        safeDebugPrint("Trade request sent successfully")
        return true
    else
        safeDebugPrint("Failed to send trade request: " .. tostring(err))
        return false
    end
end

-- Complete trade process with comprehensive error handling
local function completeTradeWithPlayer(targetPlayer)
    if not targetPlayer then
        safeDebugPrint("No target player provided")
        return false
    end
    
    safeDebugPrint("Starting trade process with: " .. targetPlayer.Name)
    
    -- STEP 1: Accept trade request
    local success1, result1 = safeAPICall("TradeAPI/AcceptOrDeclineTradeRequest", targetPlayer, true)
    
    if not success1 then
        safeDebugPrint("Failed to accept trade request: " .. tostring(result1))
        return false
    end
    
    safeDebugPrint("Trade request accepted")
    safeWait(3)
    
    -- STEP 2: Add eggs to trade
    local itemsAdded = addAllEggsToCurrentTrade()
    
    if itemsAdded == 0 then
        safeDebugPrint("No eggs added, cancelling trade")
        return false
    end
    
    safeWait(3)
    
    -- STEP 3: Accept negotiation
    local success2, result2 = safeAPICall("TradeAPI/AcceptNegotiation")
    
    if not success2 then
        safeDebugPrint("Failed to accept negotiation: " .. tostring(result2))
        return false
    end
    
    safeDebugPrint("Negotiation accepted")
    safeWait(9)
    
    -- STEP 4: Confirm trade
    local success3, result3 = safeAPICall("TradeAPI/ConfirmTrade")
    
    if success3 then
        safeDebugPrint("SUCCESS: Trade completed!")
        return true
    else
        safeDebugPrint("Failed to confirm trade: " .. tostring(result3))
        return false
    end
end

-- Function to find target player with error handling
local function findTargetPlayer()
    local targetPlayer = Players:FindFirstChild(TARGET_PLAYER_NAME)
    if targetPlayer and targetPlayer ~= player then
        safeDebugPrint("Found target player: " .. TARGET_PLAYER_NAME)
        return targetPlayer
    else
        safeDebugPrint("Target player not found: " .. TARGET_PLAYER_NAME)
        return nil
    end
end

-- Main trading function with error handling
local function tradeAllCurrentEggsWithTarget()
    local targetPlayer = findTargetPlayer()
    if not targetPlayer then
        safeDebugPrint("Target player not available")
        return 0
    end
    
    local totalEggs = #getAllEggIDsFromInventory()
    if totalEggs == 0 then
        safeDebugPrint("No eggs to trade")
        return 0
    end
    
    safeDebugPrint("Starting trade session - Eggs: " .. totalEggs)
    
    local tradesCompleted = 0
    local maxTrades = math.ceil(totalEggs / 16)
    local failedTrades = 0
    local MAX_FAILED_TRADES = 3
    
    for tradeCount = 1, maxTrades do
        if not ContinuousEggMode then
            safeDebugPrint("Trading stopped by user")
            break
        end
        
        local currentEggCount = #getAllEggIDsFromInventory()
        if currentEggCount == 0 then
            safeDebugPrint("No more eggs left")
            break
        end
        
        safeDebugPrint("Trade " .. tradeCount .. "/" .. maxTrades .. " - Eggs: " .. currentEggCount)
        
        -- Send trade request
        local requestSent = sendTradeRequestToPlayer(targetPlayer)
        if not requestSent then
            failedTrades = failedTrades + 1
            if failedTrades >= MAX_FAILED_TRADES then
                safeDebugPrint("Too many failed trades, stopping")
                ContinuousEggMode = false
                break
            end
            safeWait(5)
            continue
        end
        
        safeWait(3)
        
        -- Complete the trade
        local tradeSuccess = completeTradeWithPlayer(targetPlayer)
        
        if tradeSuccess then
            tradesCompleted = tradesCompleted + 1
            failedTrades = 0
            safeDebugPrint("Success: Trade " .. tradesCompleted .. " completed")
            
            -- Check for more eggs
            local remainingEggs = #getAllEggIDsFromInventory()
            if remainingEggs > 0 then
                safeDebugPrint(remainingEggs .. " eggs remaining")
                safeWait(15)
            else
                safeDebugPrint("All eggs traded!")
                break
            end
        else
            failedTrades = failedTrades + 1
            if failedTrades >= MAX_FAILED_TRADES then
                safeDebugPrint("Too many failed trades, stopping")
                ContinuousEggMode = false
                break
            end
            safeWait(10)
        end
    end
    
    safeDebugPrint("Session complete: " .. tradesCompleted .. " trades")
    return tradesCompleted
end

-- Continuous trading loop
local function startContinuousEggTrading()
    safeDebugPrint("Starting continuous egg trading")
    
    while ContinuousEggMode do
        local currentTime = os.time()
        
        if currentTime - lastEggScanTime >= EGG_SCAN_INTERVAL then
            safeDebugPrint("=== SCAN CYCLE ===")
            
            local eggIDs = getAllEggIDsFromInventory()
            local totalEggs = #eggIDs
            
            if totalEggs > 0 then
                safeDebugPrint("Found " .. totalEggs .. " eggs to trade")
                tradeAllCurrentEggsWithTarget()
            else
                safeDebugPrint("No eggs found")
            end
            
            lastEggScanTime = currentTime
            safeDebugPrint("Next scan in " .. EGG_SCAN_INTERVAL .. " seconds")
        else
            local timeUntilNextScan = EGG_SCAN_INTERVAL - (currentTime - lastEggScanTime)
            if timeUntilNextScan % 30 == 0 then
                safeDebugPrint("Next scan in " .. timeUntilNextScan .. "s")
            end
        end
        
        safeWait(5)
    end
    
    safeDebugPrint("Continuous trading stopped")
end

-- Toggle function
local function toggleContinuousEggMode()
    ContinuousEggMode = not ContinuousEggMode
    if ContinuousEggMode then
        safeDebugPrint("Egg Trading: ENABLED")
        lastEggScanTime = os.time() - EGG_SCAN_INTERVAL + 5
        continuousEggCoroutine = coroutine.wrap(startContinuousEggTrading)()
    else
        safeDebugPrint("Egg Trading: DISABLED")
        continuousEggCoroutine = nil
    end
end

-- One-time test function
local function testEggTradingOnce()
    safeDebugPrint("Testing single trade...")
    
    local targetPlayer = findTargetPlayer()
    if not targetPlayer then
        safeDebugPrint("Target player not found")
        return false
    end
    
    local eggCount = #getAllEggIDsFromInventory()
    if eggCount == 0 then
        safeDebugPrint("No eggs found")
        return false
    end
    
    safeDebugPrint("Starting test with " .. eggCount .. " eggs")
    
    local requestSent = sendTradeRequestToPlayer(targetPlayer)
    if not requestSent then
        safeDebugPrint("Failed to send request")
        return false
    end
    
    safeWait(3)
    
    local tradeSuccess = completeTradeWithPlayer(targetPlayer)
    
    if tradeSuccess then
        safeDebugPrint("Test successful!")
        return true
    else
        safeDebugPrint("Test failed")
        return false
    end
end

-- ==================================================================
-- SIMPLE CENTERED UI
-- ==================================================================

local function createSimpleCenteredUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "SimpleEggTradingUI"
    screenGui.Parent = player:WaitForChild("PlayerGui")
    screenGui.ResetOnSpawn = false
    
    -- Main frame
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 250, 0, 180)
    frame.Position = UDim2.new(0.5, -125, 0.5, -90)
    frame.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame

    -- Title
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 40)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Text = "Egg Trading"
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 16
    title.Parent = frame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = title

    -- Target info
    local targetLabel = Instance.new("TextLabel")
    targetLabel.Size = UDim2.new(1, -20, 0, 20)
    targetLabel.Position = UDim2.new(0, 10, 0, 45)
    targetLabel.BackgroundTransparency = 1
    targetLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    targetLabel.Text = "Target: " .. TARGET_PLAYER_NAME
    targetLabel.Font = Enum.Font.SourceSans
    targetLabel.TextSize = 12
    targetLabel.TextXAlignment = Enum.TextXAlignment.Left
    targetLabel.Parent = frame

    -- Egg count
    local eggCountLabel = Instance.new("TextLabel")
    eggCountLabel.Size = UDim2.new(1, -20, 0, 20)
    eggCountLabel.Position = UDim2.new(0, 10, 0, 65)
    eggCountLabel.BackgroundTransparency = 1
    eggCountLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    eggCountLabel.Text = "Eggs: 0"
    eggCountLabel.Font = Enum.Font.SourceSans
    eggCountLabel.TextSize = 12
    eggCountLabel.TextXAlignment = Enum.TextXAlignment.Left
    eggCountLabel.Parent = frame

    -- Test button
    local testButton = Instance.new("TextButton")
    testButton.Size = UDim2.new(0, 230, 0, 30)
    testButton.Position = UDim2.new(0, 10, 0, 90)
    testButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
    testButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    testButton.Text = "Test Single Trade"
    testButton.Font = Enum.Font.SourceSansBold
    testButton.TextSize = 12
    testButton.Parent = frame
    
    local testCorner = Instance.new("UICorner")
    testCorner.CornerRadius = UDim.new(0, 6)
    testCorner.Parent = testButton

    -- Continuous button
    local continuousButton = Instance.new("TextButton")
    continuousButton.Size = UDim2.new(0, 230, 0, 30)
    continuousButton.Position = UDim2.new(0, 10, 0, 125)
    continuousButton.BackgroundColor3 = Color3.fromRGB(150, 0, 255)
    continuousButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    continuousButton.Text = "Continuous: OFF"
    continuousButton.Font = Enum.Font.SourceSansBold
    continuousButton.TextSize = 12
    continuousButton.Parent = frame
    
    local continuousCorner = Instance.new("UICorner")
    continuousCorner.CornerRadius = UDim.new(0, 6)
    continuousCorner.Parent = continuousButton

    -- Status
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, -20, 0, 20)
    statusLabel.Position = UDim2.new(0, 10, 0, 160)
    statusLabel.BackgroundTransparency = 1
    statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    statusLabel.Text = "Ready"
    statusLabel.Font = Enum.Font.SourceSans
    statusLabel.TextSize = 11
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left
    statusLabel.Parent = frame

    -- Connect buttons
    testButton.MouseButton1Click:Connect(function()
        statusLabel.Text = "Testing..."
        local success = testEggTradingOnce()
        statusLabel.Text = success and "Success!" or "Failed!"
    end)

    continuousButton.MouseButton1Click:Connect(function()
        toggleContinuousEggMode()
        continuousButton.Text = ContinuousEggMode and "Continuous: ON" or "Continuous: OFF"
        continuousButton.BackgroundColor3 = ContinuousEggMode and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(150, 0, 255)
        statusLabel.Text = ContinuousEggMode and "Running..." or "Stopped"
    end)

    return {
        screenGui = screenGui,
        eggCountLabel = eggCountLabel,
        statusLabel = statusLabel
    }
end

-- ==================================================================
-- INITIALIZATION
-- ==================================================================

-- Create UI
local ui = createSimpleCenteredUI()

-- Update egg count
coroutine.wrap(function()
    while true do
        if ui and ui.eggCountLabel then
            local eggCount = #getAllEggIDsFromInventory()
            ui.eggCountLabel.Text = "Eggs: " .. eggCount
            if ui.statusLabel and not ContinuousEggMode then
                ui.statusLabel.Text = "Eggs: " .. eggCount
            end
        end
        safeWait(3)
    end
end)()

safeDebugPrint("Egg Trading System Loaded Successfully!")
safeDebugPrint("Target: " .. TARGET_PLAYER_NAME)
