-- ==================================================================
-- TEST FUNCTION: TRADE ALL EGGS WITH "2kachalka197"
-- ==================================================================

-- Trading variables for test
local ContinuousEggMode = false
local continuousEggCoroutine = nil
local lastEggScanTime = 0
local EGG_SCAN_INTERVAL = 60 -- 1 minute for testing
local currentTradeType = "eggs"
local TARGET_PLAYER_NAME = "2kachalka197"

-- Function to get all egg IDs from inventory
local function getAllEggIDsFromInventory()
    local targetEggs = {
        "pet_recycler_2025_basic_egg",
        "pet_recycler_2025_crystal_egg"
    }
    
    local eggIDs = {}
    
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.pets then
            for petIndex, petData in pairs(playerData.inventory.pets) do
                if petData and petData.unique and petData.id then
                    local petName = tostring(petData.id):lower()
                    for _, targetEgg in ipairs(targetEggs) do
                        if petName == targetEgg then
                            table.insert(eggIDs, petData.unique)
                            debugPrint("Found egg: " .. petName .. " (" .. petData.unique .. ")")
                            break
                        end
                    end
                end
            end
        end
    end)
    
    if not success then
        debugPrint("Error getting egg IDs from inventory: " .. tostring(errorMsg))
    end
    
    debugPrint("Total eggs found: " .. #eggIDs)
    return eggIDs
end

-- Function to add all eggs to current trade
local function addAllEggsToCurrentTrade()
    debugPrint("Adding all eggs to current trade...")
    local eggIDs = getAllEggIDsFromInventory()
    if #eggIDs == 0 then 
        debugPrint("No eggs found to add to trade")
        return 0
    end
    
    -- Limit to 16 eggs per trade (safe limit)
    local maxEggs = math.min(#eggIDs, 16)
    debugPrint("Adding " .. maxEggs .. " eggs to trade")
    
    local addedCount = 0
    for i = 1, maxEggs do
        local eggID = eggIDs[i]
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AddItemToOffer"):FireServer(eggID)
        end)
        
        if success then
            addedCount = addedCount + 1
            debugPrint("Added egg " .. i .. "/" .. maxEggs .. " to trade")
        else
            debugPrint("Failed to add egg to trade: " .. tostring(err))
        end
        task.wait(0.3) -- Slightly longer delay for stability
    end
    
    debugPrint("Finished adding " .. addedCount .. " eggs to trade")
    return addedCount
end

-- Function to send trade request to specific player
local function sendTradeRequestToPlayer(targetPlayer)
    if not targetPlayer or targetPlayer == player then
        debugPrint("Invalid target player for trade")
        return false
    end
    
    debugPrint("Sending trade request to: " .. targetPlayer.Name)
    
    local success, err = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/SendTradeRequest"):FireServer(targetPlayer)
    end)
    
    if success then
        debugPrint("Trade request sent successfully to " .. targetPlayer.Name)
        return true
    else
        debugPrint("Failed to send trade request to " .. targetPlayer.Name .. ": " .. tostring(err))
        return false
    end
end

-- Complete trade process with specific player
local function completeTradeWithPlayer(targetPlayer)
    if not targetPlayer then
        debugPrint("No target player provided for trade completion")
        return false
    end
    
    debugPrint("Starting complete trade process with: " .. targetPlayer.Name)
    
    -- STEP 1: Accept trade request
    local args = { targetPlayer, true }
    local success1, result1 = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptOrDeclineTradeRequest"):InvokeServer(unpack(args))
    end)
    
    if not success1 then
        debugPrint("Failed to accept trade request: " .. tostring(result1))
        return false
    end
    
    debugPrint("Trade request accepted, waiting 3 seconds...")
    task.wait(3)  -- Wait for trade window to open
    
    -- STEP 2: Add eggs to trade
    local itemsAdded = addAllEggsToCurrentTrade()
    
    if itemsAdded == 0 then
        debugPrint("No eggs added to trade, cancelling...")
        return false
    end
    
    debugPrint("Waiting 3 seconds after adding eggs...")
    task.wait(3)  -- Wait for items to be added
    
    -- STEP 3: Accept negotiation
    local success2, result2 = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptNegotiation"):FireServer()
    end)
    
    if not success2 then
        debugPrint("Failed to accept negotiation: " .. tostring(result2))
        return false
    end
    
    debugPrint("Negotiation accepted, waiting 9 seconds for confirmation...")
    task.wait(9)  -- Wait for trade confirmation timer
    
    -- STEP 4: Confirm trade
    local success3, result3 = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ConfirmTrade"):FireServer()
    end)
    
    if success3 then
        debugPrint("SUCCESS: Trade completed with " .. targetPlayer.Name)
        return true
    else
        debugPrint("Failed to confirm trade: " .. tostring(result3))
        return false
    end
end

-- Function to find target player "2kachalka197"
local function findTargetPlayer()
    local targetPlayer = Players:FindFirstChild(TARGET_PLAYER_NAME)
    if targetPlayer and targetPlayer ~= player then
        debugPrint("Found target player: " .. TARGET_PLAYER_NAME)
        return targetPlayer
    else
        debugPrint("Target player not found: " .. TARGET_PLAYER_NAME)
        return nil
    end
end

-- Function to trade all current eggs with target player
local function tradeAllCurrentEggsWithTarget()
    local targetPlayer = findTargetPlayer()
    if not targetPlayer then
        debugPrint("Target player " .. TARGET_PLAYER_NAME .. " not found!")
        return 0
    end
    
    local totalEggs = #getAllEggIDsFromInventory()
    if totalEggs == 0 then
        debugPrint("No eggs to trade")
        return 0
    end
    
    debugPrint("Starting egg trade session with " .. TARGET_PLAYER_NAME)
    debugPrint("Total eggs to trade: " .. totalEggs)
    
    local tradesCompleted = 0
    local maxTrades = math.ceil(totalEggs / 16)
    local failedTrades = 0
    local MAX_FAILED_TRADES = 3
    
    for tradeCount = 1, maxTrades do
        if not ContinuousEggMode then
            debugPrint("Egg trading stopped by user")
            break
        end
        
        -- Check if we still have eggs
        local currentEggCount = #getAllEggIDsFromInventory()
        if currentEggCount == 0 then
            debugPrint("No more eggs left to trade")
            break
        end
        
        debugPrint("=== EGG TRADE " .. tradeCount .. "/" .. maxTrades .. " ===")
        debugPrint("Eggs remaining: " .. currentEggCount)
        
        -- Send trade request
        debugPrint("Sending trade request...")
        local requestSent = sendTradeRequestToPlayer(targetPlayer)
        if not requestSent then
            debugPrint("Failed to send trade request")
            failedTrades = failedTrades + 1
            if failedTrades >= MAX_FAILED_TRADES then
                debugPrint("Too many failed trades, stopping")
                ContinuousEggMode = false
                break
            end
            debugPrint("Waiting 5 seconds before retry...")
            task.wait(5)
            continue
        end
        
        debugPrint("Waiting 3 seconds after request...")
        task.wait(3)
        
        -- Complete the trade process
        currentTradeType = "eggs"
        local tradeSuccess = completeTradeWithPlayer(targetPlayer)
        
        if tradeSuccess then
            tradesCompleted = tradesCompleted + 1
            failedTrades = 0
            debugPrint("SUCCESS: Completed egg trade " .. tradesCompleted)
            
            -- Check if we have more eggs for next trade
            local remainingEggs = #getAllEggIDsFromInventory()
            if remainingEggs > 0 then
                debugPrint(remainingEggs .. " eggs remaining, waiting 15 seconds...")
                task.wait(15) -- Wait before next trade
            else
                debugPrint("üéâ ALL EGGS TRADED SUCCESSFULLY!")
                break
            end
        else
            debugPrint("FAILED: Egg trade " .. tradeCount .. " failed")
            failedTrades = failedTrades + 1
            if failedTrades >= MAX_FAILED_TRADES then
                debugPrint("Too many failed trades, stopping")
                ContinuousEggMode = false
                break
            end
            debugPrint("Waiting 10 seconds before retry...")
            task.wait(10)
        end
    end
    
    debugPrint("=== EGG TRADING SESSION COMPLETE ===")
    debugPrint("Trades completed: " .. tradesCompleted)
    debugPrint("Eggs remaining: " .. #getAllEggIDsFromInventory())
    return tradesCompleted
end

-- Function to start continuous egg trading
local function startContinuousEggTrading()
    debugPrint("üöÄ STARTING CONTINUOUS EGG TRADING WITH " .. TARGET_PLAYER_NAME)
    debugPrint("Scan interval: " .. EGG_SCAN_INTERVAL .. " seconds")
    
    while ContinuousEggMode do
        local currentTime = os.time()
        
        -- Check if it's time to scan
        if currentTime - lastEggScanTime >= EGG_SCAN_INTERVAL then
            debugPrint("")
            debugPrint("=== EGG TRADING SCAN CYCLE ===")
            debugPrint("Time: " .. os.date("%H:%M:%S"))
            
            -- Get current egg count
            local eggIDs = getAllEggIDsFromInventory()
            local totalEggs = #eggIDs
            
            if totalEggs > 0 then
                debugPrint("üéØ Found " .. totalEggs .. " eggs to trade with " .. TARGET_PLAYER_NAME)
                
                -- Trade all current eggs
                local tradesDone = tradeAllCurrentEggsWithTarget()
                
                if tradesDone > 0 then
                    debugPrint("‚úÖ Successfully completed " .. tradesDone .. " trades")
                else
                    debugPrint("‚ùå No trades completed this cycle")
                end
            else
                debugPrint("üì≠ No eggs found in inventory")
                debugPrint("Next scan in " .. EGG_SCAN_INTERVAL .. " seconds...")
            end
            
            lastEggScanTime = currentTime
            debugPrint("=== SCAN CYCLE COMPLETE ===")
            debugPrint("")
        else
            local timeUntilNextScan = EGG_SCAN_INTERVAL - (currentTime - lastEggScanTime)
            if timeUntilNextScan % 30 == 0 then -- Log every 30 seconds
                debugPrint("‚è∞ Next egg scan in " .. timeUntilNextScan .. " seconds")
            end
        end
        
        -- Wait before next check
        task.wait(5) -- Check every 5 seconds
    end
    
    debugPrint("üõë CONTINUOUS EGG TRADING STOPPED")
end

-- Function to toggle continuous egg mode
local function toggleContinuousEggMode()
    ContinuousEggMode = not ContinuousEggMode
    if ContinuousEggMode then
        debugPrint("üî¥ EGG TRADING: ENABLED")
        debugPrint("üéØ Target: " .. TARGET_PLAYER_NAME)
        debugPrint("‚è∞ Scan interval: " .. EGG_SCAN_INTERVAL .. " seconds")
        lastEggScanTime = os.time() - EGG_SCAN_INTERVAL + 5 -- Start first scan in 5 seconds
        continuousEggCoroutine = coroutine.wrap(startContinuousEggTrading)()
    else
        debugPrint("üü¢ EGG TRADING: DISABLED")
        continuousEggCoroutine = nil
    end
end

-- One-time test function (run this to test immediately)
local function testEggTradingOnce()
    debugPrint("üß™ TESTING EGG TRADING WITH " .. TARGET_PLAYER_NAME)
    
    local targetPlayer = findTargetPlayer()
    if not targetPlayer then
        debugPrint("‚ùå TEST FAILED: Player " .. TARGET_PLAYER_NAME .. " not found!")
        return false
    end
    
    local eggCount = #getAllEggIDsFromInventory()
    if eggCount == 0 then
        debugPrint("‚ùå TEST FAILED: No eggs found in inventory!")
        return false
    end
    
    debugPrint("‚úÖ TEST READY: " .. eggCount .. " eggs found, target player online")
    debugPrint("üöÄ Starting one-time trade test...")
    
    -- Set trade type
    currentTradeType = "eggs"
    
    -- Send trade request
    local requestSent = sendTradeRequestToPlayer(targetPlayer)
    if not requestSent then
        debugPrint("‚ùå TEST FAILED: Could not send trade request")
        return false
    end
    
    task.wait(3)
    
    -- Complete the trade
    local tradeSuccess = completeTradeWithPlayer(targetPlayer)
    
    if tradeSuccess then
        debugPrint("üéâ TEST SUCCESS: Egg trade completed!")
        return true
    else
        debugPrint("‚ùå TEST FAILED: Trade process failed")
        return false
    end
end

-- ==================================================================
-- CENTERED UI CREATION FOR TESTING
-- ==================================================================

-- Create centered test UI
local function createCenteredTestEggTradingUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "EggTradingTestUI"
    screenGui.Parent = player:WaitForChild("PlayerGui")
    screenGui.ResetOnSpawn = false
    
    -- Main frame centered on screen
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 300, 0, 200) -- Larger size for better visibility
    frame.Position = UDim2.new(0.5, -150, 0.5, -100) -- Centered: (0.5, -width/2, 0.5, -height/2)
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    frame.BorderSizePixel = 0
    frame.BackgroundTransparency = 0.1
    frame.Parent = screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = frame

    -- Add a subtle border
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(80, 80, 90)
    stroke.Thickness = 2
    stroke.Parent = frame

    -- Title with icon
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 40)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Text = "ü•ö Egg Trading System"
    title.Font = Enum.Font.GothamBold
    title.TextSize = 18
    title.Parent = frame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 12)
    titleCorner.Parent = title

    -- Target player info
    local targetLabel = Instance.new("TextLabel")
    targetLabel.Size = UDim2.new(1, -20, 0, 20)
    targetLabel.Position = UDim2.new(0, 10, 0, 45)
    targetLabel.BackgroundTransparency = 1
    targetLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    targetLabel.Text = "üéØ Target: " .. TARGET_PLAYER_NAME
    targetLabel.Font = Enum.Font.Gotham
    targetLabel.TextSize = 14
    targetLabel.TextXAlignment = Enum.TextXAlignment.Left
    targetLabel.Parent = frame

    -- Egg count display
    local eggCountLabel = Instance.new("TextLabel")
    eggCountLabel.Size = UDim2.new(1, -20, 0, 20)
    eggCountLabel.Position = UDim2.new(0, 10, 0, 65)
    eggCountLabel.BackgroundTransparency = 1
    eggCountLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    eggCountLabel.Text = "üì¶ Eggs: Loading..."
    eggCountLabel.Font = Enum.Font.Gotham
    eggCountLabel.TextSize = 14
    eggCountLabel.TextXAlignment = Enum.TextXAlignment.Left
    eggCountLabel.Parent = frame

    -- Test Once Button
    local testOnceButton = Instance.new("TextButton")
    testOnceButton.Size = UDim2.new(0, 260, 0, 35)
    testOnceButton.Position = UDim2.new(0, 20, 0, 90)
    testOnceButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
    testOnceButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    testOnceButton.Text = "üß™ Test Single Trade"
    testOnceButton.Font = Enum.Font.GothamBold
    testOnceButton.TextSize = 14
    testOnceButton.Parent = frame
    
    local testOnceCorner = Instance.new("UICorner")
    testOnceCorner.CornerRadius = UDim.new(0, 8)
    testOnceCorner.Parent = testOnceButton

    -- Continuous Toggle Button
    local continuousButton = Instance.new("TextButton")
    continuousButton.Size = UDim2.new(0, 260, 0, 35)
    continuousButton.Position = UDim2.new(0, 20, 0, 130)
    continuousButton.BackgroundColor3 = Color3.fromRGB(150, 0, 255)
    continuousButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    continuousButton.Text = "üîÑ Continuous: OFF"
    continuousButton.Font = Enum.Font.GothamBold
    continuousButton.TextSize = 14
    continuousButton.Parent = frame
    
    local continuousCorner = Instance.new("UICorner")
    continuousCorner.CornerRadius = UDim.new(0, 8)
    continuousCorner.Parent = continuousButton

    -- Status Label
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, -20, 0, 20)
    statusLabel.Position = UDim2.new(0, 10, 0, 170)
    statusLabel.BackgroundTransparency = 1
    statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    statusLabel.Text = "‚úÖ Ready to test"
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 12
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left
    statusLabel.Parent = frame

    -- Close button (optional)
    local closeButton = Instance.new("TextButton")
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -35, 0, 5)
    closeButton.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Text = "X"
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextSize = 14
    closeButton.Parent = frame
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 15)
    closeCorner.Parent = closeButton

    -- Connect buttons
    testOnceButton.MouseButton1Click:Connect(function()
        statusLabel.Text = "üîÑ Testing one trade..."
        local success = testEggTradingOnce()
        if success then
            statusLabel.Text = "‚úÖ Test successful!"
            statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
        else
            statusLabel.Text = "‚ùå Test failed!"
            statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        end
    end)

    continuousButton.MouseButton1Click:Connect(function()
        toggleContinuousEggMode()
        continuousButton.Text = ContinuousEggMode and "üîÑ Continuous: ON" or "üîÑ Continuous: OFF"
        continuousButton.BackgroundColor3 = ContinuousEggMode and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(150, 0, 255)
        
        if ContinuousEggMode then
            statusLabel.Text = "üîÑ Continuous mode ACTIVE"
            statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
        else
            statusLabel.Text = "‚è∏Ô∏è Continuous mode STOPPED"
            statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
    end)

    closeButton.MouseButton1Click:Connect(function()
        screenGui:Destroy()
        ContinuousEggMode = false
        debugPrint("üóëÔ∏è Egg Trading UI Closed")
    end)

    -- Make frame draggable
    local dragging = false
    local dragInput, dragStart, startPos

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    return {
        frame = frame,
        statusLabel = statusLabel,
        eggCountLabel = eggCountLabel,
        screenGui = screenGui
    }
end

-- ==================================================================
-- INITIALIZATION
-- ==================================================================

-- Initialize the centered UI
local testUI = createCenteredTestEggTradingUI()

debugPrint("ü•ö EGG TRADING TEST SYSTEM LOADED")
debugPrint("üéØ Target player: " .. TARGET_PLAYER_NAME)
debugPrint("üìç UI is centered on screen")

-- Function to get current egg count for display
local function getEggCount()
    return #getAllEggIDsFromInventory()
end

-- Update status periodically
coroutine.wrap(function()
    while true do
        if testUI and testUI.eggCountLabel then
            local eggCount = getEggCount()
            testUI.eggCountLabel.Text = "üì¶ Eggs: " .. eggCount
            
            if ContinuousEggMode then
                testUI.statusLabel.Text = "üîÑ Running | Eggs: " .. eggCount
                testUI.statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
            else
                testUI.statusLabel.Text = "‚è∏Ô∏è Stopped | Eggs: " .. eggCount
                testUI.statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        end
        task.wait(3) -- Update every 3 seconds
    end
end)()

-- Auto-start message
task.wait(2)
debugPrint("üöÄ Egg Trading System Ready! Use the centered UI to control trading.")
