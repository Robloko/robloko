-- Gingerbread Farm Script with Realistic Movement
-- Try multiple Rayfield sources
local Rayfield = nil
local success, err = pcall(function()
    Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Rayfield/main/source'))()
end)
if not success then
    success, err = pcall(function()
        Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
    end)
end
if not success then
    -- Fallback to simple UI if Rayfield fails
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Gingerbread Farm",
        Text = "Failed to load Rayfield. Creating simple UI...",
        Duration = 5
    })
    
    -- Create a simple command-based system
    local Settings = {
        StartFarming = false,
        WalkSpeed = 16,
        StartIndex = 32,
        EndIndex = 188
    }
    
    -- Simple print commands
    print("=== Gingerbread Farm Commands ===")
    print("Type in chat or execute:")
    print("!start - Start farming")
    print("!stop - Stop farming")
    print("!status - Check status")
    print("!setspeed [number] - Set walk speed")
    print("================================")
    
    -- Listen for chat commands
    game:GetService("Players").LocalPlayer.Chatted:Connect(function(msg)
        if msg:lower() == "!start" then
            Settings.StartFarming = true
            print("[Gingerbread Farm] Started farming!")
        elseif msg:lower() == "!stop" then
            Settings.StartFarming = false
            print("[Gingerbread Farm] Stopped farming!")
        elseif msg:lower() == "!status" then
            print(string.format("[Gingerbread Farm] Status: %s", Settings.StartFarming and "Running" or "Stopped"))
        elseif msg:lower():sub(1, 10) == "!setspeed" then
            local speed = tonumber(msg:sub(12))
            if speed then
                Settings.WalkSpeed = speed
                print(string.format("[Gingerbread Farm] Speed set to: %s", speed))
            end
        end
    end)
    
    -- Return early since we're using command system
    return
end

-- If we get here, Rayfield loaded successfully
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

-- Create the window with proper settings
local Window = Rayfield:CreateWindow({
    Name = "üç™ Gingerbread Farm",
    LoadingTitle = "Loading Gingerbread Farm...",
    LoadingSubtitle = "Powered by xAI",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "GingerbreadFarmConfig",
        FileName = "Settings"
    },
    Discord = {
        Enabled = false,
        Invite = "noinvite",
        RememberJoins = true
    },
    KeySystem = false
})

-- Verify window was created
if not Window then
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Error",
        Text = "Failed to create window",
        Duration = 5
    })
    return
end

-- Create tabs
local MainTab = Window:CreateTab("Main", 4483362458)
local SettingsTab = Window:CreateTab("Settings", 4483362458)

-- Settings
local Settings = {
    Farming = false,
    WalkSpeed = 16,
    StartIndex = 32,
    EndIndex = 188,
    AntiAFK = true,
    Notifications = true,
    CollectDelay = 0.5,
    UseHumanoid = true,
    UsePathfinding = true,
    RealisticTurning = true,
    SpeedVariation = true,
    NaturalPauses = true
}

-- Store gingerbread positions
local GingerbreadPositions = {}
local CurrentTargetIndex = nil
local CurrentPath = nil
local PathPoints = {}
local CurrentPathIndex = 0
local LastLookAt = tick()
local IsTurning = false
local LastSpeedChange = tick()
local CurrentSpeedModifier = 1.0

-- Function to find gingerbread positions
local function findGingerbreadPositions()
    GingerbreadPositions = {}
    local foundCount = 0
    
    pcall(function()
        local interior = workspace:FindFirstChild("Interiors")
        if interior then
            local christmas = interior:FindFirstChild("MainMap!Christmas")
            if christmas then
                local children = christmas:GetChildren()
                
                -- Sort children by name for consistent order
                local sortedChildren = {}
                for _, child in ipairs(children) do
                    table.insert(sortedChildren, child)
                end
                
                table.sort(sortedChildren, function(a, b)
                    -- Handle string comparison safely
                    local aName = tostring(a.Name)
                    local bName = tostring(b.Name)
                    return aName < bName
                end)
                
                for i, model in ipairs(sortedChildren) do
                    local gingerbread = model:FindFirstChild("GingerbreadMan") or 
                                       model:FindFirstChild("Gingerbread") or
                                       model:FindFirstChildWhichIsA("BasePart")
                    
                    if gingerbread then
                        -- Get the actual position where the gingerbread is
                        local pos
                        if gingerbread:IsA("BasePart") then
                            pos = gingerbread.Position
                        elseif gingerbread:IsA("Model") then
                            local primaryPart = gingerbread.PrimaryPart
                            if primaryPart then
                                pos = primaryPart.Position
                            else
                                local modelPos = gingerbread:GetModelCFrame()
                                if modelPos then
                                    pos = modelPos.Position
                                else
                                    pos = Vector3.new(0, 0, 0)
                                end
                            end
                        else
                            pos = Vector3.new(0, 0, 0)
                        end
                        
                        table.insert(GingerbreadPositions, {
                            Index = i,
                            Position = pos,
                            Model = gingerbread,
                            ModelName = model.Name
                        })
                        foundCount = foundCount + 1
                    end
                end
                
                if Settings.Notifications and foundCount > 0 then
                    Rayfield:Notify({
                        Title = "Scan Complete",
                        Content = string.format("Found %d gingerbreads", foundCount),
                        Duration = 3,
                        Image = 4483362458
                    })
                elseif foundCount == 0 then
                    Rayfield:Notify({
                        Title = "Scan Failed",
                        Content = "No gingerbreads found in this location",
                        Duration = 3,
                        Image = 4483362458
                    })
                end
            else
                Rayfield:Notify({
                    Title = "Scan Failed",
                    Content = "Christmas map not found in Interiors",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        else
            Rayfield:Notify({
                Title = "Scan Failed",
                Content = "Interiors workspace not found",
                Duration = 3,
                Image = 4483362458
            })
        end
    end)
    
    -- Return the count as number (not boolean)
    return foundCount
end

-- Function to create a path to the target position
local function createPath(targetPosition)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        WaypointSpacing = 4
    })
    
    local success, errorMessage = pcall(function()
        path:ComputeAsync(HumanoidRootPart.Position, targetPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        return path:GetWaypoints()
    else
        return nil
    end
end

-- Function to smoothly turn the character towards a direction
local function smoothLookAt(targetPosition, turnSpeed)
    if not Settings.RealisticTurning then return end
    
    local lookVector = (targetPosition - HumanoidRootPart.Position).Unit
    local currentLookVector = HumanoidRootPart.CFrame.LookVector
    
    -- Calculate the angle between current and target direction
    local crossProduct = currentLookVector:Cross(lookVector)
    local dotProduct = currentLookVector:Dot(lookVector)
    local angle = math.atan2(crossProduct.Magnitude, dotProduct)
    
    -- Determine rotation direction
    local rotationDirection = 1
    if crossProduct.Y < 0 then
        rotationDirection = -1
    end
    
    -- Apply smooth rotation
    local rotationAmount = math.min(angle, turnSpeed) * rotationDirection
    local newCFrame = HumanoidRootPart.CFrame * CFrame.Angles(0, rotationAmount, 0)
    HumanoidRootPart.CFrame = newCFrame
    
    -- Return true if we're still turning
    return math.abs(angle) > 0.1
end

-- Function to apply natural speed variations
local function updateSpeedVariation()
    if not Settings.SpeedVariation then return 1.0 end
    
    -- Only change speed occasionally
    if tick() - LastSpeedChange < 2 then return CurrentSpeedModifier end
    
    -- Randomly decide if we should change speed
    if math.random() < 0.3 then
        -- Create a small random variation (0.9 to 1.1)
        CurrentSpeedModifier = 0.9 + (math.random() * 0.2)
        LastSpeedChange = tick()
    end
    
    return CurrentSpeedModifier
end

-- Enhanced function to walk to position like a real player
local function walkToPosition(targetPosition)
    if not Character or not HumanoidRootPart or not Humanoid then
        return false
    end
    
    local startTime = tick()
    local timeout = 30 -- 30 second timeout
    local lastPathUpdate = 0
    local stuckCounter = 0
    local lastPosition = HumanoidRootPart.Position
    
    -- Enable humanoid movement
    Humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
    
    -- Create initial path if using pathfinding
    if Settings.UsePathfinding then
        PathPoints = createPath(targetPosition)
        if not PathPoints then
            -- Fall back to direct movement if pathfinding fails
            Settings.UsePathfinding = false
        else
            CurrentPathIndex = 2 -- Start at the second waypoint (first is current position)
        end
    end
    
    while tick() - startTime < timeout do
        if not Settings.Farming then break end
        
        local currentPos = HumanoidRootPart.Position
        local direction = (targetPosition - currentPos)
        local distance = direction.Magnitude
        
        -- Check if we're stuck
        if (currentPos - lastPosition).Magnitude < 0.5 then
            stuckCounter = stuckCounter + 1
            if stuckCounter > 5 then
                -- We're stuck, try to jump or recreate path
                Humanoid.Jump = true
                if Settings.UsePathfinding and tick() - lastPathUpdate > 3 then
                    PathPoints = createPath(targetPosition)
                    if PathPoints then
                        CurrentPathIndex = 2
                        lastPathUpdate = tick()
                    end
                end
                stuckCounter = 0
            end
        else
            stuckCounter = 0
        end
        
        lastPosition = currentPos
        
        -- If we're close enough, stop
        if distance < 3 then
            Humanoid:Move(Vector3.new(0, 0, 0))
            return true
        end
        
        -- Get our movement direction
        local moveDirection
        
        if Settings.UsePathfinding and PathPoints and CurrentPathIndex <= #PathPoints then
            -- Use pathfinding
            local currentWaypoint = PathPoints[CurrentPathIndex]
            local waypointPos = currentWaypoint.Position
            local waypointDistance = (waypointPos - currentPos).Magnitude
            
            -- If we've reached the current waypoint, move to the next
            if waypointDistance < 4 then
                CurrentPathIndex = CurrentPathIndex + 1
                if CurrentPathIndex > #PathPoints then
                    -- We've reached the end of the path
                    Humanoid:Move(Vector3.new(0, 0, 0))
                    return true
                end
            else
                -- Move towards the current waypoint
                moveDirection = (waypointPos - currentPos).Unit
            end
        else
            -- Direct movement
            moveDirection = direction.Unit
        end
        
        -- Apply speed variation
        local speedModifier = updateSpeedVariation()
        local adjustedSpeed = Settings.WalkSpeed * speedModifier
        
        -- Smoothly turn towards our movement direction
        if Settings.RealisticTurning then
            local targetLookAt = currentPos + moveDirection * 10
            IsTurning = smoothLookAt(targetLookAt, 0.1)
        end
        
        -- Move towards target
        Humanoid:Move(moveDirection * adjustedSpeed)
        
        -- Add natural pauses occasionally
        if Settings.NaturalPauses and math.random() < 0.01 then
            Humanoid:Move(Vector3.new(0, 0, 0))
            task.wait(0.2 + (math.random() * 0.3))
        end
        
        -- Wait a bit
        task.wait(0.1)
    end
    
    Humanoid:Move(Vector3.new(0, 0, 0))
    return false
end

-- Function to collect gingerbread at current position
local function collectGingerbread()
    local collected = false
    pcall(function()
        -- Try to collect using the remote
        local remote = game:GetService("ReplicatedStorage"):FindFirstChild("adoptme_new_net")
        if remote then
            local iceRemote = remote:FindFirstChild("adoptme_legacy_shared.ContentPacks.Winter2025.Game.IceSkating.IceSkatingNet:16")
            if iceRemote then
                iceRemote:FireServer()
                collected = true
                if Settings.Notifications then
                    Rayfield:Notify({
                        Title = "Collected",
                        Content = "Gingerbread collected!",
                        Duration = 1,
                        Image = 4483362458
                    })
                end
                task.wait(Settings.CollectDelay)
            else
                -- Try alternative remote names
                for _, child in ipairs(remote:GetChildren()) do
                    if string.find(child.Name:lower(), "iceskating") or string.find(child.Name:lower(), "winter") then
                        child:FireServer()
                        collected = true
                        task.wait(Settings.CollectDelay)
                        break
                    end
                end
            end
        end
    end)
    return collected
end

-- Main farming function with realistic movement
local function farmGingerbread()
    -- Make sure we have positions
    if #GingerbreadPositions == 0 then
        local count = findGingerbreadPositions()
        if count == 0 then
            Rayfield:Notify({
                Title = "Error",
                Content = "No gingerbreads found to farm!",
                Duration = 3,
                Image = 4483362458
            })
            Settings.Farming = false
            return
        end
    end
    
    -- Validate indices
    Settings.StartIndex = math.max(1, math.min(Settings.StartIndex, #GingerbreadPositions))
    Settings.EndIndex = math.max(1, math.min(Settings.EndIndex, #GingerbreadPositions))
    
    if Settings.StartIndex > Settings.EndIndex then
        -- Swap if start is greater than end
        Settings.StartIndex, Settings.EndIndex = Settings.EndIndex, Settings.StartIndex
    end
    
    -- First teleport to start position
    local startPos = GingerbreadPositions[Settings.StartIndex].Position
    HumanoidRootPart.CFrame = CFrame.new(startPos + Vector3.new(0, 3, 0))
    
    if Settings.Notifications then
        Rayfield:Notify({
            Title = "Teleported",
            Content = string.format("Teleported to gingerbread #%d", Settings.StartIndex),
            Duration = 3,
            Image = 4483362458
        })
    end
    
    task.wait(2) -- Wait a moment after teleport
    
    CurrentTargetIndex = Settings.StartIndex
    
    while Settings.Farming and CurrentTargetIndex <= Settings.EndIndex and CurrentTargetIndex <= #GingerbreadPositions do
        local gingerbreadData = GingerbreadPositions[CurrentTargetIndex]
        
        if not gingerbreadData then
            CurrentTargetIndex = CurrentTargetIndex + 1
            continue
        end
        
        -- Walk to the gingerbread
        if Settings.UseHumanoid and CurrentTargetIndex > Settings.StartIndex then
            -- For subsequent gingerbreads, walk instead of teleport
            if Settings.Notifications then
                Rayfield:Notify({
                    Title = "Moving",
                    Content = string.format("Walking to gingerbread #%d", CurrentTargetIndex),
                    Duration = 2,
                    Image = 4483362458
                })
            end
            
            local success = walkToPosition(gingerbreadData.Position)
            
            if not success then
                -- If walking failed, teleport as fallback
                HumanoidRootPart.CFrame = CFrame.new(gingerbreadData.Position + Vector3.new(0, 3, 0))
                task.wait(1)
            end
        else
            -- For first gingerbread or if walking is disabled
            HumanoidRootPart.CFrame = CFrame.new(gingerbreadData.Position + Vector3.new(0, 3, 0))
            task.wait(1)
        end
        
        -- Add a natural pause before collecting
        if Settings.NaturalPauses then
            task.wait(0.3 + (math.random() * 0.5))
        end
        
        -- Try to collect
        collectGingerbread()
        
        -- Move to next gingerbread
        CurrentTargetIndex = CurrentTargetIndex + 1
        
        -- Small pause between gingerbreads
        if Settings.Farming then
            task.wait(0.5)
        end
        
        -- If we reached the end, loop back to start
        if CurrentTargetIndex > Settings.EndIndex or CurrentTargetIndex > #GingerbreadPositions then
            if Settings.Notifications then
                Rayfield:Notify({
                    Title = "Loop Complete",
                    Content = "Finished route, returning to start...",
                    Duration = 3,
                    Image = 4483362458
                })
            end
            
            -- Teleport back to start
            local startPos = GingerbreadPositions[Settings.StartIndex].Position
            HumanoidRootPart.CFrame = CFrame.new(startPos + Vector3.new(0, 3, 0))
            task.wait(2)
            CurrentTargetIndex = Settings.StartIndex
        end
    end
    
    Settings.Farming = false
end

-- Anti-AFK
if Settings.AntiAFK then
    local VirtualUser = game:GetService("VirtualUser")
    game:GetService("Players").LocalPlayer.Idled:Connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    end)
end

-- Main Tab
MainTab:CreateSection("Farming Controls")

local farmingToggle = MainTab:CreateToggle({
    Name = "Start Farming",
    CurrentValue = Settings.Farming,
    Flag = "FarmingToggle",
    Callback = function(Value)
        Settings.Farming = Value
        if Value then
            Rayfield:Notify({
                Title = "Started",
                Content = "Gingerbread farming started! Walking like a real player...",
                Duration = 3,
                Image = 4483362458
            })
            task.spawn(farmGingerbread)
        else
            Rayfield:Notify({
                Title = "Stopped",
                Content = "Gingerbread farming stopped.",
                Duration = 3,
                Image = 4483362458
            })
            -- Stop any movement
            if Humanoid then
                Humanoid:Move(Vector3.new(0, 0, 0))
            end
        end
    end
})

MainTab:CreateButton({
    Name = "Scan Gingerbread Locations",
    Callback = function()
        local count = findGingerbreadPositions()
        if count > 0 then
            Rayfield:Notify({
                Title = "Scan Complete",
                Content = string.format("Found %d gingerbread locations", count),
                Duration = 3,
                Image = 4483362458
            })
        end
    end
})

MainTab:CreateButton({
    Name = "Test Walk to Next",
    Callback = function()
        if #GingerbreadPositions == 0 then
            local count = findGingerbreadPositions()
            if count == 0 then return end
        end
        
        if #GingerbreadPositions > 0 then
            local targetIndex = math.min(Settings.StartIndex + 1, #GingerbreadPositions)
            local targetPos = GingerbreadPositions[targetIndex].Position
            
            Rayfield:Notify({
                Title = "Walking Test",
                Content = string.format("Walking to gingerbread #%d", targetIndex),
                Duration = 3,
                Image = 4483362458
            })
            
            walkToPosition(targetPos)
        end
    end
})

MainTab:CreateButton({
    Name = "View Gingerbread List",
    Callback = function()
        if #GingerbreadPositions == 0 then
            local count = findGingerbreadPositions()
            if count == 0 then return end
        end
        
        local message = string.format("Found %d gingerbreads:\n", #GingerbreadPositions)
        for i = 1, math.min(10, #GingerbreadPositions) do
            local data = GingerbreadPositions[i]
            message = message .. string.format("%d: %s\n", i, data.ModelName or "Unknown")
        end
        
        if #GingerbreadPositions > 10 then
            message = message .. string.format("... and %d more", #GingerbreadPositions - 10)
        end
        
        Rayfield:Notify({
            Title = "Gingerbread List",
            Content = message,
            Duration = 5,
            Image = 4483362458
        })
    end
})

-- Settings Tab
SettingsTab:CreateSection("Movement Settings")

SettingsTab:CreateSlider({
    Name = "Walk Speed",
    Range = {8, 32},
    Increment = 1,
    Suffix = "studs/sec",
    CurrentValue = Settings.WalkSpeed,
    Flag = "WalkSpeed",
    Callback = function(Value)
        Settings.WalkSpeed = Value
    end
})

SettingsTab:CreateSlider({
    Name = "Collection Delay",
    Range = {0.1, 2},
    Increment = 0.1,
    Suffix = "seconds",
    CurrentValue = Settings.CollectDelay,
    Flag = "CollectDelay",
    Callback = function(Value)
        Settings.CollectDelay = Value
    end
})

SettingsTab:CreateInput({
    Name = "Start Index",
    PlaceholderText = "32",
    RemoveTextAfterFocusLost = false,
    CurrentValue = tostring(Settings.StartIndex),
    Flag = "StartIndex",
    Callback = function(Value)
        local num = tonumber(Value)
        if num and num >= 1 then
            Settings.StartIndex = math.floor(num)
        end
    end
})

SettingsTab:CreateInput({
    Name = "End Index",
    PlaceholderText = "188",
    RemoveTextAfterFocusLost = false,
    CurrentValue = tostring(Settings.EndIndex),
    Flag = "EndIndex",
    Callback = function(Value)
        local num = tonumber(Value)
        if num and num >= 1 then
            Settings.EndIndex = math.floor(num)
        end
    end
})

SettingsTab:CreateToggle({
    Name = "Use Humanoid Movement",
    CurrentValue = Settings.UseHumanoid,
    Flag = "UseHumanoid",
    Callback = function(Value)
        Settings.UseHumanoid = Value
        Rayfield:Notify({
            Title = "Movement Mode",
            Content = Value and "Will walk like real player" or "Will teleport to each",
            Duration = 3,
            Image = 4483362458
        })
    end
})

SettingsTab:CreateToggle({
    Name = "Use Pathfinding",
    CurrentValue = Settings.UsePathfinding,
    Flag = "UsePathfinding",
    Callback = function(Value)
        Settings.UsePathfinding = Value
        Rayfield:Notify({
            Title = "Pathfinding",
            Content = Value and "Will use smart pathfinding" or "Will use direct movement",
            Duration = 3,
            Image = 4483362458
        })
    end
})

SettingsTab:CreateToggle({
    Name = "Realistic Turning",
    CurrentValue = Settings.RealisticTurning,
    Flag = "RealisticTurning",
    Callback = function(Value)
        Settings.RealisticTurning = Value
        Rayfield:Notify({
            Title = "Turning",
            Content = Value and "Will turn smoothly" or "Will turn instantly",
            Duration = 3,
            Image = 4483362458
        })
    end
})

SettingsTab:CreateToggle({
    Name = "Speed Variation",
    CurrentValue = Settings.SpeedVariation,
    Flag = "SpeedVariation",
    Callback = function(Value)
        Settings.SpeedVariation = Value
        Rayfield:Notify({
            Title = "Speed Variation",
            Content = Value and "Will vary walking speed" or "Will use constant speed",
            Duration = 3,
            Image = 4483362458
        })
    end
})

SettingsTab:CreateToggle({
    Name = "Natural Pauses",
    CurrentValue = Settings.NaturalPauses,
    Flag = "NaturalPauses",
    Callback = function(Value)
        Settings.NaturalPauses = Value
        Rayfield:Notify({
            Title = "Natural Pauses",
            Content = Value and "Will pause occasionally" or "Will move continuously",
            Duration = 3,
            Image = 4483362458
        })
    end
})

SettingsTab:CreateSection("Preferences")

SettingsTab:CreateToggle({
    Name = "Anti-AFK",
    CurrentValue = Settings.AntiAFK,
    Flag = "AntiAFK",
    Callback = function(Value)
        Settings.AntiAFK = Value
    end
})

SettingsTab:CreateToggle({
    Name = "Notifications",
    CurrentValue = Settings.Notifications,
    Flag = "Notifications",
    Callback = function(Value)
        Settings.Notifications = Value
    end
})

SettingsTab:CreateButton({
    Name = "Save Settings",
    Callback = function()
        Rayfield:Notify({
            Title = "Settings Saved",
            Content = "Your settings have been saved!",
            Duration = 3,
            Image = 4483362458
        })
    end
})

-- Character handling
Player.CharacterAdded:Connect(function(newChar)
    Character = newChar
    task.wait(1)
    HumanoidRootPart = newChar:WaitForChild("HumanoidRootPart")
    Humanoid = newChar:WaitForChild("Humanoid")
end)

-- Initial scan
task.spawn(function()
    task.wait(3)
    findGingerbreadPositions()
end)

-- Initial notification
Rayfield:Notify({
    Title = "Gingerbread Farm",
    Content = "UI loaded successfully! Will walk like a real player. üç™",
    Duration = 5,
    Image = 4483362458
})

print("[Gingerbread Farm] UI Loaded Successfully!")
print("[Gingerbread Farm] Movement Mode: Realistic Walking")
