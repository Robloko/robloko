-- Enhanced Gingerbread Farm UI Script for Roblox Adopt Me
-- Load Rayfield UI Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Player setup
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Create the main window
local Window = Rayfield:CreateWindow({
   Name = "üç™ Gingerbread Farm Pro",
   LoadingTitle = "Gingerbread Farm Pro",
   LoadingSubtitle = "Enhanced with Safety Features",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "GingerbreadFarm",
      FileName = "GingerbreadConfigPro"
   },
   Discord = {
      Enabled = false,
      Invite = "",
      RememberJoins = true
   },
   KeySystem = false,
   KeySettings = {
      Title = "Access Key",
      Subtitle = "Enter Key",
      Note = "Join discord.gg/rayfield for key",
      FileName = "GingerbreadKey",
      SaveKey = true,
      GrabKeyFromSite = false,
      Key = {"GINGER2024"}
   }
})

-- Settings table with default values
local Settings = {
   StartFarming = false,
   TeleportDelay = 1.5,
   RandomDelay = 0.5,
   StartIndex = 32,
   EndIndex = 188,
   UseHumanMovement = true,
   AntiAFK = true,
   AutoStopOnError = true,
   MaxErrors = 5,
   CollectMethod = 1,
   SafeMode = true,
   LoopMode = true
}

-- Statistics
local Stats = {
   Collected = 0,
   Errors = 0,
   CurrentIndex = 0,
   StartTime = 0,
   Runtime = 0
}

-- Status variables
local IsFarming = false
local FarmingThread = nil

-- Anti-AFK System
local function setupAntiAFK()
    if Settings.AntiAFK then
        local VirtualUser = game:GetService("VirtualUser")
        Player.Idled:Connect(function()
            VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
            task.wait(1)
            VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        end)
        print("Anti-AFK system enabled")
    end
end

-- Get random delay
local function getRandomDelay()
    return Settings.TeleportDelay + (math.random(-Settings.RandomDelay * 100, Settings.RandomDelay * 100) / 100)
end

-- Smooth teleport function
local function smoothTeleport(cframe)
    if Settings.UseHumanMovement and HumanoidRootPart then
        local distance = (HumanoidRootPart.Position - cframe.Position).Magnitude
        
        if distance < 50 then -- Use tween for short distances
            local tweenInfo = TweenInfo.new(
                0.5 + (distance / 100), -- Duration based on distance
                Enum.EasingStyle.Quad,
                Enum.EasingDirection.Out
            )
            
            local tween = TweenService:Create(HumanoidRootPart, tweenInfo, {CFrame = cframe})
            tween:Play()
            local success = pcall(function()
                tween.Completed:Wait()
            end)
            
            if not success then
                HumanoidRootPart.CFrame = cframe
            end
        else
            HumanoidRootPart.CFrame = cframe
        end
    else
        HumanoidRootPart.CFrame = cframe
    end
end

-- Find gingerbread remote with multiple fallbacks
local function getGingerbreadRemote()
    local remoteNames = {
        "adoptme_legacy_shared.ContentPacks.Winter2025.Game.IceSkating.IceSkatingNet:16",
        "adoptme_new_net.IceSkatingNet:16",
        "IceSkatingNet",
        "CollectGingerbread",
        "GingerbreadCollect",
        "CollectGingerbreadMan"
    }
    
    for _, remoteName in pairs(remoteNames) do
        local remote = ReplicatedStorage:FindFirstChild("adoptme_new_net")
        if remote then
            remote = remote:FindFirstChild(remoteName)
            if remote then
                return remote
            end
        end
    end
    
    -- Try searching in other locations
    for _, remoteName in pairs(remoteNames) do
        local remote = ReplicatedStorage:FindFirstChild(remoteName)
        if remote then
            return remote
        end
    end
    
    return nil
end

-- Collect gingerbread with multiple methods
local function collectGingerbread()
    local methods = {
        function() -- Method 1: Direct remote
            local remote = getGingerbreadRemote()
            if remote then
                remote:FireServer()
                return true
            end
            return false
        end,
        
        function() -- Method 2: Try different remote paths
            pcall(function()
                game:GetService("ReplicatedStorage").adoptme_new_net:FireServer("CollectGingerbread")
            end)
            return true
        end,
        
        function() -- Method 3: Click simulation
            pcall(function()
                local args = {
                    [1] = "GingerbreadMan",
                    [2] = "Collect"
                }
                game:GetService("ReplicatedStorage").adoptme_new_net:FireServer(unpack(args))
            end)
            return true
        end
    }
    
    -- Try all collection methods
    for i = 1, #methods do
        if Settings.CollectMethod == 0 or Settings.CollectMethod == i then
            local success = pcall(methods[i])
            if success then
                return true
            end
        end
    end
    
    return false
end

-- Enhanced teleport and collect function
local function teleportAndCollect(index)
    local success, result = pcall(function()
        Stats.CurrentIndex = index
        
        -- Find interior
        local interior = workspace.Interiors:FindFirstChild("MainMap!Christmas")
        if not interior then
            error("Christmas interior not found")
        end
        
        local children = interior:GetChildren()
        if index > #children then
            error("Index out of range: " .. index .. " > " .. #children)
        end
        
        local targetModel = children[index]
        if not targetModel then
            error("Target model not found at index: " .. index)
        end
        
        -- Find gingerbread
        local gingerbread = targetModel:FindFirstChild("GingerbreadMan") or 
                           targetModel:FindFirstChild("Gingerbread") or
                           targetModel:FindFirstChild("GingerbreadManNPC")
        
        if not gingerbread or not gingerbread:IsA("BasePart") then
            error("Gingerbread part not found in model: " .. targetModel.Name)
        end
        
        -- Calculate safe position
        local offset = Vector3.new(0, 3, 0)
        if Settings.SafeMode then
            offset = Vector3.new(
                math.random(-2, 2),
                3,
                math.random(-2, 2)
            )
        end
        
        local targetCFrame = gingerbread.CFrame + offset
        
        -- Teleport
        smoothTeleport(targetCFrame)
        
        -- Face the gingerbread
        if Character and Character:FindFirstChild("Humanoid") then
            Character.Humanoid:MoveTo(gingerbread.Position)
        end
        
        -- Wait for stabilization
        local waitTime = getRandomDelay() / 2
        task.wait(waitTime)
        
        -- Collect
        local collected = collectGingerbread()
        if collected then
            Stats.Collected = Stats.Collected + 1
        end
        
        -- Additional wait before next action
        task.wait(waitTime)
        
        return true
    end)
    
    if not success then
        Stats.Errors = Stats.Errors + 1
        warn("Error at index", index, ":", result)
        return false, result
    end
    
    return true
end

-- Main farming loop
local function startFarmingLoop()
    if IsFarming then return end
    
    IsFarming = true
    Stats.StartTime = os.time()
    Stats.Errors = 0
    
    Rayfield:Notify({
        Title = "üöÄ Farming Started",
        Content = string.format("Collecting from index %d to %d", Settings.StartIndex, Settings.EndIndex),
        Duration = 3,
        Image = nil
    })
    
    while IsFarming do
        for index = Settings.StartIndex, Settings.EndIndex do
            if not IsFarming then break end
            
            -- Update runtime
            Stats.Runtime = os.time() - Stats.StartTime
            
            -- Check error limit
            if Settings.AutoStopOnError and Stats.Errors >= Settings.MaxErrors then
                Rayfield:Notify({
                    Title = "‚ö†Ô∏è Auto-Stopped",
                    Content = string.format("Too many errors (%d). Stopping farm.", Stats.Errors),
                    Duration = 5,
                    Image = nil
                })
                IsFarming = false
                break
            end
            
            -- Perform collection
            local success, err = teleportAndCollect(index)
            
            if success then
                -- Update status label if it exists
                if StatusLabel then
                    StatusLabel:Set(string.format(
                        "Index: %d | Collected: %d | Errors: %d | Time: %ds",
                        index, Stats.Collected, Stats.Errors, Stats.Runtime
                    ))
                end
            else
                -- Log error but continue
                warn("Failed at index", index, ":", err)
            end
            
            -- Delay with variation
            local delay = getRandomDelay()
            task.wait(delay)
        end
        
        -- Loop if enabled
        if IsFarming and Settings.LoopMode then
            Rayfield:Notify({
                Title = "üîÅ Loop Restart",
                Content = string.format("Completed cycle. Collected: %d. Restarting...", Stats.Collected),
                Duration = 2,
                Image = nil
            })
            task.wait(3) -- Wait between loops
        else
            break
        end
    end
    
    IsFarming = false
    Rayfield:Notify({
        Title = "‚úÖ Farming Stopped",
        Content = string.format("Final Stats: %d collected in %d seconds", Stats.Collected, Stats.Runtime),
        Duration = 5,
        Image = nil
    })
end

-- Create tabs
local MainTab = Window:CreateTab("Main Farming", "üåæ")
local SettingsTab = Window:CreateTab("Settings", "‚öôÔ∏è")
local TeleportTab = Window:CreateTab("Teleport", "üìç")
local StatsTab = Window:CreateTab("Statistics", "üìä")

-- ===== MAIN TAB =====
MainTab:CreateSection("Farming Control")

-- Status label
StatusLabel = MainTab:CreateLabel("Status: Ready")

-- Main toggle
MainTab:CreateToggle({
   Name = "Start/Stop Farming",
   CurrentValue = false,
   Flag = "FarmToggle",
   Callback = function(State)
        if State then
            if not IsFarming then
                FarmingThread = coroutine.create(startFarmingLoop)
                coroutine.resume(FarmingThread)
            end
        else
            IsFarming = false
            StatusLabel:Set("Status: Stopped")
        end
   end
})

-- Emergency stop button
MainTab:CreateButton({
   Name = "üö® Emergency Stop",
   Callback = function()
        IsFarming = false
        Rayfield:Notify({
            Title = "üõë EMERGENCY STOP",
            Content = "All farming activities immediately stopped!",
            Duration = 5,
            Image = nil
        })
   end
})

-- Test button
MainTab:CreateButton({
   Name = "Test Current Index",
   Callback = function()
        local success, err = teleportAndCollect(Settings.StartIndex)
        if success then
            Rayfield:Notify({
                Title = "‚úÖ Test Success",
                Content = string.format("Successfully collected at index %d", Settings.StartIndex),
                Duration = 3,
                Image = nil
            })
        else
            Rayfield:Notify({
                Title = "‚ùå Test Failed",
                Content = "Error: " .. tostring(err),
                Duration = 5,
                Image = nil
            })
        end
   end
})

-- ===== SETTINGS TAB =====
SettingsTab:CreateSection("Movement Settings")

SettingsTab:CreateToggle({
   Name = "Use Human-Like Movement",
   CurrentValue = Settings.UseHumanMovement,
   Flag = "HumanMovement",
   Callback = function(Value)
        Settings.UseHumanMovement = Value
   end
})

SettingsTab:CreateToggle({
   Name = "Safe Mode (Random Offset)",
   CurrentValue = Settings.SafeMode,
   Flag = "SafeMode",
   Callback = function(Value)
        Settings.SafeMode = Value
   end
})

SettingsTab:CreateToggle({
   Name = "Enable Anti-AFK",
   CurrentValue = Settings.AntiAFK,
   Flag = "AntiAFK",
   Callback = function(Value)
        Settings.AntiAFK = Value
        if Value then
            setupAntiAFK()
        end
   end
})

SettingsTab:CreateSection("Delay Settings")

SettingsTab:CreateSlider({
   Name = "Base Teleport Delay",
   Range = {0.5, 5},
   Increment = 0.1,
   Suffix = "s",
   CurrentValue = Settings.TeleportDelay,
   Flag = "BaseDelay",
   Callback = function(Value)
        Settings.TeleportDelay = Value
   end
})

SettingsTab:CreateSlider({
   Name = "Random Delay Variation",
   Range = {0, 2},
   Increment = 0.1,
   Suffix = "s",
   CurrentValue = Settings.RandomDelay,
   Flag = "RandomDelay",
   Callback = function(Value)
        Settings.RandomDelay = Value
   end
})

-- ===== TELEPORT TAB =====
TeleportTab:CreateSection("Index Range")

TeleportTab:CreateInput({
   Name = "Start Index",
   PlaceholderText = "32",
   RemoveTextAfterFocusLost = false,
   CurrentValue = tostring(Settings.StartIndex),
   Flag = "StartIndexInput",
   Callback = function(Value)
        local num = tonumber(Value)
        if num and num > 0 then
            Settings.StartIndex = math.floor(num)
        end
   end
})

TeleportTab:CreateInput({
   Name = "End Index",
   PlaceholderText = "188",
   RemoveTextAfterFocusLost = false,
   CurrentValue = tostring(Settings.EndIndex),
   Flag = "EndIndexInput",
   Callback = function(Value)
        local num = tonumber(Value)
        if num and num > 0 then
            Settings.EndIndex = math.floor(num)
        end
   end
})

TeleportTab:CreateSection("Quick Teleports")

-- Create buttons for specific indices
local quickIndices = {31, 32, 33, 34, 35, 188, 1, 100, 150}

for _, index in ipairs(quickIndices) do
    TeleportTab:CreateButton({
        Name = "üìç Teleport to Index " .. index,
        Callback = function()
            local success, err = teleportAndCollect(index)
            if success then
                Rayfield:Notify({
                    Title = "Teleported",
                    Content = "Successfully teleported to index: " .. index,
                    Duration = 3,
                    Image = nil
                })
            else
                Rayfield:Notify({
                    Title = "Failed",
                    Content = "Failed to teleport: " .. tostring(err),
                    Duration = 5,
                    Image = nil
                })
            end
        end
    })
end

-- ===== STATISTICS TAB =====
StatsTab:CreateSection("Live Statistics")

local StatsLabel = StatsTab:CreateLabel("Waiting for data...")

-- Update stats display
local function updateStatsDisplay()
    if IsFarming then
        StatsLabel:Set(string.format([[
üìä Farming Statistics:
        
‚è±Ô∏è Runtime: %d seconds
üç™ Collected: %d
‚ö†Ô∏è Errors: %d
üìç Current Index: %d
üìà Efficiency: %.1f/min
        
üîÅ Loop Mode: %s
üõ°Ô∏è Safe Mode: %s
        ]],
        Stats.Runtime,
        Stats.Collected,
        Stats.Errors,
        Stats.CurrentIndex,
        (Stats.Runtime > 0 and Stats.Collected / (Stats.Runtime / 60)) or 0,
        Settings.LoopMode and "Enabled" or "Disabled",
        Settings.SafeMode and "Enabled" or "Disabled"
        ))
    else
        StatsLabel:Set(string.format([[
üìä Last Session Stats:
        
üç™ Total Collected: %d
‚ö†Ô∏è Total Errors: %d
‚è±Ô∏è Last Runtime: %d seconds
üìà Efficiency: %.1f/min
        
Status: Ready
        ]],
        Stats.Collected,
        Stats.Errors,
        Stats.Runtime,
        (Stats.Runtime > 0 and Stats.Collected / (Stats.Runtime / 60)) or 0
        ))
    end
end

-- Reset stats button
StatsTab:CreateButton({
   Name = "Reset Statistics",
   Callback = function()
        Stats = {
            Collected = 0,
            Errors = 0,
            CurrentIndex = 0,
            StartTime = 0,
            Runtime = 0
        }
        updateStatsDisplay()
        Rayfield:Notify({
            Title = "Statistics Reset",
            Content = "All statistics have been reset to zero.",
            Duration = 3,
            Image = nil
        })
   end
})

-- Auto-update stats
coroutine.wrap(function()
    while true do
        updateStatsDisplay()
        task.wait(1)
    end
end)()

-- Character respawn handler
Player.CharacterAdded:Connect(function(newChar)
    task.wait(1) -- Wait for character to fully load
    Character = newChar
    repeat task.wait(0.5) 
    until Character:FindFirstChild("HumanoidRootPart")
    HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    Rayfield:Notify({
        Title = "Character Loaded",
        Content = "Character respawn detected and ready.",
        Duration = 3,
        Image = nil
    })
end)

-- Initial setup
setupAntiAFK()

-- Notify when ready
Rayfield:Notify({
   Title = "üéÑ Gingerbread Farm Pro",
   Content = "Script loaded successfully!\nConfigure settings before starting.",
   Duration = 5,
   Image = nil
})

print("Gingerbread Farm Pro loaded successfully!")
print("Current Settings:")
for key, value in pairs(Settings) do
    print("  " .. key .. ": " .. tostring(value))
end
