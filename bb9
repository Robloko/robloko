[file name]: bb8.txt
[file content begin]
-- Small Script to Go to Main Map and Then to Specific Character Position
-- Based on logic from ress0 — копия.txt
-- Added respawn and unsubscribe from home at the beginning
-- Added choose Baby team at the beginning (from b1.txt)
-- Added baby ailment detection and handling (from bb3.txt, integrated with monitoring)
-- Added camera reset after arriving at character position
-- Integrated furniture and food handling for baby ailments
-- Added beach_party ailment handling: teleport to character position if detected
-- Updated bored ailment handling: teleport to specific bored position instead of using Piano
-- Added school ailment handling: teleport to school character position, set camera, pressW
-- Added salon ailment handling: teleport to salon character position, set camera, pressW
-- Added pizza_party ailment handling: teleport to pizza_party character position, set camera, pressW
-- ADDED: Integrated PetFarm logic from w1.txt with new furniture from bb8 and removed Piano

repeat task.wait() until game:IsLoaded()
repeat task.wait() until game.Players.LocalPlayer
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

-----------------------------------------------------
-- UTILITIES (Simplified from ress0)
-----------------------------------------------------
local function log(msg) print("[MainMap Teleporter] " .. tostring(msg)) end
local function getChar() return player.Character or player.CharacterAdded:Wait() end
local function safeTp(pos)
    return pcall(function()
        local hrp = getChar():FindFirstChild("HumanoidRootPart")
        if hrp then hrp.CFrame = CFrame.new(pos); task.wait(0.3) end
    end)
end
local function setCam(pos, look)
    pcall(function()
        local cam = Workspace.CurrentCamera
        if cam then cam.CameraType = Enum.CameraType.Scriptable; cam.CFrame = CFrame.new(pos, look) end
    end)
end
local function resetCam()
    pcall(function()
        local cam = Workspace.CurrentCamera
        if cam then cam.CameraType = Enum.CameraType.Custom end
    end)
end
local function pressW()
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
    end)
end
local function isNear(pos, dist)
    dist = dist or 60
    local success, result = pcall(function()
        local hrp = getChar():FindFirstChild("HumanoidRootPart")
        return hrp and (hrp.Position - pos).Magnitude < dist
    end)
    return success and result or false
end

local function pressS()
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.s, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.s, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
    end)
end

-----------------------------------------------------
-- PETFARM VARIABLES AND FUNCTIONS (from w1.txt)
-----------------------------------------------------
local DEBUG_MODE = true
local PetFarmMode = false
local petFarmCoroutine = nil
local petFarmPetID = nil
local currentToyID = nil
local currentStrollerID = nil
local currentFoodID = nil
local AutoPetPenMode = false
local autoPetPenCoroutine = nil
local lastPetPenCommitTime = 0
local sessionBucksEarned = 0
local sessionPotionsEarned = 0
local lastMoneyAmount = 0
local lastPotionAmount = 0
local ContinuousMode = false
local continuousCoroutine = nil
local AutoAcceptMode = false
local autoAcceptCoroutine = nil
local AutoPotionMode = false
local autoPotionCoroutine = nil
local scriptInitialized = false
local PetID = nil
local Pet = nil
local PetsShow = {}
local currentSelectedPetKey = nil
local lastValidPetID = nil

-- Priority eggs for Auto PetPen
local priorityEggs = {
    "basic_egg_2022_ant",
    "cracked_egg"
}
local prioritySet = {}
for _, v in ipairs(priorityEggs) do prioritySet[v] = true end

-- UPDATED AILMENT TO FURNITURE MAPPING (using bb8 furniture, removed Piano)
local AILMENT_TASKS = {
    sleepy = "SleepingBag",
    hungry = "PetFoodBowl", 
    thirsty = "PetWaterBowl",
    dirty = "CampingShower",
    bored = "teleport_to_bored",  -- Custom handling for bored (teleport)
    toilet = "AilmentsRefresh2024LitterBox",
    play = "THROW_TOY",
    walk = "WALK_HANDLER",
    ride = "STROLLER_HANDLER",
    sick = "HEALING_APPLE",
    mystery = "MYSTERY_HANDLER",
    pet_me = "PET_ME_HANDLER"
}

-- Task cooldowns to prevent spam
local lastTaskTime = {}
local TASK_COOLDOWN = 30 -- seconds

local function debugPrint(message)
    if not DEBUG_MODE then return end
    local hours = os.date("%H")
    local minutes = os.date("%M")
    local seconds = os.date("%S")
    local timestamp = string.format("[%s:%s:%s]", hours, minutes, seconds)
    print(timestamp .. " " .. message)
end

-- ==================================================================
-- PETFARM CORE FUNCTIONS (from w1.txt)
-- ==================================================================

-- Function to get player data
local function getPlayerData()
    local success, data = pcall(function()
        return require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    end)
    if not success or not data then
        debugPrint("Failed to get player data")
        return nil
    end
    return data
end

-- Function to check if pet is equipped via equip_manager
local function isPetEquipped(petUniqueID)
    local data = getPlayerData()
    if not data or not data.equip_manager or not data.equip_manager.pets then
        debugPrint("Cannot check equip status: equip_manager not found")
        return false
    end
    for _, equippedPet in pairs(data.equip_manager.pets) do
        if equippedPet and equippedPet.unique == petUniqueID then
            debugPrint("Pet " .. petUniqueID .. " is equipped (confirmed via equip_manager)")
            return true
        end
    end
    debugPrint("Pet " .. petUniqueID .. " is NOT equipped (via equip_manager)")
    return false
end

-- Function to find the pet model
local function findPetModel(petUniqueID)
    debugPrint("Searching for pet model with ID: " .. tostring(petUniqueID))
    local data = getPlayerData()
    if not data or not data.inventory or not data.inventory.pets then
        debugPrint("Failed to get player data or pet inventory")
        return nil
    end
    for petID, petData in pairs(data.inventory.pets) do
        if petData.unique == petUniqueID then
            debugPrint("Found matching pet in inventory: " .. tostring(petData.id))
            local petsFolder = Workspace:FindFirstChild("Pets")
            if not petsFolder then
                debugPrint("Pets folder not found")
                return nil
            end
            -- Try exact match first
            local petModel = petsFolder:FindFirstChild(petData.id)
            if petModel then
                debugPrint("Found pet model: " .. petModel.Name)
                return petModel
            end
            -- Try case-insensitive search
            for _, child in pairs(petsFolder:GetChildren()) do
                if string.lower(child.Name) == string.lower(petData.id) then
                    debugPrint("Found pet model (case-insensitive): " .. child.Name)
                    return child
                end
            end
            debugPrint("Pet model not found.")
            return nil
        end
    end
    debugPrint("No pet found with unique ID: " .. tostring(petUniqueID))
    return nil
end

-- Character validation
local function getValidCharacter()
    local currentChar = player.Character
    if currentChar and currentChar.Parent and currentChar:FindFirstChild("HumanoidRootPart") then
        return currentChar
    end
    debugPrint("Character not found or invalid, waiting for CharacterAdded...")
    local character = player.CharacterAdded:Wait()
    local startTime = os.time()
    while os.time() - startTime < 10 do
        if character and character.Parent and character:FindFirstChild("HumanoidRootPart") then
            debugPrint("Character loaded successfully")
            return character
        end
        task.wait(0.5)
    end
    debugPrint("Failed to load valid character after waiting")
    return nil
end

-- Ensure character is spawned and valid
local function ensureCharacterSpawned()
    local char = getValidCharacter()
    if not char then
        debugPrint("Respawning character...")
        ReplicatedStorage:WaitForChild("API"):WaitForChild("TeamAPI/Spawn"):InvokeServer()
        task.wait(5)
        char = getValidCharacter()
    end
    return char
end

-- Check if player is at home
local function isPlayerAtHome()
    local hi = Workspace:FindFirstChild("HouseInteriors")
    if not hi then
        return false
    end
    for _, folder in ipairs(hi:GetChildren()) do
        if string.find(folder.Name, player.Name) then
            return true
        end
    end
    return false
end

-- Find player's pet in workspace
local function findPlayerPetInWorkspace()
    local char = getValidCharacter()
    if not char then
        debugPrint("Cannot find pet: No valid character")
        return nil
    end
    if workspace:FindFirstChild("Pets") then
        for _, petInWorkspace in ipairs(workspace.Pets:GetChildren()) do
            if petInWorkspace:FindFirstChild("Owner") and petInWorkspace.Owner.Value == player then
                return petInWorkspace
            end
        end
    end
    if workspace:FindFirstChild("Pets") then
        for _, petInWorkspace in ipairs(workspace.Pets:GetChildren()) do
            if petInWorkspace:FindFirstChild("PetProperties") then
                local properties = petInWorkspace.PetProperties
                if properties:FindFirstChild("Owner") and properties.Owner.Value == player then
                    return petInWorkspace
                end
            end
        end
    end
    local humanoidRootPart = char:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart and workspace:FindFirstChild("Pets") then
        for _, petInWorkspace in ipairs(workspace.Pets:GetChildren()) do
            if petInWorkspace:FindFirstChild("HumanoidRootPart") then
                local distance = (petInWorkspace.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                if distance < 20 then
                    return petInWorkspace
                end
            end
        end
    end
    if workspace:FindFirstChild("Pets") then
        for _, petInWorkspace in ipairs(workspace.Pets:GetChildren()) do
            if petInWorkspace:IsA("Model") and petInWorkspace:FindFirstChild("Humanoid") then
                return petInWorkspace
            end
        end
    end
    debugPrint("No pet found in workspace using all search methods")
    return nil
end

-- Ensure pet is equipped
local function ensurePetEquipped(petUniqueID, timeout)
    timeout = timeout or 15
    if not petUniqueID then
        debugPrint("ensurePetEquipped: no petUniqueID provided")
        return false
    end
    -- Primary check: equip_manager (more reliable)
    if isPetEquipped(petUniqueID) then
        debugPrint("Pet already equipped via equip_manager")
        -- Secondary: Ensure it's in workspace too
        if findPlayerPetInWorkspace() then
            debugPrint("Pet also present in workspace")
            petFarmPetID = petUniqueID
            return true
        end
    end
    -- If not equipped, attempt to equip
    debugPrint("Pet not equipped, equipping: " .. tostring(petUniqueID))
    local success, result = pcall(function()
        return ReplicatedStorage.API["ToolAPI/Equip"]:InvokeServer(petUniqueID, {use_sound_delay = true, equip_as_last = false})
    end)
    if not success then
        debugPrint("Failed to equip pet: " .. tostring(result))
        return false
    end
    -- Wait and verify
    local startTime = os.time()
    while os.time() - startTime < timeout do
        if isPetEquipped(petUniqueID) and findPlayerPetInWorkspace() then
            debugPrint("Pet successfully equipped and present")
            petFarmPetID = petUniqueID
            return true
        end
        task.wait(0.5) -- More frequent checks
    end
    debugPrint("Pet did not fully equip within timeout")
    return false
end

-- Safely unequip toy
local function safelyUnequipToy()
    if currentToyID then
        debugPrint("Unequipping toy: " .. currentToyID)
        local args = { currentToyID }
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(args))
        end)
     
        if success then
            debugPrint("Successfully unequipped toy")
        else
            debugPrint("Failed to unequip toy: " .. tostring(result))
        end
     
        currentToyID = nil
        task.wait(1)
    else
        debugPrint("No toy equipped to unequip - skipping")
    end
end

-- Safely unequip stroller
local function safelyUnequipStroller()
    if currentStrollerID then
        debugPrint("Unequipping stroller: " .. currentStrollerID)
        local args = { currentStrollerID }
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(args))
        end)
        if success then
            debugPrint("Successfully unequipped stroller")
        else
            debugPrint("Failed to unequip stroller: " .. tostring(result))
        end
        currentStrollerID = nil
        task.wait(1)
    else
        debugPrint("No stroller equipped to unequip - skipping")
    end
end

-- Safely unequip food
local function safelyUnequipFood(foodID)
    if foodID then
        debugPrint("Unequipping food: " .. foodID)
        local args = { foodID }
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(args))
        end)
        if success then
            debugPrint("Successfully unequipped food")
        else
            debugPrint("Failed to unequip food: " .. tostring(result))
        end
        task.wait(1)
    end
end

-- ==================================================================
-- PLAY AILMENT HANDLER (from w1.txt)
-- ==================================================================
local SQUEAKY_BONE_ID = nil
local function getSqueakyBoneID()
    if SQUEAKY_BONE_ID then
        return SQUEAKY_BONE_ID
    end
 
    local success, data = pcall(function()
        return require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    end)
 
    if not success or not data or not data.inventory or not data.inventory.toys then
        debugPrint("No inventory or toys data found!")
        return nil
    end
 
    for uniqueId, toyData in pairs(data.inventory.toys) do
        if toyData.id == "squeaky_bone_default" then
            debugPrint("Found squeaky_bone_default → ID: " .. uniqueId)
            SQUEAKY_BONE_ID = uniqueId
            return uniqueId
        end
    end
 
    debugPrint("squeaky_bone_default NOT FOUND in inventory!")
    return nil
end

-- Single throw function
local function performThrowToy()
    local toyID = getSqueakyBoneID()
    if not toyID then
        debugPrint("NO squeaky_bone_default → Play ailment skipped")
        return false
    end
 
    debugPrint("Using squeaky_bone_default → " .. toyID)
    currentToyID = toyID
 
    -- EQUIP
    local success1, err1 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/Equip"]:InvokeServer(toyID, {
            use_sound_delay = true,
            equip_as_last = false
        })
    end)
 
    if not success1 then
        debugPrint("Failed to equip toy: " .. tostring(err1))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1.2)
 
    -- START
    local success2, err2 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/ServerUseTool"]:FireServer(toyID, "START")
    end)
 
    if not success2 then
        debugPrint("Failed to start using toy: " .. tostring(err2))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1)
 
    -- TRIGGER PET REACTION
    local success3, err3 = pcall(function()
        return ReplicatedStorage.API["PetObjectAPI/CreatePetObject"]:InvokeServer(
            "__Enum_PetObjectCreatorType_1",
            { reaction_name = "ThrowToyReaction", unique_id = toyID }
        )
    end)
 
    if not success3 then
        debugPrint("Failed to trigger pet reaction: " .. tostring(err3))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1.1)
 
    -- END
    local success4, err4 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/ServerUseTool"]:FireServer(toyID, "END")
    end)
 
    if not success4 then
        debugPrint("Failed to end using toy: " .. tostring(err4))
        safelyUnequipToy()
        return false
    end
 
    debugPrint("squeaky_bone_default throw SUCCESS")
    return true
end

-- Complete throw sequence (3 throws)
local function performThrowToySequence()
    debugPrint("Starting squeaky_bone_default throw sequence (3x)...")
    local toyID = getSqueakyBoneID()
    if not toyID then
        debugPrint("NO squeaky_bone_default → Play ailment skipped")
        return false
    end
 
    local successfulThrows = 0
 
    for i = 1, 3 do
        if not PetFarmMode then
            debugPrint("PetFarm stopped → canceling throw sequence")
            safelyUnequipToy()
            return false
        end
     
        debugPrint("Throw #" .. i .. " with squeaky_bone_default")
        local success, err = pcall(performThrowToy)
     
        if success and err then
            successfulThrows += 1
            debugPrint("Throw #" .. i .. " SUCCESS")
        else
            debugPrint("Throw #" .. i .. " FAILED: " .. tostring(err) .. " → stopping sequence")
            safelyUnequipToy()
            return false
        end
     
        if i < 3 then
            for w = 1, 9 do
                if not PetFarmMode then
                    safelyUnequipToy()
                    return false
                end
                task.wait(1)
            end
        end
    end
 
    safelyUnequipToy()
    local cured = successfulThrows >= 2
    debugPrint("Throw sequence finished: " .. successfulThrows .. "/3 → Play ailment " .. (cured and "CURED" or "NOT CURED"))
    return cured
end

-- Main play ailment handler
local function handlePlayAilment()
    debugPrint("PLAY AILMENT DETECTED! → Using squeaky_bone_default sequence")
    local toyID = getSqueakyBoneID()
    if not toyID then
        debugPrint("Play ailment FAILED: squeaky_bone_default not found")
        return false
    end
 
    local success, err = pcall(performThrowToySequence)
 
    if success and err then
        debugPrint("Play ailment CURED with squeaky_bone_default")
        return true
    else
        debugPrint("Play ailment FAILED: " .. tostring(err) .. " (no bone or interrupted)")
        safelyUnequipToy()
        return false
    end
end

-- ==================================================================
-- FURNITURE HANDLING (UPDATED with bb8 furniture)
-- ==================================================================

-- Extract furniture data
local function extractFurnitureData(model, folderId, part)
    return {
        folderId = folderId,
        partName = part.Name,
        position = part.Position,
        cframe = part.CFrame,
        model = model
    }
end

-- Find furniture by name (picks random from available)
local function findFurnitureByName(name)
    log("Searching for furniture: " .. name)
    local hi = Workspace:FindFirstChild("HouseInteriors")
    if not hi then
        log("HouseInteriors not found")
        return nil
    end
   
    local possibleFurniture = {}
   
    -- Search in HouseInteriors.furniture
    local furnitureFolder = hi:FindFirstChild("furniture")
    if furnitureFolder then
        for _, houseKey in ipairs(furnitureFolder:GetChildren()) do
            local model = houseKey:FindFirstChild(name)
            if model and model:IsA("Model") then
                local folderId = string.match(houseKey.Name, "f%-%d+") or "unknown"
                local activationParts = {"UseBlock", "Seat1", "Seat2"}
                local foundPart = nil
                for _, partName in ipairs(activationParts) do
                    local part = model:FindFirstChild(partName, true)
                    if part and part:IsA("BasePart") then
                        foundPart = part
                        log("Using " .. partName .. " in " .. model.Name .. " from houseKey " .. houseKey.Name)
                        break
                    end
                end
               
                if not foundPart then
                    for _, part in ipairs(model:GetDescendants()) do
                        if part:IsA("BasePart") then
                            foundPart = part
                            log("Using fallback part: " .. part.Name .. " in " .. model.Name .. " from houseKey " .. houseKey.Name)
                            break
                        end
                    end
                end
               
                if foundPart then
                    table.insert(possibleFurniture, extractFurnitureData(model, folderId, foundPart))
                end
            end
        end
    end
   
    -- Fallback: search entire workspace
    local model = Workspace:FindFirstChild(name, true)
    if model and model:IsA("Model") then
        local parentFolder = model.Parent
        local folderId = (parentFolder and string.match(parentFolder.Name, "f%-%d+")) or "unknown"
        local activationParts = {"UseBlock", "Seat1", "Seat2"}
        local foundPart = nil
        for _, partName in ipairs(activationParts) do
            local part = model:FindFirstChild(partName, true)
            if part and part:IsA("BasePart") then
                foundPart = part
                break
            end
        end
        if not foundPart then
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA("BasePart") then
                    foundPart = part
                    break
                end
            end
        end
        if foundPart then
            table.insert(possibleFurniture, extractFurnitureData(model, folderId, foundPart))
        end
    end
   
    if #possibleFurniture > 0 then
        local randomIndex = math.random(1, #possibleFurniture)
        local selected = possibleFurniture[randomIndex]
        log("Selected random furniture from " .. #possibleFurniture .. " options: folder " .. selected.folderId .. " part " .. selected.partName)
        return selected
    end
   
    log("Furniture not found: " .. name .. " (no instances available)")
    return nil
end

-- Activate furniture
local function activateFurniture(furnitureName, pet)
    local furnitureData = findFurnitureByName(furnitureName)
    if not furnitureData then
        debugPrint("Cannot activate furniture: " .. furnitureName .. " - not found")
        return false
    end

    local isInterior = (furnitureName == "CampingShower" or furnitureName == "SleepingBag")
    local apiPath = isInterior and "HousingAPI/ActivateInteriorFurniture" or "HousingAPI/ActivateFurniture"
    local args
    if isInterior then
        args = {
            furnitureData.folderId,
            furnitureData.partName,
            {
                cframe = furnitureData.cframe
            },
            pet
        }
    else
        args = {
            player,
            furnitureData.folderId,
            furnitureData.partName,
            {
                cframe = furnitureData.cframe
            },
            pet
        }
    end
   
    debugPrint("Activating " .. furnitureName .. " in folder " .. furnitureData.folderId .. " with part " .. furnitureData.partName .. " using " .. apiPath)
   
    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild(apiPath):InvokeServer(unpack(args))
    end)
   
    if success then
        debugPrint("Successfully activated: " .. furnitureName)
        return true
    else
        debugPrint("Failed to activate: " .. furnitureName .. " - " .. tostring(result))
        return false
    end
end

-- Use furniture with pet
local function useFurnitureWithPet(furnitureName)
    local char = ensureCharacterSpawned()
    if not char then
        debugPrint("Cannot use furniture: No valid character")
        return false
    end
    task.wait(2)
    local petObject = nil
    for attempt = 1, 5 do
        petObject = findPlayerPetInWorkspace()
        if petObject then
            break
        end
        debugPrint("Pet not found in workspace, attempt " .. attempt .. "/5")
        task.wait(2)
    end
    if petObject then
        debugPrint("Found pet for activation: " .. petObject.Name)
        local success = activateFurniture(furnitureName, petObject)
        if success then
            task.wait(20)
            return true
        else
            debugPrint("Failed to activate furniture with pet")
            return false
        end
    else
        debugPrint("No pet found in workspace for activation after multiple attempts")
        if petFarmPetID then
            debugPrint("Re-equipping pet...")
            local equipSuccess, equipResult = pcall(function()
                return ReplicatedStorage.API["ToolAPI/Equip"]:InvokeServer(petFarmPetID, {use_sound_delay = true, equip_as_last = false})
            end)
            if equipSuccess then
                task.wait(5)
                petObject = findPlayerPetInWorkspace()
                if petObject then
                    return useFurnitureWithPet(furnitureName)
                end
            end
        end
        return false
    end
end

-- ==================================================================
-- AILMENT HANDLERS (from w1.txt, updated with bb8 furniture)
-- ==================================================================

-- Handle walk ailment
local function handleWalkAilment()
    debugPrint("WALK AILMENT DETECTED! Starting walk sequence...")
    local currentPetID = petFarmPetID or PetID
    if not currentPetID then
        debugPrint("No pet ID available for walk sequence")
        return false
    end
    debugPrint("Storing current pet ID for re-equip: " .. tostring(currentPetID))
    local args = {
        player,
        true
    }
    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("HousingAPI/UnsubscribeFromHouse"):InvokeServer(unpack(args))
    end)
    if success then
        debugPrint("Successfully unsubscribed from house")
    else
        debugPrint("Failed to unsubscribe from house: " .. tostring(result))
        return false
    end
    debugPrint("Waiting 5 seconds for transition...")
    task.wait(5)
    debugPrint("Starting walking simulation...")
    for i = 1, 20 do
        if not PetFarmMode then
            debugPrint("PetFarm stopped during walk sequence, cancelling...")
            return false
        end
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, nil)
        debugPrint("Pressing W key...")
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, nil)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, nil)
        debugPrint("Pressing S key...")
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, nil)
        debugPrint("Walk cycle " .. i .. "/20 completed")
    end
    debugPrint("Walk sequence completed, respawning to return home...")
    local respawnSuccess, respawnResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("TeamAPI/Spawn"):InvokeServer()
    end)
    if respawnSuccess then
        debugPrint("Successfully respawned to return home")
        task.wait(5)
        debugPrint("Re-equipping pet after respawn...")
        local reequipSuccess = ensurePetEquipped(currentPetID, 10)
        if reequipSuccess then
            debugPrint("Successfully re-equipped pet after respawn")
            task.wait(2)
            return true
        else
            debugPrint("Failed to re-equip pet after respawn")
            return false
        end
    else
        debugPrint("Failed to respawn: " .. tostring(respawnResult))
        return false
    end
end

-- Find strollers in inventory
local function findStrollers()
    local strollers = {}
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.strollers then
            for strollerId, strollerData in pairs(playerData.inventory.strollers) do
                if strollerData.id then
                    table.insert(strollers, {
                        id = strollerId,
                        name = strollerData.id,
                        amount = strollerData.amount or 1
                    })
                end
            end
        end
    end)
    if not success then
        debugPrint("Error finding strollers: " .. tostring(errorMsg))
    end
    return strollers
end

-- Get first available stroller
local function getStrollerID()
    local strollers = findStrollers()
    if #strollers > 0 then
        debugPrint("Found stroller: " .. strollers[1].name .. " (ID: " .. strollers[1].id .. ")")
        return strollers[1].id
    end
    debugPrint("No strollers found in inventory")
    return nil
end

-- Handle ride ailment
local function handleRideAilment()
    debugPrint("RIDE AILMENT DETECTED! Starting ride sequence with stroller...")
    local currentPetID = petFarmPetID or PetID
    if not currentPetID then
        debugPrint("No pet ID available for ride sequence")
        return false
    end
    debugPrint("Storing current pet ID for re-equip: " .. tostring(currentPetID))
    local args = {
        player,
        true
    }
    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("HousingAPI/UnsubscribeFromHouse"):InvokeServer(unpack(args))
    end)
    if success then
        debugPrint("Successfully unsubscribed from house")
    else
        debugPrint("Failed to unsubscribe from house: " .. tostring(result))
        return false
    end
    debugPrint("Waiting 5 seconds for transition...")
    task.wait(5)
    local strollerID = getStrollerID()
    if not strollerID then
        debugPrint("No strollers found in inventory!")
        return false
    end
    debugPrint("Equipping stroller: " .. strollerID)
    currentStrollerID = strollerID
    local equipArgs = {
        strollerID,
        {
            use_sound_delay = true,
            equip_as_last = true
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        debugPrint("Failed to equip stroller: " .. tostring(equipResult))
        currentStrollerID = nil
        return false
    end
    debugPrint("Successfully equipped stroller, starting walking simulation...")
    task.wait(3)
    debugPrint("Starting walking simulation with stroller...")
    for i = 1, 20 do
        if not PetFarmMode then
            debugPrint("PetFarm stopped during ride sequence, cancelling...")
            safelyUnequipStroller()
            return false
        end
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, nil)
        debugPrint("Pressing W key...")
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, nil)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, nil)
        debugPrint("Pressing S key...")
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, nil)
        debugPrint("Ride cycle " .. i .. "/20 completed")
    end
    debugPrint("Ride sequence completed, unequipping stroller and respawning to return home...")
    safelyUnequipStroller()
    local respawnSuccess, respawnResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("TeamAPI/Spawn"):InvokeServer()
    end)
    if respawnSuccess then
        debugPrint("Successfully respawned to return home")
        task.wait(5)
        debugPrint("Re-equipping pet after respawn...")
        local reequipSuccess = ensurePetEquipped(currentPetID, 10)
        if reequipSuccess then
            debugPrint("Successfully re-equipped pet after respawn")
            task.wait(2)
            return true
        else
            debugPrint("Failed to re-equip pet after respawn")
            return false
        end
    else
        debugPrint("Failed to respawn: " .. tostring(respawnResult))
        return false
    end
end

-- Buy healing apple
local function buyHealingApple()
    debugPrint("Buying healing apple from shop...")
    local args = {
        "food",
        "healing_apple",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        debugPrint("Successfully purchased healing apple")
        return true
    else
        debugPrint("Failed to buy healing apple: " .. tostring(result))
        return false
    end
end

-- Find healing apple in inventory
local function findHealingApple()
    debugPrint("Scanning inventory for healing apple...")
    local healingAppleID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "healing_apple" then
                    healingAppleID = foodId
                    debugPrint("Found healing apple with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        debugPrint("Error scanning inventory for healing apple: " .. tostring(errorMsg))
    end
    return healingAppleID
end

-- Use healing apple on pet
local function useHealingApple(foodID, petUniqueID)
    if not foodID or not petUniqueID then
        debugPrint("Cannot use healing apple: Missing foodID or petUniqueID")
        return false
    end
    debugPrint("Using healing apple " .. foodID .. " on pet " .. petUniqueID)
    local equipArgs = {
        foodID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        debugPrint("Failed to equip healing apple: " .. tostring(equipResult))
        return false
    end
    currentFoodID = foodID
    debugPrint("Successfully equipped healing apple")
    task.wait(2)
    local startArgs = {
        foodID,
        "START"
    }
    local startSuccess, startResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    if not startSuccess then
        debugPrint("Failed to start using healing apple: " .. tostring(startResult))
        safelyUnequipFood(foodID)
        currentFoodID = nil
        return false
    end
    debugPrint("Started using healing apple, waiting 1 second...")
    task.wait(1)
    local petObjectArgs = {
        "__Enum_PetObjectCreatorType_2",
        {
            additional_consume_uniques = {},
            pet_unique = petUniqueID,
            unique_id = foodID
        }
    }
    local petObjectSuccess, petObjectResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("PetObjectAPI/CreatePetObject"):InvokeServer(unpack(petObjectArgs))
    end)
    if not petObjectSuccess then
        debugPrint("Failed to create pet object for healing: " .. tostring(petObjectResult))
        safelyUnequipFood(foodID)
        currentFoodID = nil
        return false
    end
    debugPrint("Healing apple consumed, waiting 9 seconds for effect...")
    task.wait(9)
    safelyUnequipFood(foodID)
    currentFoodID = nil
    debugPrint("Successfully used healing apple on pet")
    return true
end

-- Handle sick ailment
local function handleSickAilment()
    debugPrint("SICK AILMENT DETECTED! Starting healing process...")
    local currentPetID = petFarmPetID or PetID
    if not currentPetID then
        debugPrint("No pet ID available for healing")
        return false
    end
    local healingAppleID = findHealingApple()
    if not healingAppleID then
        debugPrint("No healing apple found in inventory, purchasing one...")
        local purchaseSuccess = buyHealingApple()
        if not purchaseSuccess then
            debugPrint("Failed to purchase healing apple")
            return false
        end
        task.wait(2)
        healingAppleID = findHealingApple()
        if not healingAppleID then
            debugPrint("Failed to find healing apple after purchase")
            return false
        end
    end
    local useSuccess = useHealingApple(healingAppleID, currentPetID)
    if useSuccess then
        debugPrint("Successfully handled sick ailment with healing apple")
        return true
    else
        debugPrint("Failed to use healing apple on pet")
        return false
    end
end

-- Detect mystery ailment
local function detectMysteryAilment()
    local data = require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    for ailmentId, ailmentData in pairs(data.ailments_manager.ailments) do
        if ailmentData.mystery then
            debugPrint("MYSTERY AILMENT DETECTED! Ailment ID: " .. ailmentId)
            return ailmentId
        end
    end
    return nil
end

-- Resolve mystery ailment
local function resolveMysteryAilment(ailmentId)
    -- Prioritized list of tasks
    local tasks = {"bored", "sick", "pet me", "sleepy", "dirty", "toilet", "hungry", "thirsty", "walk", "ride"}
    -- Try all tasks for all 3 levels
    for _, chosenAilment in ipairs(tasks) do
        debugPrint("Attempting to resolve mystery ailment as: " .. chosenAilment)
        local allLevelsSuccess = true
        for level = 1, 3 do
            local args = {
                ailmentId,
                "mystery",
                level,
                chosenAilment
            }
            local success, result = pcall(function()
                return ReplicatedStorage:WaitForChild("API"):WaitForChild("AilmentsAPI/ChooseMysteryAilment"):FireServer(unpack(args))
            end)
            if success then
                debugPrint("Successfully resolved mystery ailment level " .. level .. " as " .. chosenAilment)
            else
                debugPrint("Failed to resolve mystery ailment level " .. level .. " as " .. chosenAilment .. ": " .. tostring(result))
                allLevelsSuccess = false
            end
            task.wait(1) -- Wait between levels
        end
        if allLevelsSuccess then
            debugPrint("Successfully resolved all levels of mystery ailment as " .. chosenAilment)
        else
            debugPrint("Failed to resolve all levels of mystery ailment as " .. chosenAilment)
        end
    end
    debugPrint("Finished attempting all tasks for mystery ailment")
    return true
end

-- Focus on pet
local function focusPet(petModel)
    if not petModel then
        debugPrint("No pet model provided")
        return false
    end
    debugPrint("Focusing pet: " .. petModel.Name)
    local args1 = { petModel }
    local success1, err1 = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("AdoptAPI/FocusPet"):FireServer(unpack(args1))
    end)
    if success1 then
        debugPrint("Successfully focused pet using AdoptAPI/FocusPet")
        task.wait(0.5)
        local args2 = {
            petModel,
            {
                FocusPet = true
            }
        }
        local success2, err2 = pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("PetAPI/ReplicateActivePerformances"):FireServer(unpack(args2))
        end)
        if success2 then
            debugPrint("Successfully set performance with focus")
        else
            debugPrint("Failed to set performance: " .. tostring(err2))
        end
        return true
    else
        debugPrint("Failed to focus pet: " .. tostring(err1))
        return false
    end
end

-- Unfocus pet
local function unfocusPet(petModel)
    if not petModel then
        debugPrint("No pet model provided for unfocus")
        return false
    end
    debugPrint("Unfocusing pet: " .. petModel.Name)
    local args = { petModel }
    local success, err = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("AdoptAPI/UnfocusPet"):FireServer(unpack(args))
    end)
    if success then
        debugPrint("Successfully unfocused pet")
        return true
    else
        debugPrint("Failed to unfocus pet: " .. tostring(err))
        return false
    end
end

-- Set pet in sitting state
local function setPetSitting(petModel)
    if not petModel then
        debugPrint("No pet model provided")
        return false
    end
    debugPrint("Setting pet to sit state: " .. petModel.Name)
    local sitAnimation = "DogSit"
    if string.find(petModel.Name:lower(), "cat") then
        sitAnimation = "CatSit"
    end
    local args = {
        petModel,
        {
            local_anim_name = sitAnimation,
            local_anim_speed = 1,
            dont_allow_sit_states = true,
            dont_allow_remote_interaction = true,
            anim_fade_time = 0.2
        }
    }
    local success, err = pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("PetAPI/ReplicatePerformanceModifiers"):FireServer(unpack(args))
    end)
    if success then
        debugPrint("Successfully set pet to sit state")
        return true
    else
        debugPrint("Failed to set sit state: " .. tostring(err))
        return false
    end
end

-- Progress "Pet Me" ailment
local function progressPetMeAilment(petUniqueID, petModel)
    if not petUniqueID or not petModel then
        debugPrint("Missing pet ID or model")
        return false
    end
    debugPrint("Attempting to progress 'Pet Me' ailment...")
    if not focusPet(petModel) then
        debugPrint("Failed to focus pet for ailment progression")
        return false
    end
    task.wait(0.5)
    if not setPetSitting(petModel) then
        debugPrint("Failed to set pet to sitting state")
        return false
    end
    task.wait(1)
    local possibleEndpoints = {
        "AilmentsAPI/ProgressPetMeAilment",
        "PetAPI/ProgressPetMeAilment",
        "AdoptAPI/ProgressPetMeAilment",
        "PetAPI/ReplicateActivePerformances",
        "PetAPI/ReplicatePerformanceModifiers"
    }
    for _, endpoint in pairs(possibleEndpoints) do
        local remoteEvent = ReplicatedStorage.API:FindFirstChild(endpoint)
        if remoteEvent then
            debugPrint("Trying endpoint: " .. endpoint)
            local args = { petUniqueID }
            local success, err = pcall(function()
                remoteEvent:FireServer(unpack(args))
            end)
            if success then
                debugPrint("Successfully called: " .. endpoint)
                return true
            else
                debugPrint("Failed to call " .. endpoint .. ": " .. tostring(err))
            end
        end
    end
    for _, endpoint in pairs(possibleEndpoints) do
        local remoteEvent = ReplicatedStorage.API:FindFirstChild(endpoint)
        if remoteEvent then
            debugPrint("Trying endpoint with model: " .. endpoint)
            local args = { petModel }
            local success, err = pcall(function()
                remoteEvent:FireServer(unpack(args))
            end)
            if success then
                debugPrint("Successfully called: " .. endpoint)
                return true
            else
                debugPrint("Failed to call " .. endpoint .. ": " .. tostring(err))
            end
        end
    end
    debugPrint("Could not find working endpoint for ailment progression")
    return false
end

-- Main function to handle 'Pet Me' ailment
local function handlePetMeAilment(petUniqueID)
    debugPrint("=== STARTING PET ME AILMENT HANDLING ===")
    local petModel = findPetModel(petUniqueID)
    if not petModel then
        debugPrint("FAILED: Could not find pet model")
        return false
    end
    debugPrint("Using pet: " .. petModel.Name)
    local success = progressPetMeAilment(petUniqueID, petModel)
    if success then
        debugPrint("SUCCESS: Ailment progression attempted")
        task.wait(2)
        debugPrint("Check if the 'Pet Me' ailment progressed in the game")
    else
        debugPrint("FAILED: Could not progress ailment")
    end
    debugPrint("Unfocusing pet...")
    if not unfocusPet(petModel) then
        local args = { Workspace:WaitForChild("Pets"):WaitForChild(petModel.Name) }
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("AdoptAPI/UnfocusPet"):FireServer(unpack(args))
        end)
        if success then
            debugPrint("Successfully unfocused pet using alternative method")
        else
            debugPrint("Failed to unfocus pet using alternative method: " .. tostring(err))
        end
    end
    debugPrint("=== PET ME AILMENT HANDLING COMPLETED ===")
    return success
end

-- ==================================================================
-- MAIN PETFARM MONITORING FUNCTION
-- ==================================================================

-- Monitor and handle ailments
local function monitorAndHandleAilments()
    debugPrint("Starting ailment-only monitoring system with ALWAYS KEEP EQUIPPED...")
    local lastAilmentScanTime = 0
    local SCAN_INTERVAL = 10 -- seconds between scans
    local lastEquipCheckTime = 0
    local EQUIP_CHECK_INTERVAL = 5 -- More frequent checks (every 5s) for always-equipped
    local lastPetCheckTime = 0
    local PET_CHECK_INTERVAL = 10 -- seconds between pet checks
    while PetFarmMode do
        local currentTime = os.time()
        -- ALWAYS KEEP EQUIPPED: Check equip_manager every EQUIP_CHECK_INTERVAL seconds
        if currentTime - lastEquipCheckTime >= EQUIP_CHECK_INTERVAL then
            local currentPetID = petFarmPetID or PetID
            if currentPetID then
                if not isPetEquipped(currentPetID) then
                    debugPrint("Pet not equipped in equip_manager, re-equipping immediately...")
                    local success = ensurePetEquipped(currentPetID, 8) -- Shorter timeout for quick recovery
                    if not success then
                        debugPrint("Critical: Failed to re-equip pet via equip_manager, stopping PetFarm")
                        PetFarmMode = false
                        break
                    end
                else
                    debugPrint("Pet confirmed equipped in equip_manager")
                    -- Optional: Double-check workspace for full presence
                    if not findPlayerPetInWorkspace() then
                        debugPrint("Pet equipped but not in workspace, quick re-equip...")
                        ensurePetEquipped(currentPetID, 5)
                    end
                end
            else
                debugPrint("No pet ID available for equip check, stopping PetFarm")
                PetFarmMode = false
                break
            end
            lastEquipCheckTime = currentTime
        end
        -- Legacy pet check (every 10s, now secondary)
        if currentTime - lastPetCheckTime >= PET_CHECK_INTERVAL then
            local currentPetID = petFarmPetID or PetID
            if currentPetID then
                if not findPlayerPetInWorkspace() then
                    debugPrint("Pet not in workspace (legacy check), re-equipping...")
                    local success = ensurePetEquipped(currentPetID, 10)
                    if not success then
                        debugPrint("Failed to re-equip pet (legacy), but equip_manager says OK - continuing")
                    end
                end
            end
            lastPetCheckTime = currentTime
        end
        local success, data = pcall(function()
            return require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
        end)
        if success and data and data.ailments_manager and data.ailments_manager.ailments then
            local foundActionableAilments = false
            local currentPetID = petFarmPetID or PetID
            -- Get the unique ID of the selected pet
            local selectedPetUniqueID = nil
            if currentPetID then
                local playerData = require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
                if playerData and playerData.inventory and playerData.inventory.pets and playerData.inventory.pets[currentPetID] then
                    selectedPetUniqueID = playerData.inventory.pets[currentPetID].unique
                end
            end
            if not selectedPetUniqueID then
                debugPrint("No selected pet or pet not found in inventory")
                task.wait(SCAN_INTERVAL)
                continue
            end
            -- Only handle ailments for the selected pet
            for ailmentId, ailmentData in pairs(data.ailments_manager.ailments) do
                if ailmentId == selectedPetUniqueID then
                    foundActionableAilments = true
                    for ailmentType, furnitureName in pairs(AILMENT_TASKS) do
                        if ailmentData[ailmentType] and type(ailmentData[ailmentType]) == "table" then
                            -- Check cooldown
                            if not lastTaskTime[ailmentType] or (currentTime - lastTaskTime[ailmentType]) >= TASK_COOLDOWN then
                                -- Before handling any ailment, ensure pet is equipped
                                if not isPetEquipped(selectedPetUniqueID) then
                                    debugPrint("Ailment detected but pet not equipped - re-equipping before handling...")
                                    ensurePetEquipped(selectedPetUniqueID, 10)
                                end
                                if ailmentType == "play" then
                                    debugPrint("PLAY AILMENT DETECTED! Using squeaky_bone_default")
                                    local success = handlePlayAilment()
                                    if success then lastTaskTime[ailmentType] = currentTime end
                                elseif ailmentType == "walk" then
                                    debugPrint("WALK AILMENT DETECTED! Starting walk sequence")
                                    local success = handleWalkAilment()
                                    if success then lastTaskTime[ailmentType] = currentTime end
                                elseif ailmentType == "ride" then
                                    debugPrint("RIDE AILMENT DETECTED! Starting ride sequence")
                                    local success = handleRideAilment()
                                    if success then lastTaskTime[ailmentType] = currentTime end
                                elseif ailmentType == "sick" then
                                    debugPrint("SICK AILMENT DETECTED! Using healing apple")
                                    local success = handleSickAilment()
                                    if success then lastTaskTime[ailmentType] = currentTime end
                                elseif ailmentType == "mystery" then
                                    debugPrint("MYSTERY AILMENT DETECTED! Starting resolution...")
                                    local success = resolveMysteryAilment(ailmentId)
                                    if success then lastTaskTime[ailmentType] = currentTime end
                                elseif ailmentType == "pet_me" then
                                    debugPrint("PET ME AILMENT DETECTED! Handling...")
                                    local success = handlePetMeAilment(currentPetID)
                                    if success then lastTaskTime[ailmentType] = currentTime end
                                elseif ailmentType == "bored" then
                                    debugPrint("BORED AILMENT DETECTED! Using custom teleport handler")
                                    -- Use the existing bored handler from bb8
                                    local success = handleBoredAilment()
                                    if success then lastTaskTime[ailmentType] = currentTime end
                                else
                                    debugPrint(string.upper(ailmentType) .. " AILMENT DETECTED! Using " .. furnitureName)
                                    local success = useFurnitureWithPet(furnitureName)
                                    if success then lastTaskTime[ailmentType] = currentTime end
                                end
                                break -- Handle one ailment at a time
                            else
                                debugPrint(ailmentType .. " task on cooldown (" .. (TASK_COOLDOWN - (currentTime - lastTaskTime[ailmentType])) .. "s remaining)")
                            end
                        end
                    end
                    if foundActionableAilments then break end
                end
            end
            -- Only show "no ailments" message once every minute
            if not foundActionableAilments and currentTime - lastAilmentScanTime >= 60 then
                debugPrint("No actionable ailments detected for selected pet")
                lastAilmentScanTime = currentTime
            end
        else
            if currentTime - lastAilmentScanTime >= 60 then
                debugPrint("Error reading ailments data or no ailments found")
                lastAilmentScanTime = currentTime
            end
        end
        task.wait(SCAN_INTERVAL)
    end
end

-- Start ailment-only PetFarm
local function startAilmentOnlyPetFarm()
    debugPrint("Starting AILMENT-ONLY PetFarm system with ALWAYS KEEP EQUIPPED...")
    debugPrint("Features: Ailment Monitoring + Throw Toys for Play Ailment + Walk Handler + Ride Handler + Sick Handler + Mystery Handler + Auto Pet Re-equip (via equip_manager)")
    -- Ensure pet is equipped and present
    local currentCyclePetID = PetID or lastValidPetID or petFarmPetID
    if not currentCyclePetID then
        debugPrint("No pet selected for PetFarm")
        PetFarmMode = false
        return
    end
    local char = ensureCharacterSpawned()
    if not char then
        debugPrint("Cannot start PetFarm: No valid character")
        PetFarmMode = false
        return
    end
    -- Ensure pet is equipped with verification (using new equip_manager check)
    debugPrint("Ensuring pet is equipped and present (via equip_manager)...")
    local ensured = ensurePetEquipped(currentCyclePetID, 18)
    if not ensured then
        debugPrint("Failed to ensure pet is equipped/present")
        PetFarmMode = false
        return
    end
    petFarmPetID = currentCyclePetID
    lastValidPetID = currentCyclePetID
    -- Check and buy missing furniture once at start
    checkAndBuyMissingFurniture()
    task.wait(3)
    -- Lock door for safety
    local args = {true}
    pcall(function()
        ReplicatedStorage:WaitForChild("API"):WaitForChild("HousingAPI/SetDoorLocked"):InvokeServer(unpack(args))
    end)
    debugPrint("Door locked, starting ailment monitoring with always-equipped...")
    -- Start the ailment monitoring loop
    monitorAndHandleAilments()
    -- Cleanup when stopped
    safelyUnequipToy()
    safelyUnequipStroller()
    safelyUnequipFood(currentFoodID)
    if petFarmPetID then
        pcall(function()
            ReplicatedStorage.API["ToolAPI/Unequip"]:InvokeServer(petFarmPetID)
        end)
        petFarmPetID = nil
    end
    debugPrint("Ailment-only PetFarm stopped")
end

-- Toggle PetFarm mode
local function togglePetFarmMode()
    if PetFarmMode and petFarmCoroutine then
        debugPrint("PetFarm is already running, stopping first...")
        PetFarmMode = false
        task.wait(2)
    end
    PetFarmMode = not PetFarmMode
    if PetFarmMode then
        if not PetID and lastValidPetID then
            PetID = lastValidPetID
            debugPrint("Restored PetID from lastValidPetID: " .. tostring(PetID))
        end
        if not PetID then
            debugPrint("Please select a pet first!")
            PetFarmMode = false
            return
        end
        debugPrint("AILMENT-ONLY PetFarm: ENABLED with selected pet (ALWAYS KEEP EQUIPPED)")
        lastValidPetID = PetID
        if not isPlayerAtHome() then
            debugPrint("Player not at home when enabling PetFarm. Waiting 2 seconds and performing a single respawn.")
            task.wait(2)
            pcall(function()
                ReplicatedStorage:WaitForChild("API"):WaitForChild("TeamAPI/Spawn"):InvokeServer()
            end)
            task.wait(5)
        else
            debugPrint("Player is at home, no respawn required.")
        end
        local ensured = ensurePetEquipped(PetID, 18)
        if not ensured then
            debugPrint("Could not ensure selected pet is equipped/present. Starting PetFarm anyway may fail. Aborting start to be safe.")
            PetFarmMode = false
            return
        end
        petFarmCoroutine = coroutine.wrap(startAilmentOnlyPetFarm)()
    else
        debugPrint("AILMENT-ONLY PetFarm: DISABLED")
        petFarmCoroutine = nil
        safelyUnequipToy()
        safelyUnequipStroller()
        safelyUnequipFood(currentFoodID)
        if petFarmPetID then
            pcall(function()
                ReplicatedStorage.API["ToolAPI/Unequip"]:InvokeServer(petFarmPetID)
            end)
            petFarmPetID = nil
        end
    end
end

-----------------------------------------------------
-- BABY AILMENT HANDLING (Integrated from bb3.txt)
-----------------------------------------------------
-- Ailment to Furniture Mapping (merged from ailDetec and bb3, prioritizing bb3 handling)
local BABY_AILMENT_TASKS = {
    sleepy = "SleepingBag",  -- Updated from BasicBed to match bb3
    hungry = "teachers_apple",
    thirsty = "water",
    dirty = "CampingShower",  -- Updated from CheapPetBathtub to match bb3
    bored = "teleport_to_bored",  -- Updated: Custom handling for bored (teleport)
    sick = "healing_apple",
    beach_party = "teleport_to_character",  -- New: Custom handling for beach_party (teleport)
    school = "teleport_to_school",  -- New: Custom handling for school (teleport)
    salon = "teleport_to_salon",  -- New: Custom handling for salon (teleport)
    pizza_party = "teleport_to_pizza"  -- New: Custom handling for pizza_party (teleport)
}

-- Task cooldowns to prevent spam
local lastTaskTime = {}
local TASK_COOLDOWN = 30 -- seconds

-- Pre-cache API references for efficiency
local API = ReplicatedStorage:WaitForChild("API")
local ExitSeatStates = API:WaitForChild("AdoptAPI/ExitSeatStates")

-- Character position for beach_party
local BEACH_PARTY_CHARACTER_POS = Vector3.new(-604.54, 26.49, -1538.53)
local BEACH_PARTY_CAMERA_POS = Vector3.new(-598.88, 33.84, -1546.60)

-- Character position for bored
local BORED_CHARACTER_POS = Vector3.new(-489.941, 29.448, -1799.160)
local BORED_CAMERA_POS = Vector3.new(-499.916, 34.281, -1804.232)

-- Character position for school
local SCHOOL_CHARACTER_POS = Vector3.new(-309.794, 29.798, -1505.317)
local SCHOOL_CAMERA_POS = Vector3.new(-300.865, 36.256, -1499.952)

-- Character position for salon
local SALON_CHARACTER_POS = Vector3.new(-131.81, 29.34, -1765.13)
local SALON_CAMERA_POS = Vector3.new(-130.97, 36.81, -1755.39)

-- Character position for pizza_party
local PIZZA_PARTY_CHARACTER_POS = Vector3.new(-121.97, 29.34, -1663.56)
local PIZZA_PARTY_CAMERA_POS = Vector3.new(-132.73, 35.09, -1662.70)

-- Function to safely get player data
local function getPlayerData()
    local clientModules = ReplicatedStorage:WaitForChild("ClientModules", 10)
    if not clientModules then return nil end
    local coreModule = clientModules:WaitForChild("Core", 5)
    if not coreModule then return nil end
    local clientDataModule = coreModule:WaitForChild("ClientData", 5)
    if not clientDataModule then return nil end
   
    local clientData
    local success, err = pcall(function()
        clientData = require(clientDataModule)
    end)
    if not success or not clientData then return nil end
   
    local playerData
    success, err = pcall(function()
        playerData = clientData.get_data()[player.Name]
    end)
    if not success or not playerData then return nil end
   
    return playerData
end

-- Enhanced helper to extract ailment key
local function extractAilmentKey(ailment)
    if type(ailment) == "table" then
        local candidates = {"type", "name", "ailment", "id", "key", "kind"}
        for _, field in ipairs(candidates) do
            local val = ailment[field]
            if type(val) == "string" then
                local lowerVal = val:lower()
                if BABY_AILMENT_TASKS[lowerVal] then
                    log("Extracted ailment '" .. lowerVal .. "' from field '" .. field .. "'")
                    return lowerVal
                end
            end
        end
        for k, v in pairs(ailment) do
            if type(v) == "string" then
                local lowerV = v:lower()
                if BABY_AILMENT_TASKS[lowerV] then
                    log("Found matching ailment string '" .. lowerV .. "' in table key '" .. tostring(k) .. "'")
                    return lowerV
                end
            elseif type(v) == "table" then
                local subKey = extractAilmentKey(v)
                if subKey ~= "unknown" then
                    return subKey
                end
            end
        end
        log("Unknown ailment table structure")
        return "unknown"
    else
        local str = tostring(ailment):lower()
        if BABY_AILMENT_TASKS[str] then
            return str
        end
        return str
    end
end

-- Function to print available baby ailments in compact form
local function printAvailableBabyAilmentsCompact()
    log("🔍 BABY AILMENTS (COMPACT)")
    log("=========================")
    local playerData = getPlayerData()
    if not playerData or not playerData.ailments_manager or not playerData.ailments_manager.baby_ailments then
        log("No baby ailments found.")
        return
    end
   
    local babyAilments = playerData.ailments_manager.baby_ailments
    local count = 0
    local actionableCount = 0
   
    log(string.format("%-5s %-36s %-15s %-10s", "No.", "Pet Unique ID", "Ailment", "Actionable"))
    log(string.rep("-", 70))
   
    for petUniqueID, ailment in pairs(babyAilments) do
        local ailmentKey = extractAilmentKey(ailment)
        local isActionable = BABY_AILMENT_TASKS[ailmentKey] and ailmentKey ~= "unknown"
        if isActionable then actionableCount = actionableCount + 1 end
        count = count + 1
        local status = isActionable and "YES" or "NO"
        log(string.format("%-5d %-36s %-15s %-10s", count, petUniqueID:sub(1, 36), ailmentKey, status))
    end
   
    log(string.rep("-", 70))
    log(string.format("Total baby ailments: %d (Actionable: %d)", count, actionableCount))
end

-- Call ExitSeatStates once after furniture use
local function callExitSeatStatesOnce()
    log("Calling ExitSeatStates once after furniture use...")
    local Char = player.Character or player.CharacterAdded:Wait()
    if Char then
        pcall(function()
            ExitSeatStates:FireServer(Char)
        end)
        log("Successfully called ExitSeatStates once")
    else
        log("Failed to get character for ExitSeatStates")
    end
end

-- Handle furniture activation
local function handleFurnitureActivation(furnitureName)
    log("Activating furniture detected: " .. furnitureName)
    local furnitureData = findFurnitureByName(furnitureName)
    if not furnitureData then
        log("Cannot activate furniture: " .. furnitureName .. " - not found")
        return false
    end
   
    local char = player.Character
    if not char then
        log("Cannot activate furniture: No character found")
        return false
    end

    local isInterior = (furnitureName == "CampingShower" or furnitureName == "SleepingBag")
    local apiPath = isInterior and "HousingAPI/ActivateInteriorFurniture" or "HousingAPI/ActivateFurniture"
    local args
    if isInterior then
        args = {
            furnitureData.folderId,
            furnitureData.partName,
            {
                cframe = furnitureData.cframe
            },
            char
        }
    else
        args = {
            player,
            furnitureData.folderId,
            furnitureData.partName,
            {
                cframe = furnitureData.cframe
            },
            char
        }
    end
   
    log("Activating " .. furnitureName .. " in folder " .. furnitureData.folderId .. " with part " .. furnitureData.partName .. " using " .. apiPath)
   
    local success, result = pcall(function()
        return API:WaitForChild(apiPath):InvokeServer(unpack(args))
    end)
   
    if success then
        log("Successfully activated: " .. furnitureName)
        task.wait(20) -- Wait for ailment cure
        callExitSeatStatesOnce() -- Call only once after wait
        return true
    else
        log("Failed to activate: " .. furnitureName .. " - " .. tostring(result))
        return false
    end
end

-- Use furniture with localPlayer
local function useFurnitureWithLocalPlayer(furnitureName)
    log("Using furniture for baby: " .. furnitureName .. " on localPlayer")
    return handleFurnitureActivation(furnitureName)
end

-- Handle beach_party ailment: Teleport to character position
local function handleBeachPartyAilment()
    log("BEACH_PARTY AILMENT DETECTED FOR BABY! Teleporting to character position...")
    if safeTp(BEACH_PARTY_CHARACTER_POS) then
        setCam(BEACH_PARTY_CAMERA_POS, BEACH_PARTY_CHARACTER_POS)
        task.wait(3)
        resetCam()
        log("Successfully teleported to beach_party position: " .. tostring(BEACH_PARTY_CHARACTER_POS))
        return true
    else
        log("Failed to teleport for beach_party ailment")
        return false
    end
end

-- Handle bored ailment: Teleport to bored position
local function handleBoredAilment()
    log("BORED AILMENT DETECTED FOR BABY! Teleporting to bored position...")
    if safeTp(BORED_CHARACTER_POS) then
        setCam(BORED_CAMERA_POS, BORED_CHARACTER_POS)
        task.wait(3)
        resetCam()
        log("Successfully teleported to bored position: " .. tostring(BORED_CHARACTER_POS))
        return true
    else
        log("Failed to teleport for bored ailment")
        return false
    end
end

-- Handle school ailment: Teleport to school character position
local function handleSchoolAilment()
    log("SCHOOL AILMENT DETECTED FOR BABY! Teleporting to school character position...")
    if safeTp(SCHOOL_CHARACTER_POS) then
        setCam(SCHOOL_CAMERA_POS, SCHOOL_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to school position: " .. tostring(SCHOOL_CHARACTER_POS) .. " and pressed W")
        return true
    else
        log("Failed to teleport for school ailment")
        return false
    end
end

-- Handle salon ailment: Teleport to salon character position
local function handleSalonAilment()
    log("SALON AILMENT DETECTED FOR BABY! Teleporting to salon character position...")
    if safeTp(SALON_CHARACTER_POS) then
        setCam(SALON_CAMERA_POS, SALON_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to salon position: " .. tostring(SALON_CHARACTER_POS) .. " and pressed W")
        return true
    else
        log("Failed to teleport for salon ailment")
        return false
    end
end

-- Handle pizza_party ailment: Teleport to pizza_party character position
local function handlePizzaPartyAilment()
    log("PIZZA_PARTY AILMENT DETECTED FOR BABY! Teleporting to pizza_party character position...")
    if safeTp(PIZZA_PARTY_CHARACTER_POS) then
        setCam(PIZZA_PARTY_CAMERA_POS, PIZZA_PARTY_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to pizza_party position: " .. tostring(PIZZA_PARTY_CHARACTER_POS) .. " and pressed W")
        return true
    else
        log("Failed to teleport for pizza_party ailment")
        return false
    end
end

-- Buy teachers_apple
local function buyTeachersApple()
    log("Buying teachers_apple from shop...")
    local args = {
        "food",
        "teachers_apple",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased teachers_apple")
        return true
    else
        log("Failed to buy teachers_apple: " .. tostring(result))
        return false
    end
end

-- Find teachers_apple in inventory
local function findTeachersApple()
    log("Scanning inventory for teachers_apple...")
    local teachersAppleID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "teachers_apple" then
                    teachersAppleID = foodId
                    log("Found teachers_apple with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for teachers_apple: " .. tostring(errorMsg))
    end
    return teachersAppleID
end

-- Use teachers_apple on localPlayer
local function useTeachersApple(foodID)
    if not foodID then
        log("Cannot use teachers_apple: Missing foodID")
        return false
    end
    log("Using teachers_apple " .. foodID .. " on localPlayer for baby ailment")
  
    local equipArgs = {
        foodID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip teachers_apple: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped teachers_apple")
    task.wait(2)
  
    local startArgs = {
        foodID,
        "START"
    }
    local endArgs = {
        foodID,
        "END"
    }
  
    -- START
    local startSuccess, startResult = pcall(function()
        return API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    if not startSuccess then
        log("Failed to start using teachers_apple: " .. tostring(startResult))
        pcall(function()
            API:WaitForChild("ToolAPI/Unequip"):InvokeServer(foodID)
        end)
        return false
    end
    task.wait(2)
  
    -- END (first)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- START END (second)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- START (third)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
  
    -- Unequip food
    local unequipArgs = { foodID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used teachers_apple on localPlayer")
    return true
end

-- Handle hungry ailment for baby
local function handleHungryAilment()
    log("HUNGRY AILMENT DETECTED FOR BABY! Starting feeding process on localPlayer...")
    local teachersAppleID = findTeachersApple()
    if not teachersAppleID then
        log("No teachers_apple found in inventory, purchasing one...")
        local purchaseSuccess = buyTeachersApple()
        if not purchaseSuccess then
            log("Failed to purchase teachers_apple")
            return false
        end
        task.wait(2)
        teachersAppleID = findTeachersApple()
        if not teachersAppleID then
            log("Failed to find teachers_apple after purchase")
            return false
        end
    end
    local useSuccess = useTeachersApple(teachersAppleID)
    if useSuccess then
        log("Successfully handled hungry ailment with teachers_apple on localPlayer")
        return true
    else
        log("Failed to use teachers_apple on localPlayer")
        return false
    end
end

-- Buy water
local function buyWater()
    log("Buying water from shop...")
    local args = {
        "food",
        "water",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased water")
        return true
    else
        log("Failed to buy water: " .. tostring(result))
        return false
    end
end

-- Find water in inventory
local function findWater()
    log("Scanning inventory for water...")
    local waterID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "water" then
                    waterID = foodId
                    log("Found water with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for water: " .. tostring(errorMsg))
    end
    return waterID
end

-- Use water on localPlayer
local function useWater(foodID)
    if not foodID then
        log("Cannot use water: Missing foodID")
        return false
    end
    log("Using water " .. foodID .. " on localPlayer for baby ailment")
  
    local equipArgs = {
        foodID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip water: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped water")
    task.wait(3)
  
    local startArgs = {
        foodID,
        "START"
    }
    local endArgs = {
        foodID,
        "END"
    }
  
    -- Perform multiple START/END cycles (9 full cycles as in bb3)
    for i = 1, 9 do
        pcall(function()
            API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
        end)
        task.wait(2)
        pcall(function()
            API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
        end)
        task.wait(2)
    end
  
    -- Unequip food
    local unequipArgs = { foodID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used water on localPlayer")
    return true
end

-- Handle thirsty ailment for baby
local function handleThirstyAilment()
    log("THIRSTY AILMENT DETECTED FOR BABY! Starting watering process on localPlayer...")
    local waterID = findWater()
    if not waterID then
        log("No water found in inventory, purchasing one...")
        local purchaseSuccess = buyWater()
        if not purchaseSuccess then
            log("Failed to purchase water")
            return false
        end
        task.wait(3)
        waterID = findWater()
        if not waterID then
            log("Failed to find water after purchase")
            return false
        end
    end
    local useSuccess = useWater(waterID)
    if useSuccess then
        log("Successfully handled thirsty ailment with water on localPlayer")
        return true
    else
        log("Failed to use water on localPlayer")
        return false
    end
end

-- Buy healing_apple
local function buyHealingApple()
    log("Buying healing_apple from shop...")
    local args = {
        "food",
        "healing_apple",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased healing_apple")
        return true
    else
        log("Failed to buy healing_apple: " .. tostring(result))
        return false
    end
end

-- Find healing_apple in inventory
local function findHealingApple()
    log("Scanning inventory for healing_apple...")
    local healingAppleID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "healing_apple" then
                    healingAppleID = foodId
                    log("Found healing_apple with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for healing_apple: " .. tostring(errorMsg))
    end
    return healingAppleID
end

-- Use healing_apple on localPlayer
local function useHealingApple(foodID)
    if not foodID then
        log("Cannot use healing_apple: Missing foodID")
        return false
    end
    log("Using healing_apple " .. foodID .. " on localPlayer for baby ailment")
  
    local equipArgs = {
        foodID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip healing_apple: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped healing_apple")
    task.wait(2)
  
    local startArgs = {
        foodID,
        "START"
    }
    local endArgs = {
        foodID,
        "END"
    }
  
    -- First START/END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- Second START/END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- Third START
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
  
    -- Unequip food
    local unequipArgs = { foodID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used healing_apple on localPlayer")
    return true
end

-- Handle sick ailment for baby
local function handleSickAilment()
    log("SICK AILMENT DETECTED FOR BABY! Starting healing process on localPlayer...")
    local healingAppleID = findHealingApple()
    if not healingAppleID then
        log("No healing_apple found in inventory, purchasing one...")
        local purchaseSuccess = buyHealingApple()
        if not purchaseSuccess then
            log("Failed to purchase healing_apple")
            return false
        end
        task.wait(2)
        healingAppleID = findHealingApple()
        if not healingAppleID then
            log("Failed to find healing_apple after purchase")
            return false
        end
    end
    local useSuccess = useHealingApple(healingAppleID)
    if useSuccess then
        log("Successfully handled sick ailment with healing_apple on localPlayer")
        return true
    else
        log("Failed to use healing_apple on localPlayer")
        return false
    end
end

-- Check and buy missing furniture (from bb3, adapted; removed Piano for bored)
local function checkAndBuyMissingFurniture()
    log("Checking for missing furniture...")
    local missingFurniture = {}
   
    local campingShowerFound = findFurnitureByName("CampingShower")
    if not campingShowerFound then
        log("CampingShower not found, adding to buy list")
        table.insert(missingFurniture, {
            kind = "camping_shower",
            properties = {
                cframe = CFrame.new(25.55991554260254, 30.25162124633789, -1049.5599365234375, -0.6118413805961609, 0, 0.7909806966781616, 0, 1, 0, -0.7909806966781616, 0, -0.6118413805961609)
            }
        })
    else
        log("CampingShower found in house")
    end
   
    local sleepingBagFound = findFurnitureByName("SleepingBag")
    if not sleepingBagFound then
        log("SleepingBag not found, adding to buy list")
        table.insert(missingFurniture, {
            kind = "sleeping_bag",
            properties = {
                cframe = CFrame.new(6.224581718444824, 28.444856643676758, -1058.27001953125, 0.9946262836456299, -0.02014518901705742, 0.10155431926250458, 0.00000843508678372018, 0.9809029698371887, 0.194497749209404, -0.10353313386440277, -0.19345171749591827, 0.9756320118904114)
            }
        })
    else
        log("SleepingBag found in house")
    end
   
    if #missingFurniture > 0 then
        log("Buying " .. #missingFurniture .. " missing furniture items...")
        local args = {missingFurniture}
        local success, result = pcall(function()
            return API:WaitForChild("HousingAPI/BuyFurnitures"):InvokeServer(unpack(args))
        end)
        if success then
            log("Successfully purchased missing furniture")
            task.wait(3)
        else
            log("Failed to buy furniture: " .. tostring(result))
        end
    else
        log("All furniture found, no purchases needed")
    end
end

-- Monitoring and handling loop for baby ailments (integrated from bb3)
local function monitorAndHandleBabyAilments()
    log("Starting baby ailment monitoring and handling...")
    local lastScanTime = 0
    local SCAN_INTERVAL = 10 -- seconds
    local currentTime = os.time()
   
    while true do  -- Infinite loop, no toggle
        currentTime = os.time()
        local playerData = getPlayerData()
       
        if playerData and playerData.ailments_manager and playerData.ailments_manager.baby_ailments then
            local foundActionable = false
           
            for petUniqueID, ailmentType in pairs(playerData.ailments_manager.baby_ailments) do
                local ailmentKey = extractAilmentKey(ailmentType)
                local taskName = BABY_AILMENT_TASKS[ailmentKey]
               
                if taskName then
                    foundActionable = true
                    -- Check cooldown
                    if not lastTaskTime[ailmentKey] or (currentTime - lastTaskTime[ailmentKey]) >= TASK_COOLDOWN then
                        if ailmentKey == "beach_party" then
                            log("Baby beach_party ailment detected for pet: " .. petUniqueID .. " → Teleporting to character position")
                            local success = handleBeachPartyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "bored" then
                            log("Baby bored ailment detected for pet: " .. petUniqueID .. " → Teleporting to bored position")
                            local success = handleBoredAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "school" then
                            log("Baby school ailment detected for pet: " .. petUniqueID .. " → Teleporting to school position")
                            local success = handleSchoolAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "salon" then
                            log("Baby salon ailment detected for pet: " .. petUniqueID .. " → Teleporting to salon position")
                            local success = handleSalonAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "pizza_party" then
                            log("Baby pizza_party ailment detected for pet: " .. petUniqueID .. " → Teleporting to pizza_party position")
                            local success = handlePizzaPartyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "hungry" then
                            log("Baby hungry ailment detected for pet: " .. petUniqueID .. " → Using teachers_apple on localPlayer")
                            local success = handleHungryAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "thirsty" then
                            log("Baby thirsty ailment detected for pet: " .. petUniqueID .. " → Using water on localPlayer")
                            local success = handleThirstyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "sick" then
                            log("Baby sick ailment detected for pet: " .. petUniqueID .. " → Using healing_apple on localPlayer")
                            local success = handleSickAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        else
                            -- For furniture-based (sleepy, dirty)
                            log("Baby " .. ailmentKey .. " ailment detected for pet: " .. petUniqueID .. " → Using " .. taskName .. " on localPlayer")
                            local success = useFurnitureWithLocalPlayer(taskName)
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        end
                        break -- Handle one at a time
                    else
                        log(ailmentKey .. " on cooldown (" .. (TASK_COOLDOWN - (currentTime - lastTaskTime[ailmentKey])) .. "s remaining)")
                    end
                end
            end
           
            if not foundActionable and currentTime - lastScanTime >= 60 then
                printAvailableBabyAilmentsCompact()  -- Print periodically if no action
                lastScanTime = currentTime
            end
        else
            if currentTime - lastScanTime >= 60 then
                printAvailableBabyAilmentsCompact()
                lastScanTime = currentTime
            end
        end
       
        task.wait(SCAN_INTERVAL)
    end
end

-----------------------------------------------------
-- SELECT BABY TEAM (from b1.txt)
-----------------------------------------------------
local function selectBabyTeam()
    log("Selecting Baby team...")
    local args = {
        "Babies",
        {
            dont_respawn = true,
            source_for_logging = "avatar_editor"
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("TeamAPI/ChooseTeam"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully selected Baby team")
        return true
    else
        log("Failed to select Baby team: " .. tostring(result))
        return false
    end
end

-----------------------------------------------------
-- RESPAWN AND UNSUBSCRIBE AT BEGINNING
-----------------------------------------------------
log("Performing initial respawn and unsubscribe...")
-- Initial respawn using TeamAPI
pcall(function()
    API:WaitForChild("TeamAPI/Spawn"):InvokeServer()
end)
task.wait(9)
-- Initial unsubscribe from house
pcall(function()
    local unsubscribeAPI = API:FindFirstChild("HousingAPI/UnsubscribeFromHouse")
    if unsubscribeAPI then
        if unsubscribeAPI:IsA("RemoteFunction") then
            unsubscribeAPI:InvokeServer(player, true)
        elseif unsubscribeAPI:IsA("RemoteEvent") then
            unsubscribeAPI:FireServer(player, true)
        end
    end
end)
task.wait(7)
-- Select Baby team after respawn and unsubscribe
selectBabyTeam()
task.wait(2)

-----------------------------------------------------
-- GO TO MAIN MAP
-----------------------------------------------------
local function goToMainMap()
    log("Starting teleport to Main Map...")
    for attempt = 1, 3 do
        log("Attempt " .. attempt)
        -- Teleport to initial position (no respawn here, done at beginning)
        local initialPos = Vector3.new(-3025.614, 6529.577, -8968.435)
        if safeTp(initialPos) then
            setCam(Vector3.new(-3025.623, 6532.164, -8970.206), Vector3.new(0, 0, 1))
            pressW()
            task.wait(15)
            -- Check if near Main Map position
            local targetPos = Vector3.new(-255.10, 30.89, -1831.46)
            if isNear(targetPos, 50) then
                resetCam()
                log("Arrived at Main Map near " .. tostring(targetPos) .. "!")
                -- Wait 2 seconds, then go to Character position
                task.wait(2)
                local characterPos = Vector3.new(-604.54, 26.49, -1538.53)
                local cameraPos = Vector3.new(-598.88, 33.84, -1546.60)
                if safeTp(characterPos) then
                    -- Set camera looking towards character position
                    setCam(cameraPos, characterPos)
                    log("Teleported to Character position: " .. tostring(characterPos) .. " with camera at " .. tostring(cameraPos))
                    -- Wait a bit to view, then reset camera
                    task.wait(3)
                    resetCam()
                    log("Camera reset after arriving at character position")
                    -- Check and buy missing furniture
                    task.wait(2)
                    checkAndBuyMissingFurniture()
                    task.wait(3)
                    -- Start baby ailment monitoring and handling
                    task.wait(2)
                    monitorAndHandleBabyAilments()
                    -- Start PetFarm automatically
                    task.wait(2)
                    togglePetFarmMode()
                end
                return true
            else
                log("Not near target, retrying...")
            end
        end
        resetCam()
        task.wait(2)
    end
    log("Failed to reach Main Map after 3 attempts.")
    return false
end

-- Run the function
goToMainMap()
[file content end]
