-- Small Script to Go to Main Map and Then to Specific Character Position
-- Based on logic from ress0 ‚Äî –∫–æ–ø–∏—è.txt
-- Added respawn and unsubscribe from home at the beginning
-- Added choose Baby team at the beginning (from b1.txt)
-- Added baby ailment detection and handling (from bb3.txt, integrated with monitoring)
-- Added camera reset after arriving at character position
-- Integrated furniture and food handling for baby ailments
-- Added beach_party ailment handling: teleport to character position if detected
-- Updated bored ailment handling: teleport to specific bored position instead of using Piano
-- Added school ailment handling: teleport to school character position, set camera, pressW
-- Added salon ailment handling: teleport to salon character position, set camera, pressW
-- Added pizza_party ailment handling: teleport to pizza_party character position, set camera, pressW
-- INTEGRATED: PetFarm logic from w1.txt - Pet selection, equipping on arrival, always keep equipped
--             Updated ailment handling to use bb8 furniture (SleepingBag for sleepy, CampingShower for dirty)
--             No BasicBed, Piano, CheapPetBathtub needed

repeat task.wait() until game:IsLoaded()
repeat task.wait() until game.Players.LocalPlayer
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local player = Players.LocalPlayer

-----------------------------------------------------
-- UTILITIES (Simplified from ress0)
-----------------------------------------------------
local function log(msg) print("[MainMap Teleporter & PetFarm] " .. tostring(msg)) end
local function getChar() return player.Character or player.CharacterAdded:Wait() end
local function safeTp(pos)
    return pcall(function()
        local hrp = getChar():FindFirstChild("HumanoidRootPart")
        if hrp then hrp.CFrame = CFrame.new(pos); task.wait(0.3) end
    end)
end
local function setCam(pos, look)
    pcall(function()
        local cam = Workspace.CurrentCamera
        if cam then cam.CameraType = Enum.CameraType.Scriptable; cam.CFrame = CFrame.new(pos, look) end
    end)
end
local function resetCam()
    pcall(function()
        local cam = Workspace.CurrentCamera
        if cam then cam.CameraType = Enum.CameraType.Custom end
    end)
end
local function pressW()
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
    end)
end
local function pressS()
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.s, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.s, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
    end)
end
local function isNear(pos, dist)
    dist = dist or 60
    local success, result = pcall(function()
        local hrp = getChar():FindFirstChild("HumanoidRootPart")
        return hrp and (hrp.Position - pos).Magnitude < dist
    end)
    return success and result or false
end

-----------------------------------------------------
-- PETFARM INTEGRATION FROM W1 (Adapted for Baby & bb8 Furniture)
-----------------------------------------------------
-- Debug settings
local DEBUG_MODE = true
local function debugPrint(message)
    if not DEBUG_MODE then return end
    local hours = os.date("%H")
    local minutes = os.date("%M")
    local seconds = os.date("%S")
    local timestamp = string.format("[%s:%s:%s]", hours, minutes, seconds)
    print(timestamp .. " [PetFarm] " .. message)
end

-- PetFarm variables (from w1)
local PetFarmMode = true  -- Auto-enabled
local petFarmPetID = nil
local lastValidPetID = nil
local PetID = nil

-- Ailment to Furniture Mapping (Updated from w1 to match bb8: SleepingBag, CampingShower; no Piano/BasicBed/CheapPetBathtub)
local AILMENT_TASKS = {
    sleepy = "SleepingBag",
    hungry = "teachers_apple",
    thirsty = "water",
    dirty = "CampingShower",
    bored = "teleport_to_bored",
    toilet = "AilmentsRefresh2024LitterBox",  -- Keep if needed, but bb8 doesn't have
    play = "THROW_TOY",  -- From w1, if needed
    walk = "WALK_HANDLER",
    ride = "STROLLER_HANDLER",
    sick = "healing_apple",
    mystery = "MYSTERY_HANDLER",
    pet_me = "PET_ME_HANDLER",
    beach_party = "teleport_to_character",
    school = "teleport_to_school",
    salon = "teleport_to_salon",
    pizza_party = "teleport_to_pizza"
}

-- Task cooldowns to prevent spam
local lastTaskTime = {}
local TASK_COOLDOWN = 30 -- seconds

-- BABY_AILMENT_TASKS (from bb8, merged/prioritized)
local BABY_AILMENT_TASKS = {
    sleepy = "SleepingBag",
    hungry = "teachers_apple",
    thirsty = "water",
    dirty = "CampingShower",
    bored = "teleport_to_bored",
    sick = "healing_apple",
    beach_party = "teleport_to_character",
    school = "teleport_to_school",
    salon = "teleport_to_salon",
    pizza_party = "teleport_to_pizza"
}

-- Pre-cache API references
local API = ReplicatedStorage:WaitForChild("API")
local ExitSeatStates = API:WaitForChild("AdoptAPI/ExitSeatStates")

-- Positions (from bb8)
local BEACH_PARTY_CHARACTER_POS = Vector3.new(-604.54, 26.49, -1538.53)
local BEACH_PARTY_CAMERA_POS = Vector3.new(-598.88, 33.84, -1546.60)
local BORED_CHARACTER_POS = Vector3.new(-489.941, 29.448, -1799.160)
local BORED_CAMERA_POS = Vector3.new(-499.916, 34.281, -1804.232)
local SCHOOL_CHARACTER_POS = Vector3.new(-309.794, 29.798, -1505.317)
local SCHOOL_CAMERA_POS = Vector3.new(-300.865, 36.256, -1499.952)
local SALON_CHARACTER_POS = Vector3.new(-131.81, 29.34, -1765.13)
local SALON_CAMERA_POS = Vector3.new(-130.97, 36.81, -1755.39)
local PIZZA_PARTY_CHARACTER_POS = Vector3.new(-121.97, 29.34, -1663.56)
local PIZZA_PARTY_CAMERA_POS = Vector3.new(-132.73, 35.09, -1662.70)

-- Function to safely get player data (from bb8)
local function getPlayerData()
    local clientModules = ReplicatedStorage:WaitForChild("ClientModules", 10)
    if not clientModules then return nil end
    local coreModule = clientModules:WaitForChild("Core", 5)
    if not coreModule then return nil end
    local clientDataModule = coreModule:WaitForChild("ClientData", 5)
    if not clientDataModule then return nil end
   
    local clientData
    local success, err = pcall(function()
        clientData = require(clientDataModule)
    end)
    if not success or not clientData then return nil end
   
    local playerData
    success, err = pcall(function()
        playerData = clientData.get_data()[player.Name]
    end)
    if not success or not playerData then return nil end
   
    return playerData
end

-- Find best starter pet (from w1, adapted)
local function findBestStarterPet()
    debugPrint("Finding best starter pet (starter_egg or 6yo dog/cat)...")
    local priorityPets = {}
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.pets then
            for petIndex, petData in pairs(playerData.inventory.pets) do
                if petData and petData.unique and petData.id and petData.properties then
                    local petName = tostring(petData.id):lower()
                    local petAge = petData.properties.age or 0
                    -- Prioritize starter_egg, then 6yo dog/cat
                    if string.find(petName, "starter_egg") then
                        table.insert(priorityPets, 1, petData.unique)  -- Highest priority
                    elseif (string.find(petName, "dog") or string.find(petName, "cat")) and petAge == 6 then
                        table.insert(priorityPets, petData.unique)
                    end
                end
            end
        end
    end)
    if not success then
        debugPrint("Error finding starter pet: " .. tostring(errorMsg))
    end
    return #priorityPets > 0 and priorityPets[1] or nil
end

-- Ensure pet is equipped (from w1, always keep equipped logic)
local function ensurePetEquipped(petID, maxAttempts)
    if not petID then return false end
    maxAttempts = maxAttempts or 10
    local attempts = 0
    while attempts < maxAttempts do
        attempts = attempts + 1
        -- Equip pet
        local equipSuccess, equipResult = pcall(function()
            return ReplicatedStorage.API["ToolAPI/Equip"]:InvokeServer(petID, {use_sound_delay = true, equip_as_last = false})
        end)
        if equipSuccess then
            debugPrint("Pet equipped successfully")
            task.wait(2)
            -- Check equip_manager
            local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
            local playerData = clientData.get_data()[player.Name]
            if playerData and playerData.equip_manager and playerData.equip_manager.pets then
                for _, equippedPet in ipairs(playerData.equip_manager.pets) do
                    if equippedPet.unique == petID then
                        debugPrint("Pet confirmed equipped in equip_manager")
                        return true
                    end
                end
            end
        else
            debugPrint("Equip attempt " .. attempts .. " failed: " .. tostring(equipResult))
        end
        task.wait(2)
    end
    debugPrint("Failed to equip pet after " .. maxAttempts .. " attempts")
    return false
end

-- Always keep pet equipped loop (from w1)
local function keepPetEquippedLoop()
    while PetFarmMode do
        if petFarmPetID then
            local ensured = ensurePetEquipped(petFarmPetID, 3)  -- Quick check with fewer attempts
            if not ensured then
                debugPrint("Pet lost - re-equipping...")
                ensurePetEquipped(petFarmPetID, 10)
            end
        end
        task.wait(5)  -- Check every 5s
    end
end

-- Equip pet on arrival (new: call after teleport)
local function equipPetOnArrival()
    debugPrint("Equipping pet on arrival to main map...")
    local bestPetID = findBestStarterPet()
    if bestPetID then
        PetID = bestPetID
        lastValidPetID = bestPetID
        petFarmPetID = bestPetID
        local equipSuccess = ensurePetEquipped(bestPetID, 10)
        if equipSuccess then
            debugPrint("Pet equipped successfully on arrival")
            -- Start keep equipped loop
            task.spawn(keepPetEquippedLoop)
        else
            debugPrint("Warning: Could not equip pet on arrival")
        end
    else
        debugPrint("Warning: No suitable pet found for equipping")
    end
end

-- Enhanced helper to extract ailment key (from bb8)
local function extractAilmentKey(ailment)
    if type(ailment) == "table" then
        local candidates = {"type", "name", "ailment", "id", "key", "kind"}
        for _, field in ipairs(candidates) do
            local val = ailment[field]
            if type(val) == "string" then
                local lowerVal = val:lower()
                if BABY_AILMENT_TASKS[lowerVal] then
                    log("Extracted ailment '" .. lowerVal .. "' from field '" .. field .. "'")
                    return lowerVal
                end
            end
        end
        for k, v in pairs(ailment) do
            if type(v) == "string" then
                local lowerV = v:lower()
                if BABY_AILMENT_TASKS[lowerV] then
                    log("Found matching ailment string '" .. lowerV .. "' in table key '" .. tostring(k) .. "'")
                    return lowerV
                end
            elseif type(v) == "table" then
                local subKey = extractAilmentKey(v)
                if subKey ~= "unknown" then
                    return subKey
                end
            end
        end
        log("Unknown ailment table structure")
        return "unknown"
    else
        local str = tostring(ailment):lower()
        if BABY_AILMENT_TASKS[str] then
            return str
        end
        return str
    end
end

-- Function to print available baby ailments in compact form (from bb8)
local function printAvailableBabyAilmentsCompact()
    log("üîç BABY AILMENTS (COMPACT)")
    log("=========================")
    local playerData = getPlayerData()
    if not playerData or not playerData.ailments_manager or not playerData.ailments_manager.baby_ailments then
        log("No baby ailments found.")
        return
    end
   
    local babyAilments = playerData.ailments_manager.baby_ailments
    local count = 0
    local actionableCount = 0
   
    log(string.format("%-5s %-36s %-15s %-10s", "No.", "Pet Unique ID", "Ailment", "Actionable"))
    log(string.rep("-", 70))
   
    for petUniqueID, ailment in pairs(babyAilments) do
        local ailmentKey = extractAilmentKey(ailment)
        local isActionable = BABY_AILMENT_TASKS[ailmentKey] and ailmentKey ~= "unknown"
        if isActionable then actionableCount = actionableCount + 1 end
        count = count + 1
        local status = isActionable and "YES" or "NO"
        log(string.format("%-5d %-36s %-15s %-10s", count, petUniqueID:sub(1, 36), ailmentKey, status))
    end
   
    log(string.rep("-", 70))
    log(string.format("Total baby ailments: %d (Actionable: %d)", count, actionableCount))
end

-- Extract furniture data (from bb8)
local function extractFurnitureData(model, folderId, part)
    return {
        folderId = folderId,
        partName = part.Name,
        position = part.Position,
        cframe = part.CFrame,
        model = model
    }
end

-- Find furniture by name (picks random from available) (from bb8)
local function findFurnitureByName(name)
    log("Searching for furniture: " .. name)
    local hi = Workspace:FindFirstChild("HouseInteriors")
    if not hi then
        log("HouseInteriors not found")
        return nil
    end
   
    local possibleFurniture = {}
   
    -- Search in HouseInteriors.furniture
    local furnitureFolder = hi:FindFirstChild("furniture")
    if furnitureFolder then
        for _, houseKey in ipairs(furnitureFolder:GetChildren()) do
            local model = houseKey:FindFirstChild(name)
            if model and model:IsA("Model") then
                local folderId = string.match(houseKey.Name, "f%-%d+") or "unknown"
                local activationParts = {"UseBlock", "Seat1", "Seat2"}
                local foundPart = nil
                for _, partName in ipairs(activationParts) do
                    local part = model:FindFirstChild(partName, true)
                    if part and part:IsA("BasePart") then
                        foundPart = part
                        log("Using " .. partName .. " in " .. model.Name .. " from houseKey " .. houseKey.Name)
                        break
                    end
                end
               
                if not foundPart then
                    for _, part in ipairs(model:GetDescendants()) do
                        if part:IsA("BasePart") then
                            foundPart = part
                            log("Using fallback part: " .. part.Name .. " in " .. model.Name .. " from houseKey " .. houseKey.Name)
                            break
                        end
                    end
                end
               
                if foundPart then
                    table.insert(possibleFurniture, extractFurnitureData(model, folderId, foundPart))
                end
            end
        end
    end
   
    -- Fallback: search entire workspace
    local model = Workspace:FindFirstChild(name, true)
    if model and model:IsA("Model") then
        local parentFolder = model.Parent
        local folderId = (parentFolder and string.match(parentFolder.Name, "f%-%d+")) or "unknown"
        local activationParts = {"UseBlock", "Seat1", "Seat2"}
        local foundPart = nil
        for _, partName in ipairs(activationParts) do
            local part = model:FindFirstChild(partName, true)
            if part and part:IsA("BasePart") then
                foundPart = part
                break
            end
        end
        if not foundPart then
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA("BasePart") then
                    foundPart = part
                    break
                end
            end
        end
        if foundPart then
            table.insert(possibleFurniture, extractFurnitureData(model, folderId, foundPart))
        end
    end
   
    if #possibleFurniture > 0 then
        local randomIndex = math.random(1, #possibleFurniture)
        local selected = possibleFurniture[randomIndex]
        log("Selected random furniture from " .. #possibleFurniture .. " options: folder " .. selected.folderId .. " part " .. selected.partName)
        return selected
    end
   
    log("Furniture not found: " .. name .. " (no instances available)")
    return nil
end

-- Call ExitSeatStates once after furniture use (from bb8)
local function callExitSeatStatesOnce()
    log("Calling ExitSeatStates once after furniture use...")
    local Char = player.Character or player.CharacterAdded:Wait()
    if Char then
        pcall(function()
            ExitSeatStates:FireServer(Char)
        end)
        log("Successfully called ExitSeatStates once")
    else
        log("Failed to get character for ExitSeatStates")
    end
end

-- Handle furniture activation (from bb8, updated for new furniture)
local function handleFurnitureActivation(furnitureName)
    log("Activating furniture detected: " .. furnitureName)
    local furnitureData = findFurnitureByName(furnitureName)
    if not furnitureData then
        log("Cannot activate furniture: " .. furnitureName .. " - not found")
        return false
    end
   
    local char = player.Character
    if not char then
        log("Cannot activate furniture: No character found")
        return false
    end

    local isInterior = (furnitureName == "CampingShower" or furnitureName == "SleepingBag")
    local apiPath = isInterior and "HousingAPI/ActivateInteriorFurniture" or "HousingAPI/ActivateFurniture"
    local args
    if isInterior then
        args = {
            furnitureData.folderId,
            furnitureData.partName,
            {
                cframe = furnitureData.cframe
            },
            char
        }
    else
        args = {
            player,
            furnitureData.folderId,
            furnitureData.partName,
            {
                cframe = furnitureData.cframe
            },
            char
        }
    end
   
    log("Activating " .. furnitureName .. " in folder " .. furnitureData.folderId .. " with part " .. furnitureData.partName .. " using " .. apiPath)
   
    local success, result = pcall(function()
        return API:WaitForChild(apiPath):InvokeServer(unpack(args))
    end)
   
    if success then
        log("Successfully activated: " .. furnitureName)
        task.wait(20) -- Wait for ailment cure
        callExitSeatStatesOnce() -- Call only once after wait
        return true
    else
        log("Failed to activate: " .. furnitureName .. " - " .. tostring(result))
        return false
    end
end

-- Use furniture with localPlayer (from bb8)
local function useFurnitureWithLocalPlayer(furnitureName)
    log("Using furniture for baby: " .. furnitureName .. " on localPlayer")
    return handleFurnitureActivation(furnitureName)
end

-- Handle teleports (from bb8, unchanged)
local function handleBeachPartyAilment()
    log("BEACH_PARTY AILMENT DETECTED FOR BABY! Teleporting to character position...")
    if safeTp(BEACH_PARTY_CHARACTER_POS) then
        setCam(BEACH_PARTY_CAMERA_POS, BEACH_PARTY_CHARACTER_POS)
        task.wait(3)
        resetCam()
        log("Successfully teleported to beach_party position: " .. tostring(BEACH_PARTY_CHARACTER_POS))
        return true
    else
        log("Failed to teleport for beach_party ailment")
        return false
    end
end

local function handleBoredAilment()
    log("BORED AILMENT DETECTED FOR BABY! Teleporting to bored position...")
    if safeTp(BORED_CHARACTER_POS) then
        setCam(BORED_CAMERA_POS, BORED_CHARACTER_POS)
        task.wait(3)
        resetCam()
        log("Successfully teleported to bored position: " .. tostring(BORED_CHARACTER_POS))
        return true
    else
        log("Failed to teleport for bored ailment")
        return false
    end
end

local function handleSchoolAilment()
    log("SCHOOL AILMENT DETECTED FOR BABY! Teleporting to school character position...")
    if safeTp(SCHOOL_CHARACTER_POS) then
        setCam(SCHOOL_CAMERA_POS, SCHOOL_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to school position: " .. tostring(SCHOOL_CHARACTER_POS) .. " and pressed W")
        return true
    else
        log("Failed to teleport for school ailment")
        return false
    end
end

local function handleSalonAilment()
    log("SALON AILMENT DETECTED FOR BABY! Teleporting to salon character position...")
    if safeTp(SALON_CHARACTER_POS) then
        setCam(SALON_CAMERA_POS, SALON_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to salon position: " .. tostring(SALON_CHARACTER_POS) .. " and pressed W")
        return true
    else
        log("Failed to teleport for salon ailment")
        return false
    end
end

local function handlePizzaPartyAilment()
    log("PIZZA_PARTY AILMENT DETECTED FOR BABY! Teleporting to pizza_party character position...")
    if safeTp(PIZZA_PARTY_CHARACTER_POS) then
        setCam(PIZZA_PARTY_CAMERA_POS, PIZZA_PARTY_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to pizza_party position: " .. tostring(PIZZA_PARTY_CHARACTER_POS) .. " and pressed W")
        return true
    else
        log("Failed to teleport for pizza_party ailment")
        return false
    end
end

-- Food handling functions (from bb8, unchanged: buy, find, use for teachers_apple, water, healing_apple)
local function buyTeachersApple()
    log("Buying teachers_apple from shop...")
    local args = {
        "food",
        "teachers_apple",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased teachers_apple")
        return true
    else
        log("Failed to buy teachers_apple: " .. tostring(result))
        return false
    end
end

local function findTeachersApple()
    log("Scanning inventory for teachers_apple...")
    local teachersAppleID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "teachers_apple" then
                    teachersAppleID = foodId
                    log("Found teachers_apple with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for teachers_apple: " .. tostring(errorMsg))
    end
    return teachersAppleID
end

local function useTeachersApple(foodID)
    if not foodID then
        log("Cannot use teachers_apple: Missing foodID")
        return false
    end
    log("Using teachers_apple " .. foodID .. " on localPlayer for baby ailment")
  
    local equipArgs = {
        foodID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip teachers_apple: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped teachers_apple")
    task.wait(2)
  
    local startArgs = {
        foodID,
        "START"
    }
    local endArgs = {
        foodID,
        "END"
    }
  
    -- START
    local startSuccess, startResult = pcall(function()
        return API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    if not startSuccess then
        log("Failed to start using teachers_apple: " .. tostring(startResult))
        pcall(function()
            API:WaitForChild("ToolAPI/Unequip"):InvokeServer(foodID)
        end)
        return false
    end
    task.wait(2)
  
    -- END (first)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- START END (second)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- START (third)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
  
    -- Unequip food
    local unequipArgs = { foodID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used teachers_apple on localPlayer")
    return true
end

local function handleHungryAilment()
    log("HUNGRY AILMENT DETECTED FOR BABY! Starting feeding process on localPlayer...")
    local teachersAppleID = findTeachersApple()
    if not teachersAppleID then
        log("No teachers_apple found in inventory, purchasing one...")
        local purchaseSuccess = buyTeachersApple()
        if not purchaseSuccess then
            log("Failed to purchase teachers_apple")
            return false
        end
        task.wait(2)
        teachersAppleID = findTeachersApple()
        if not teachersAppleID then
            log("Failed to find teachers_apple after purchase")
            return false
        end
    end
    local useSuccess = useTeachersApple(teachersAppleID)
    if useSuccess then
        log("Successfully handled hungry ailment with teachers_apple on localPlayer")
        return true
    else
        log("Failed to use teachers_apple on localPlayer")
        return false
    end
end

local function buyWater()
    log("Buying water from shop...")
    local args = {
        "food",
        "water",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased water")
        return true
    else
        log("Failed to buy water: " .. tostring(result))
        return false
    end
end

local function findWater()
    log("Scanning inventory for water...")
    local waterID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "water" then
                    waterID = foodId
                    log("Found water with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for water: " .. tostring(errorMsg))
    end
    return waterID
end

local function useWater(foodID)
    if not foodID then
        log("Cannot use water: Missing foodID")
        return false
    end
    log("Using water " .. foodID .. " on localPlayer for baby ailment")
  
    local equipArgs = {
        foodID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip water: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped water")
    task.wait(3)
  
    local startArgs = {
        foodID,
        "START"
    }
    local endArgs = {
        foodID,
        "END"
    }
  
    -- Perform multiple START/END cycles (9 full cycles as in bb3)
    for i = 1, 9 do
        pcall(function()
            API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
        end)
        task.wait(2)
        pcall(function()
            API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
        end)
        task.wait(2)
    end
  
    -- Unequip food
    local unequipArgs = { foodID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used water on localPlayer")
    return true
end

local function handleThirstyAilment()
    log("THIRSTY AILMENT DETECTED FOR BABY! Starting watering process on localPlayer...")
    local waterID = findWater()
    if not waterID then
        log("No water found in inventory, purchasing one...")
        local purchaseSuccess = buyWater()
        if not purchaseSuccess then
            log("Failed to purchase water")
            return false
        end
        task.wait(3)
        waterID = findWater()
        if not waterID then
            log("Failed to find water after purchase")
            return false
        end
    end
    local useSuccess = useWater(waterID)
    if useSuccess then
        log("Successfully handled thirsty ailment with water on localPlayer")
        return true
    else
        log("Failed to use water on localPlayer")
        return false
    end
end

local function buyHealingApple()
    log("Buying healing_apple from shop...")
    local args = {
        "food",
        "healing_apple",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased healing_apple")
        return true
    else
        log("Failed to buy healing_apple: " .. tostring(result))
        return false
    end
end

local function findHealingApple()
    log("Scanning inventory for healing_apple...")
    local healingAppleID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "healing_apple" then
                    healingAppleID = foodId
                    log("Found healing_apple with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for healing_apple: " .. tostring(errorMsg))
    end
    return healingAppleID
end

local function useHealingApple(foodID)
    if not foodID then
        log("Cannot use healing_apple: Missing foodID")
        return false
    end
    log("Using healing_apple " .. foodID .. " on localPlayer for baby ailment")
  
    local equipArgs = {
        foodID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip healing_apple: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped healing_apple")
    task.wait(2)
  
    local startArgs = {
        foodID,
        "START"
    }
    local endArgs = {
        foodID,
        "END"
    }
  
    -- First START/END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- Second START/END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- Third START
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
  
    -- Unequip food
    local unequipArgs = { foodID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used healing_apple on localPlayer")
    return true
end

local function handleSickAilment()
    log("SICK AILMENT DETECTED FOR BABY! Starting healing process on localPlayer...")
    local healingAppleID = findHealingApple()
    if not healingAppleID then
        log("No healing_apple found in inventory, purchasing one...")
        local purchaseSuccess = buyHealingApple()
        if not purchaseSuccess then
            log("Failed to purchase healing_apple")
            return false
        end
        task.wait(2)
        healingAppleID = findHealingApple()
        if not healingAppleID then
            log("Failed to find healing_apple after purchase")
            return false
        end
    end
    local useSuccess = useHealingApple(healingAppleID)
    if useSuccess then
        log("Successfully handled sick ailment with healing_apple on localPlayer")
        return true
    else
        log("Failed to use healing_apple on localPlayer")
        return false
    end
end

-- Check and buy missing furniture (from bb8, updated: SleepingBag, CampingShower only)
local function checkAndBuyMissingFurniture()
    log("Checking for missing furniture...")
    local missingFurniture = {}
   
    local campingShowerFound = findFurnitureByName("CampingShower")
    if not campingShowerFound then
        log("CampingShower not found, adding to buy list")
        table.insert(missingFurniture, {
            kind = "camping_shower",
            properties = {
                cframe = CFrame.new(25.55991554260254, 30.25162124633789, -1049.5599365234375, -0.6118413805961609, 0, 0.7909806966781616, 0, 1, 0, -0.7909806966781616, 0, -0.6118413805961609)
            }
        })
    else
        log("CampingShower found in house")
    end
   
    local sleepingBagFound = findFurnitureByName("SleepingBag")
    if not sleepingBagFound then
        log("SleepingBag not found, adding to buy list")
        table.insert(missingFurniture, {
            kind = "sleeping_bag",
            properties = {
                cframe = CFrame.new(6.224581718444824, 28.444856643676758, -1058.27001953125, 0.9946262836456299, -0.02014518901705742, 0.10155431926250458, 0.00000843508678372018, 0.9809029698371887, 0.194497749209404, -0.10353313386440277, -0.19345171749591827, 0.9756320118904114)
            }
        })
    else
        log("SleepingBag found in house")
    end
   
    if #missingFurniture > 0 then
        log("Buying " .. #missingFurniture .. " missing furniture items...")
        local args = {missingFurniture}
        local success, result = pcall(function()
            return API:WaitForChild("HousingAPI/BuyFurnitures"):InvokeServer(unpack(args))
        end)
        if success then
            log("Successfully purchased missing furniture")
            task.wait(3)
        else
            log("Failed to buy furniture: " .. tostring(result))
        end
    else
        log("All furniture found, no purchases needed")
    end
end

-- Monitoring and handling loop for baby ailments (from bb8, integrated with PetFarmMode)
local function monitorAndHandleBabyAilments()
    log("Starting baby ailment monitoring and handling with PetFarm...")
    local lastScanTime = 0
    local SCAN_INTERVAL = 10 -- seconds
    local currentTime = os.time()
   
    while PetFarmMode do  -- Now tied to PetFarmMode
        currentTime = os.time()
        local playerData = getPlayerData()
       
        if playerData and playerData.ailments_manager and playerData.ailments_manager.baby_ailments then
            local foundActionable = false
           
            for petUniqueID, ailmentType in pairs(playerData.ailments_manager.baby_ailments) do
                -- Prioritize equipped pet if matching
                if petFarmPetID and petUniqueID == petFarmPetID then
                    debugPrint("Prioritizing ailment for equipped pet: " .. petUniqueID)
                end
                local ailmentKey = extractAilmentKey(ailmentType)
                local taskName = BABY_AILMENT_TASKS[ailmentKey]
               
                if taskName then
                    foundActionable = true
                    -- Check cooldown
                    if not lastTaskTime[ailmentKey] or (currentTime - lastTaskTime[ailmentKey]) >= TASK_COOLDOWN then
                        if ailmentKey == "beach_party" then
                            log("Baby beach_party ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to character position")
                            local success = handleBeachPartyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "bored" then
                            log("Baby bored ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to bored position")
                            local success = handleBoredAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "school" then
                            log("Baby school ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to school position")
                            local success = handleSchoolAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "salon" then
                            log("Baby salon ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to salon position")
                            local success = handleSalonAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "pizza_party" then
                            log("Baby pizza_party ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to pizza_party position")
                            local success = handlePizzaPartyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "hungry" then
                            log("Baby hungry ailment detected for pet: " .. petUniqueID .. " ‚Üí Using teachers_apple on localPlayer")
                            local success = handleHungryAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "thirsty" then
                            log("Baby thirsty ailment detected for pet: " .. petUniqueID .. " ‚Üí Using water on localPlayer")
                            local success = handleThirstyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "sick" then
                            log("Baby sick ailment detected for pet: " .. petUniqueID .. " ‚Üí Using healing_apple on localPlayer")
                            local success = handleSickAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        else
                            -- For furniture-based (sleepy, dirty) - Updated to new furniture
                            log("Baby " .. ailmentKey .. " ailment detected for pet: " .. petUniqueID .. " ‚Üí Using " .. taskName .. " on localPlayer")
                            local success = useFurnitureWithLocalPlayer(taskName)
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        end
                        break -- Handle one at a time
                    else
                        log(ailmentKey .. " on cooldown (" .. (TASK_COOLDOWN - (currentTime - lastTaskTime[ailmentKey])) .. "s remaining)")
                    end
                end
            end
           
            if not foundActionable and currentTime - lastScanTime >= 60 then
                printAvailableBabyAilmentsCompact()  -- Print periodically if no action
                lastScanTime = currentTime
            end
        else
            if currentTime - lastScanTime >= 60 then
                printAvailableBabyAilmentsCompact()
                lastScanTime = currentTime
            end
        end
       
        task.wait(SCAN_INTERVAL)
    end
    debugPrint("PetFarm stopped - ailment monitoring ended")
end

-----------------------------------------------------
-- SELECT BABY TEAM (from b1.txt)
-----------------------------------------------------
local function selectBabyTeam()
    log("Selecting Baby team...")
    local args = {
        "Babies",
        {
            dont_respawn = true,
            source_for_logging = "avatar_editor"
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("TeamAPI/ChooseTeam"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully selected Baby team")
        return true
    else
        log("Failed to select Baby team: " .. tostring(result))
        return false
    end
end

-----------------------------------------------------
-- RESPAWN AND UNSUBSCRIBE AT BEGINNING
-----------------------------------------------------
log("Performing initial respawn and unsubscribe...")
-- Initial respawn using TeamAPI
pcall(function()
    API:WaitForChild("TeamAPI/Spawn"):InvokeServer()
end)
task.wait(9)
-- Initial unsubscribe from house
pcall(function()
    local unsubscribeAPI = API:FindFirstChild("HousingAPI/UnsubscribeFromHouse")
    if unsubscribeAPI then
        if unsubscribeAPI:IsA("RemoteFunction") then
            unsubscribeAPI:InvokeServer(player, true)
        elseif unsubscribeAPI:IsA("RemoteEvent") then
            unsubscribeAPI:FireServer(player, true)
        end
    end
end)
task.wait(7)
-- Select Baby team after respawn and unsubscribe
selectBabyTeam()
task.wait(2)

-----------------------------------------------------
-- GO TO MAIN MAP & START PETFARM (Updated)
-----------------------------------------------------
local function goToMainMap()
    log("Starting teleport to Main Map...")
    for attempt = 1, 3 do
        log("Attempt " .. attempt)
        -- Teleport to initial position (no respawn here, done at beginning)
        local initialPos = Vector3.new(-3025.614, 6529.577, -8968.435)
        if safeTp(initialPos) then
            setCam(Vector3.new(-3025.623, 6532.164, -8970.206), Vector3.new(0, 0, 1))
            pressW()
            task.wait(15)
            -- Check if near Main Map position
            local targetPos = Vector3.new(-255.10, 30.89, -1831.46)
            if isNear(targetPos, 50) then
                resetCam()
                log("Arrived at Main Map near " .. tostring(targetPos) .. "!")
                -- Wait 2 seconds, then go to Character position
                task.wait(2)
                local characterPos = Vector3.new(-604.54, 26.49, -1538.53)
                local cameraPos = Vector3.new(-598.88, 33.84, -1546.60)
                if safeTp(characterPos) then
                    -- Set camera looking towards character position
                    setCam(cameraPos, characterPos)
                    log("Teleported to Character position: " .. tostring(characterPos) .. " with camera at " .. tostring(cameraPos))
                    -- Wait a bit to view, then reset camera
                    task.wait(3)
                    resetCam()
                    log("Camera reset after arriving at character position")
                    -- NEW: Equip pet on arrival
                    task.wait(2)
                    equipPetOnArrival()
                    -- Check and buy missing furniture (updated for new furniture)
                    task.wait(2)
                    checkAndBuyMissingFurniture()
                    task.wait(3)
                    -- Start baby ailment monitoring and handling (now with PetFarm)
                    task.wait(2)
                    monitorAndHandleBabyAilments()
                end
                return true
            else
                log("Not near target, retrying...")
            end
        end
        resetCam()
        task.wait(2)
    end
    log("Failed to reach Main Map after 3 attempts.")
    return false
end

-- Run the function
goToMainMap()

debugPrint("INTEGRATED PetFarm Loaded! Equipped pet & monitoring baby ailments with new furniture (SleepingBag, CampingShower).")
debugPrint("PetFarm: RUNNING | Always Keep Equipped: ACTIVE")
