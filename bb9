-- Small Script to Go to Main Map and Then to Specific Character Position
-- Based on logic from ress0 ‚Äî –∫–æ–ø–∏—è.txt
-- Added respawn and unsubscribe from home at the beginning
-- Added choose Baby team at the beginning (from b1.txt)
-- Added baby ailment detection and handling (from bb3.txt, integrated with monitoring)
-- Added camera reset after arriving at character position
-- Integrated furniture and food handling for baby ailments
-- Added beach_party ailment handling: teleport to character position if detected
-- Updated bored ailment handling: teleport to specific bored position instead of using Piano
-- Added school ailment handling: teleport to school character position, set camera, pressW
-- Added salon ailment handling: teleport to salon character position, set camera, pressW
-- Added pizza_party ailment handling: teleport to pizza_party character position, set camera, pressW
-- INTEGRATED: PetFarm logic from w1.txt for regular pet ailments
--             - Updated furniture: SleepingBag (sleepy), CampingShower (dirty), AilmentsRefresh2024LitterBox (toilet)
--             - Removed BasicBed, Piano, CheapPetBathtub
--             - For hungry/thirsty: Buy teachers_apple/water and feed the pet like with pet apple healing logic from w1
--             - For bored: Teleport like bb8
--             - For play: Throw toy sequence with squeaky_bone
--             - Auto-selects best starter pet and equips
--             - Monitors regular ailments_manager for selected pet
--             - Assumes script runs in house for furniture (added goToHome with safe calls)

repeat task.wait() until game:IsLoaded()
repeat task.wait() until game.Players.LocalPlayer
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local player = Players.LocalPlayer

-----------------------------------------------------
-- UTILITIES (Simplified from ress0 + w1 debug)
-----------------------------------------------------
local function log(msg) print("[Baby+PetFarm] " .. tostring(msg)) end
local function getChar() return player.Character or player.CharacterAdded:Wait() end
local function safeTp(pos)
    return pcall(function()
        local hrp = getChar():FindFirstChild("HumanoidRootPart")
        if hrp then hrp.CFrame = CFrame.new(pos); task.wait(0.3) end
    end)
end
local function setCam(pos, look)
    pcall(function()
        local cam = Workspace.CurrentCamera
        if cam then cam.CameraType = Enum.CameraType.Scriptable; cam.CFrame = CFrame.new(pos, look) end
    end)
end
local function resetCam()
    pcall(function()
        local cam = Workspace.CurrentCamera
        if cam then cam.CameraType = Enum.CameraType.Custom end
    end)
end
local function pressW()
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
    end)
end
local function pressS()
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.S, false, game)
        task.wait(1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.S, false, game)
    end)
end
local function isNear(pos, dist)
    dist = dist or 60
    local success, result = pcall(function()
        local hrp = getChar():FindFirstChild("HumanoidRootPart")
        return hrp and (hrp.Position - pos).Magnitude < dist
    end)
    return success and result or false
end

-----------------------------------------------------
-- GO TO HOME FUNCTION (For furniture access) - FIXED SAFE CALL
-----------------------------------------------------
local function goToHome()
    log("Going to home...")
    local playerData = getPlayerData()
    if not playerData or not playerData.home or not playerData.home.id then
        log("No home ID found in player data, skipping home subscribe")
        return false
    end

    local API = ReplicatedStorage:WaitForChild("API")
    local HousingAPI = API:WaitForChild("HousingAPI", 5)
    if not HousingAPI then
        log("HousingAPI not found, skipping home subscribe")
        return false
    end

    local subscribeAPI = HousingAPI:FindFirstChild("SubscribeToHouse")
    if not subscribeAPI then
        log("SubscribeToHouse remote not found, skipping home subscribe")
        return false
    end

    local success = false
    pcall(function()
        if subscribeAPI:IsA("RemoteFunction") then
            success, _ = subscribeAPI:InvokeServer(playerData.home.id)
        elseif subscribeAPI:IsA("RemoteEvent") then
            subscribeAPI:FireServer(playerData.home.id)
            success = true
        end
    end)

    if success then
        task.wait(5)
        log("Successfully subscribed to home")

        -- Lock door safely
        local lockAPI = HousingAPI:FindFirstChild("SetDoorLocked")
        if lockAPI then
            pcall(function()
                if lockAPI:IsA("RemoteFunction") then
                    lockAPI:InvokeServer(true)
                elseif lockAPI:IsA("RemoteEvent") then
                    lockAPI:FireServer(true)
                end
            end)
            log("Door locked")
        else
            log("SetDoorLocked remote not found, skipping lock")
        end
        return true
    else
        log("Failed to subscribe to home")
        return false
    end
end

-----------------------------------------------------
-- BABY AILMENT HANDLING (Unchanged from bb8)
-----------------------------------------------------
-- Ailment to Furniture Mapping (merged from ailDetec and bb3, prioritizing bb3 handling)
local BABY_AILMENT_TASKS = {
    sleepy = "SleepingBag",  -- Updated from BasicBed to match bb3
    hungry = "teachers_apple",
    thirsty = "water",
    dirty = "CampingShower",  -- Updated from CheapPetBathtub to match bb3
    bored = "teleport_to_bored",  -- Updated: Custom handling for bored (teleport)
    sick = "healing_apple",
    beach_party = "teleport_to_character",  -- New: Custom handling for beach_party (teleport)
    school = "teleport_to_school",  -- New: Custom handling for school (teleport)
    salon = "teleport_to_salon",  -- New: Custom handling for salon (teleport)
    pizza_party = "teleport_to_pizza"  -- New: Custom handling for pizza_party (teleport)
}

-- Task cooldowns to prevent spam
local lastTaskTime = {}
local TASK_COOLDOWN = 30 -- seconds

-- Pre-cache API references for efficiency
local API = ReplicatedStorage:WaitForChild("API")
local ExitSeatStates = API:WaitForChild("AdoptAPI/ExitSeatStates")

-- Character position for beach_party
local BEACH_PARTY_CHARACTER_POS = Vector3.new(-604.54, 26.49, -1538.53)
local BEACH_PARTY_CAMERA_POS = Vector3.new(-598.88, 33.84, -1546.60)

-- Character position for bored
local BORED_CHARACTER_POS = Vector3.new(-489.941, 29.448, -1799.160)
local BORED_CAMERA_POS = Vector3.new(-499.916, 34.281, -1804.232)

-- Character position for school
local SCHOOL_CHARACTER_POS = Vector3.new(-309.794, 29.798, -1505.317)
local SCHOOL_CAMERA_POS = Vector3.new(-300.865, 36.256, -1499.952)

-- Character position for salon
local SALON_CHARACTER_POS = Vector3.new(-131.81, 29.34, -1765.13)
local SALON_CAMERA_POS = Vector3.new(-130.97, 36.81, -1755.39)

-- Character position for pizza_party
local PIZZA_PARTY_CHARACTER_POS = Vector3.new(-121.97, 29.34, -1663.56)
local PIZZA_PARTY_CAMERA_POS = Vector3.new(-132.73, 35.09, -1662.70)

-- Function to safely get player data
local function getPlayerData()
    local clientModules = ReplicatedStorage:WaitForChild("ClientModules", 10)
    if not clientModules then return nil end
    local coreModule = clientModules:WaitForChild("Core", 5)
    if not coreModule then return nil end
    local clientDataModule = coreModule:WaitForChild("ClientData", 5)
    if not clientDataModule then return nil end
   
    local clientData
    local success, err = pcall(function()
        clientData = require(clientDataModule)
    end)
    if not success or not clientData then return nil end
   
    local playerData
    success, err = pcall(function()
        playerData = clientData.get_data()[player.Name]
    end)
    if not success or not playerData then return nil end
   
    return playerData
end

-- Enhanced helper to extract ailment key
local function extractAilmentKey(ailment)
    if type(ailment) == "table" then
        local candidates = {"type", "name", "ailment", "id", "key", "kind"}
        for _, field in ipairs(candidates) do
            local val = ailment[field]
            if type(val) == "string" then
                local lowerVal = val:lower()
                if BABY_AILMENT_TASKS[lowerVal] or PET_AILMENT_TASKS[lowerVal] then
                    log("Extracted ailment '" .. lowerVal .. "' from field '" .. field .. "'")
                    return lowerVal
                end
            end
        end
        for k, v in pairs(ailment) do
            if type(v) == "string" then
                local lowerV = v:lower()
                if BABY_AILMENT_TASKS[lowerV] or PET_AILMENT_TASKS[lowerV] then
                    log("Found matching ailment string '" .. lowerV .. "' in table key '" .. tostring(k) .. "'")
                    return lowerV
                end
            elseif type(v) == "table" then
                local subKey = extractAilmentKey(v)
                if subKey ~= "unknown" then
                    return subKey
                end
            end
        end
        log("Unknown ailment table structure")
        return "unknown"
    else
        local str = tostring(ailment):lower()
        if BABY_AILMENT_TASKS[str] or PET_AILMENT_TASKS[str] then
            return str
        end
        return str
    end
end

-- Function to print available baby ailments in compact form
local function printAvailableBabyAilmentsCompact()
    log("üîç BABY AILMENTS (COMPACT)")
    log("=========================")
    local playerData = getPlayerData()
    if not playerData or not playerData.ailments_manager or not playerData.ailments_manager.baby_ailments then
        log("No baby ailments found.")
        return
    end
   
    local babyAilments = playerData.ailments_manager.baby_ailments
    local count = 0
    local actionableCount = 0
   
    log(string.format("%-5s %-36s %-15s %-10s", "No.", "Pet Unique ID", "Ailment", "Actionable"))
    log(string.rep("-", 70))
   
    for petUniqueID, ailment in pairs(babyAilments) do
        local ailmentKey = extractAilmentKey(ailment)
        local isActionable = BABY_AILMENT_TASKS[ailmentKey] and ailmentKey ~= "unknown"
        if isActionable then actionableCount = actionableCount + 1 end
        count = count + 1
        local status = isActionable and "YES" or "NO"
        log(string.format("%-5d %-36s %-15s %-10s", count, petUniqueID:sub(1, 36), ailmentKey, status))
    end
   
    log(string.rep("-", 70))
    log(string.format("Total baby ailments: %d (Actionable: %d)", count, actionableCount))
end

-- Extract furniture data
local function extractFurnitureData(model, folderId, part)
    return {
        folderId = folderId,
        partName = part.Name,
        position = part.Position,
        cframe = part.CFrame,
        model = model
    }
end

-- Find furniture by name (picks random from available)
local function findFurnitureByName(name)
    log("Searching for furniture: " .. name)
    local hi = Workspace:FindFirstChild("HouseInteriors")
    if not hi then
        log("HouseInteriors not found")
        return nil
    end
   
    local possibleFurniture = {}
   
    -- Search in HouseInteriors.furniture
    local furnitureFolder = hi:FindFirstChild("furniture")
    if furnitureFolder then
        for _, houseKey in ipairs(furnitureFolder:GetChildren()) do
            local model = houseKey:FindFirstChild(name)
            if model and model:IsA("Model") then
                local folderId = string.match(houseKey.Name, "f%-%d+") or "unknown"
                local activationParts = {"UseBlock", "Seat1", "Seat2"}
                local foundPart = nil
                for _, partName in ipairs(activationParts) do
                    local part = model:FindFirstChild(partName, true)
                    if part and part:IsA("BasePart") then
                        foundPart = part
                        log("Using " .. partName .. " in " .. model.Name .. " from houseKey " .. houseKey.Name)
                        break
                    end
                end
               
                if not foundPart then
                    for _, part in ipairs(model:GetDescendants()) do
                        if part:IsA("BasePart") then
                            foundPart = part
                            log("Using fallback part: " .. part.Name .. " in " .. model.Name .. " from houseKey " .. houseKey.Name)
                            break
                        end
                    end
                end
               
                if foundPart then
                    table.insert(possibleFurniture, extractFurnitureData(model, folderId, foundPart))
                end
            end
        end
    end
   
    -- Fallback: search entire workspace
    local model = Workspace:FindFirstChild(name, true)
    if model and model:IsA("Model") then
        local parentFolder = model.Parent
        local folderId = (parentFolder and string.match(parentFolder.Name, "f%-%d+")) or "unknown"
        local activationParts = {"UseBlock", "Seat1", "Seat2"}
        local foundPart = nil
        for _, partName in ipairs(activationParts) do
            local part = model:FindFirstChild(partName, true)
            if part and part:IsA("BasePart") then
                foundPart = part
                break
            end
        end
        if not foundPart then
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA("BasePart") then
                    foundPart = part
                    break
                end
            end
        end
        if foundPart then
            table.insert(possibleFurniture, extractFurnitureData(model, folderId, foundPart))
        end
    end
   
    if #possibleFurniture > 0 then
        local randomIndex = math.random(1, #possibleFurniture)
        local selected = possibleFurniture[randomIndex]
        log("Selected random furniture from " .. #possibleFurniture .. " options: folder " .. selected.folderId .. " part " .. selected.partName)
        return selected
    end
   
    log("Furniture not found: " .. name .. " (no instances available)")
    return nil
end

-- Call ExitSeatStates once after furniture use
local function callExitSeatStatesOnce()
    log("Calling ExitSeatStates once after furniture use...")
    local Char = player.Character or player.CharacterAdded:Wait()
    if Char then
        pcall(function()
            ExitSeatStates:FireServer(Char)
        end)
        log("Successfully called ExitSeatStates once")
    else
        log("Failed to get character for ExitSeatStates")
    end
end

-- Handle furniture activation (reused for both baby and pet)
local function handleFurnitureActivation(furnitureName)
    log("Activating furniture detected: " .. furnitureName)
    local furnitureData = findFurnitureByName(furnitureName)
    if not furnitureData then
        log("Cannot activate furniture: " .. furnitureName .. " - not found")
        return false
    end
   
    local char = player.Character
    if not char then
        log("Cannot activate furniture: No character found")
        return false
    end

    local HousingAPI = API:WaitForChild("HousingAPI", 5)
    if not HousingAPI then
        log("HousingAPI not found for furniture activation")
        return false
    end

    local isInterior = (furnitureName == "CampingShower" or furnitureName == "SleepingBag" or furnitureName == "AilmentsRefresh2024LitterBox")
    local apiName = isInterior and "ActivateInteriorFurniture" or "ActivateFurniture"
    local activateAPI = HousingAPI:FindFirstChild(apiName)
    if not activateAPI then
        log(apiName .. " remote not found")
        return false
    end

    local args
    if isInterior then
        args = {
            furnitureData.folderId,
            furnitureData.partName,
            {
                cframe = furnitureData.cframe
            },
            char
        }
    else
        args = {
            player,
            furnitureData.folderId,
            furnitureData.partName,
            {
                cframe = furnitureData.cframe
            },
            char
        }
    end
   
    log("Activating " .. furnitureName .. " in folder " .. furnitureData.folderId .. " with part " .. furnitureData.partName .. " using " .. apiName)
   
    local success = false
    pcall(function()
        if activateAPI:IsA("RemoteFunction") then
            success, _ = activateAPI:InvokeServer(unpack(args))
        elseif activateAPI:IsA("RemoteEvent") then
            activateAPI:FireServer(unpack(args))
            success = true
        end
    end)
   
    if success then
        log("Successfully activated: " .. furnitureName)
        task.wait(20) -- Wait for ailment cure
        callExitSeatStatesOnce() -- Call only once after wait
        return true
    else
        log("Failed to activate: " .. furnitureName)
        return false
    end
end

-- Use furniture with localPlayer (for baby and pet furniture)
local function useFurnitureWithLocalPlayer(furnitureName)
    log("Using furniture for ailment: " .. furnitureName .. " on localPlayer")
    return handleFurnitureActivation(furnitureName)
end

-- Handle beach_party ailment: Teleport to character position
local function handleBeachPartyAilment()
    log("BEACH_PARTY AILMENT DETECTED FOR BABY! Teleporting to character position...")
    if safeTp(BEACH_PARTY_CHARACTER_POS) then
        setCam(BEACH_PARTY_CAMERA_POS, BEACH_PARTY_CHARACTER_POS)
        task.wait(3)
        resetCam()
        log("Successfully teleported to beach_party position: " .. tostring(BEACH_PARTY_CHARACTER_POS))
        task.wait(5) -- Brief stay
        goToHome() -- Return home after
        return true
    else
        log("Failed to teleport for beach_party ailment")
        return false
    end
end

-- Handle bored ailment: Teleport to bored position
local function handleBoredAilment()
    log("BORED AILMENT DETECTED! Teleporting to bored position...")
    if safeTp(BORED_CHARACTER_POS) then
        setCam(BORED_CAMERA_POS, BORED_CHARACTER_POS)
        task.wait(3)
        resetCam()
        log("Successfully teleported to bored position: " .. tostring(BORED_CHARACTER_POS))
        task.wait(5) -- Brief stay
        goToHome() -- Return home after
        return true
    else
        log("Failed to teleport for bored ailment")
        return false
    end
end

-- Handle school ailment: Teleport to school character position
local function handleSchoolAilment()
    log("SCHOOL AILMENT DETECTED FOR BABY! Teleporting to school character position...")
    if safeTp(SCHOOL_CHARACTER_POS) then
        setCam(SCHOOL_CAMERA_POS, SCHOOL_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to school position: " .. tostring(SCHOOL_CHARACTER_POS) .. " and pressed W")
        task.wait(5)
        goToHome()
        return true
    else
        log("Failed to teleport for school ailment")
        return false
    end
end

-- Handle salon ailment: Teleport to salon character position
local function handleSalonAilment()
    log("SALON AILMENT DETECTED FOR BABY! Teleporting to salon character position...")
    if safeTp(SALON_CHARACTER_POS) then
        setCam(SALON_CAMERA_POS, SALON_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to salon position: " .. tostring(SALON_CHARACTER_POS) .. " and pressed W")
        task.wait(5)
        goToHome()
        return true
    else
        log("Failed to teleport for salon ailment")
        return false
    end
end

-- Handle pizza_party ailment: Teleport to pizza_party character position
local function handlePizzaPartyAilment()
    log("PIZZA_PARTY AILMENT DETECTED FOR BABY! Teleporting to pizza_party character position...")
    if safeTp(PIZZA_PARTY_CHARACTER_POS) then
        setCam(PIZZA_PARTY_CAMERA_POS, PIZZA_PARTY_CHARACTER_POS)
        task.wait(3)
        resetCam()
        pressW()
        task.wait(50)
        pressS()
        log("Successfully teleported to pizza_party position: " .. tostring(PIZZA_PARTY_CHARACTER_POS) .. " and pressed W")
        task.wait(5)
        goToHome()
        return true
    else
        log("Failed to teleport for pizza_party ailment")
        return false
    end
end

-- Buy teachers_apple
local function buyTeachersApple()
    log("Buying teachers_apple from shop...")
    local args = {
        "food",
        "teachers_apple",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased teachers_apple")
        return true
    else
        log("Failed to buy teachers_apple: " .. tostring(result))
        return false
    end
end

-- Find teachers_apple in inventory
local function findTeachersApple()
    log("Scanning inventory for teachers_apple...")
    local teachersAppleID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "teachers_apple" then
                    teachersAppleID = foodId
                    log("Found teachers_apple with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for teachers_apple: " .. tostring(errorMsg))
    end
    return teachersAppleID
end

-- Buy water
local function buyWater()
    log("Buying water from shop...")
    local args = {
        "food",
        "water",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased water")
        return true
    else
        log("Failed to buy water: " .. tostring(result))
        return false
    end
end

-- Find water in inventory
local function findWater()
    log("Scanning inventory for water...")
    local waterID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "water" then
                    waterID = foodId
                    log("Found water with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for water: " .. tostring(errorMsg))
    end
    return waterID
end

-- Buy healing_apple
local function buyHealingApple()
    log("Buying healing_apple from shop...")
    local args = {
        "food",
        "healing_apple",
        {
            buy_count = 1
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("ShopAPI/BuyItem"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully purchased healing_apple")
        return true
    else
        log("Failed to buy healing_apple: " .. tostring(result))
        return false
    end
end

-- Find healing_apple in inventory
local function findHealingApple()
    log("Scanning inventory for healing_apple...")
    local healingAppleID = nil
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.food then
            for foodId, foodData in pairs(playerData.inventory.food) do
                if foodData.id and string.lower(foodData.id) == "healing_apple" then
                    healingAppleID = foodId
                    log("Found healing_apple with ID: " .. foodId)
                    break
                end
            end
        end
    end)
    if not success then
        log("Error scanning inventory for healing_apple: " .. tostring(errorMsg))
    end
    return healingAppleID
end

-- Handle hungry ailment for baby (unchanged, on localPlayer)
local function handleHungryAilment()
    log("HUNGRY AILMENT DETECTED FOR BABY! Starting feeding process on localPlayer...")
    local teachersAppleID = findTeachersApple()
    if not teachersAppleID then
        log("No teachers_apple found in inventory, purchasing one...")
        local purchaseSuccess = buyTeachersApple()
        if not purchaseSuccess then
            log("Failed to purchase teachers_apple")
            return false
        end
        task.wait(2)
        teachersAppleID = findTeachersApple()
        if not teachersAppleID then
            log("Failed to find teachers_apple after purchase")
            return false
        end
    end
    -- Use on localPlayer for baby (multiple cycles)
    local equipArgs = {
        teachersAppleID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip teachers_apple: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped teachers_apple")
    task.wait(2)
  
    local startArgs = {
        teachersAppleID,
        "START"
    }
    local endArgs = {
        teachersAppleID,
        "END"
    }
  
    -- START
    local startSuccess, startResult = pcall(function()
        return API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    if not startSuccess then
        log("Failed to start using teachers_apple: " .. tostring(startResult))
        pcall(function()
            API:WaitForChild("ToolAPI/Unequip"):InvokeServer(teachersAppleID)
        end)
        return false
    end
    task.wait(2)
  
    -- END (first)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- START END (second)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- START (third)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
  
    -- Unequip food
    local unequipArgs = { teachersAppleID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used teachers_apple on localPlayer")
    return true
end

-- Handle thirsty ailment for baby (unchanged, on localPlayer)
local function handleThirstyAilment()
    log("THIRSTY AILMENT DETECTED FOR BABY! Starting watering process on localPlayer...")
    local waterID = findWater()
    if not waterID then
        log("No water found in inventory, purchasing one...")
        local purchaseSuccess = buyWater()
        if not purchaseSuccess then
            log("Failed to purchase water")
            return false
        end
        task.wait(3)
        waterID = findWater()
        if not waterID then
            log("Failed to find water after purchase")
            return false
        end
    end
    -- Use on localPlayer for baby (9 cycles)
    local equipArgs = {
        waterID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip water: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped water")
    task.wait(3)
  
    local startArgs = {
        waterID,
        "START"
    }
    local endArgs = {
        waterID,
        "END"
    }
  
    -- Perform multiple START/END cycles (9 full cycles as in bb3)
    for i = 1, 9 do
        pcall(function()
            API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
        end)
        task.wait(2)
        pcall(function()
            API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
        end)
        task.wait(2)
    end
  
    -- Unequip food
    local unequipArgs = { waterID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used water on localPlayer")
    return true
end

-- Handle sick ailment for baby (unchanged, on localPlayer)
local function handleSickAilment()
    log("SICK AILMENT DETECTED FOR BABY! Starting healing process on localPlayer...")
    local healingAppleID = findHealingApple()
    if not healingAppleID then
        log("No healing_apple found in inventory, purchasing one...")
        local purchaseSuccess = buyHealingApple()
        if not purchaseSuccess then
            log("Failed to purchase healing_apple")
            return false
        end
        task.wait(2)
        healingAppleID = findHealingApple()
        if not healingAppleID then
            log("Failed to find healing_apple after purchase")
            return false
        end
    end
    -- Use on localPlayer for baby
    local equipArgs = {
        healingAppleID,
        {
            use_sound_delay = true,
            equip_as_last = false
        }
    }
    local equipSuccess, equipResult = pcall(function()
        return API:WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(equipArgs))
    end)
    if not equipSuccess then
        log("Failed to equip healing_apple: " .. tostring(equipResult))
        return false
    end
    log("Successfully equipped healing_apple")
    task.wait(2)
  
    local startArgs = {
        healingAppleID,
        "START"
    }
    local endArgs = {
        healingAppleID,
        "END"
    }
  
    -- First START/END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- Second START/END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    -- Third START
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(startArgs))
    end)
    task.wait(2)
  
    -- Unequip food
    local unequipArgs = { healingAppleID }
    pcall(function()
        API:WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(unequipArgs))
    end)
  
    -- Final END
    pcall(function()
        API:WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(endArgs))
    end)
    task.wait(2)
  
    log("Successfully used healing_apple on localPlayer")
    return true
end

-- Check and buy missing furniture (updated for petfarm litterbox)
local function checkAndBuyMissingFurniture()
    log("Checking for missing furniture...")
    local missingFurniture = {}
   
    local campingShowerFound = findFurnitureByName("CampingShower")
    if not campingShowerFound then
        log("CampingShower not found, adding to buy list")
        table.insert(missingFurniture, {
            kind = "camping_shower",
            properties = {
                cframe = CFrame.new(25.55991554260254, 30.25162124633789, -1049.5599365234375, -0.6118413805961609, 0, 0.7909806966781616, 0, 1, 0, -0.7909806966781616, 0, -0.6118413805961609)
            }
        })
    else
        log("CampingShower found in house")
    end
   
    local sleepingBagFound = findFurnitureByName("SleepingBag")
    if not sleepingBagFound then
        log("SleepingBag not found, adding to buy list")
        table.insert(missingFurniture, {
            kind = "sleeping_bag",
            properties = {
                cframe = CFrame.new(6.224581718444824, 28.444856643676758, -1058.27001953125, 0.9946262836456299, -0.02014518901705742, 0.10155431926250458, 0.00000843508678372018, 0.9809029698371887, 0.194497749209404, -0.10353313386440277, -0.19345171749591827, 0.9756320118904114)
            }
        })
    else
        log("SleepingBag found in house")
    end

    local litterBoxFound = findFurnitureByName("AilmentsRefresh2024LitterBox")
    if not litterBoxFound then
        log("AilmentsRefresh2024LitterBox not found, adding to buy list")
        table.insert(missingFurniture, {
            kind = "ailments_refresh_2024_litter_box",
            properties = {
                cframe = CFrame.new(0, 0, 0) -- Default CFrame; adjust if needed
            }
        })
    else
        log("AilmentsRefresh2024LitterBox found in house")
    end
   
    if #missingFurniture > 0 then
        log("Buying " .. #missingFurniture .. " missing furniture items...")
        local args = {missingFurniture}
        local success, result = pcall(function()
            return API:WaitForChild("HousingAPI/BuyFurnitures"):InvokeServer(unpack(args))
        end)
        if success then
            log("Successfully purchased missing furniture")
            task.wait(3)
        else
            log("Failed to buy furniture: " .. tostring(result))
        end
    else
        log("All furniture found, no purchases needed")
    end
end

-- Monitoring and handling loop for baby ailments (unchanged)
local function monitorAndHandleBabyAilments()
    log("Starting baby ailment monitoring and handling...")
    local lastScanTime = 0
    local SCAN_INTERVAL = 10 -- seconds
    local currentTime = os.time()
   
    while true do
        currentTime = os.time()
        local playerData = getPlayerData()
       
        if playerData and playerData.ailments_manager and playerData.ailments_manager.baby_ailments then
            local foundActionable = false
           
            for petUniqueID, ailmentType in pairs(playerData.ailments_manager.baby_ailments) do
                local ailmentKey = extractAilmentKey(ailmentType)
                local taskName = BABY_AILMENT_TASKS[ailmentKey]
               
                if taskName then
                    foundActionable = true
                    -- Check cooldown
                    if not lastTaskTime[ailmentKey] or (currentTime - lastTaskTime[ailmentKey]) >= TASK_COOLDOWN then
                        if ailmentKey == "beach_party" then
                            log("Baby beach_party ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to character position")
                            local success = handleBeachPartyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "bored" then
                            log("Baby bored ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to bored position")
                            local success = handleBoredAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "school" then
                            log("Baby school ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to school position")
                            local success = handleSchoolAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "salon" then
                            log("Baby salon ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to salon position")
                            local success = handleSalonAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "pizza_party" then
                            log("Baby pizza_party ailment detected for pet: " .. petUniqueID .. " ‚Üí Teleporting to pizza_party position")
                            local success = handlePizzaPartyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "hungry" then
                            log("Baby hungry ailment detected for pet: " .. petUniqueID .. " ‚Üí Using teachers_apple on localPlayer")
                            local success = handleHungryAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "thirsty" then
                            log("Baby thirsty ailment detected for pet: " .. petUniqueID .. " ‚Üí Using water on localPlayer")
                            local success = handleThirstyAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        elseif ailmentKey == "sick" then
                            log("Baby sick ailment detected for pet: " .. petUniqueID .. " ‚Üí Using healing_apple on localPlayer")
                            local success = handleSickAilment()
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        else
                            -- For furniture-based (sleepy, dirty)
                            log("Baby " .. ailmentKey .. " ailment detected for pet: " .. petUniqueID .. " ‚Üí Using " .. taskName .. " on localPlayer")
                            local success = useFurnitureWithLocalPlayer(taskName)
                            if success then
                                lastTaskTime[ailmentKey] = currentTime
                            end
                        end
                        break -- Handle one at a time
                    else
                        log(ailmentKey .. " on cooldown (" .. (TASK_COOLDOWN - (currentTime - lastTaskTime[ailmentKey])) .. "s remaining)")
                    end
                end
            end
           
            if not foundActionable and currentTime - lastScanTime >= 60 then
                printAvailableBabyAilmentsCompact()  -- Print periodically if no action
                lastScanTime = currentTime
            end
        else
            if currentTime - lastScanTime >= 60 then
                printAvailableBabyAilmentsCompact()
                lastScanTime = currentTime
            end
        end
       
        task.wait(SCAN_INTERVAL)
    end
end

-----------------------------------------------------
-- PETFARM LOGIC INTEGRATION FROM W1 (Updated) - FIXED PET SELECTION
-----------------------------------------------------
-- Pet selection variables
local PetID = nil
local currentFoodID = nil
local currentToyID = nil

-- Updated AILMENT_TASKS (no BasicBed, Piano, CheapPetBathtub; updated furniture; feed for hungry/thirsty/sick)
local PET_AILMENT_TASKS = {
    sleepy = "SleepingBag",
    hungry = "TEACHERS_APPLE",
    thirsty = "WATER",
    dirty = "CampingShower",
    bored = "TELEPORT_BORED",
    toilet = "AilmentsRefresh2024LitterBox",
    play = "THROW_TOY",
    walk = "WALK_HANDLER",  -- Not implemented
    ride = "STROLLER_HANDLER",  -- Not implemented
    sick = "HEALING_APPLE",
    mystery = "MYSTERY_HANDLER",  -- Not implemented
    pet_me = "PET_ME_HANDLER"  -- Not implemented
}

-- Find best starter pet (from w1) - FIXED WITH STRING.FIND
local function findBestStarterPet()
    log("Finding best starter pet...")
    local success, errorMsg = pcall(function()
        local clientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        local playerData = clientData.get_data()[player.Name]
        if playerData and playerData.inventory and playerData.inventory.pets then
            local petName = nil
            -- Prefer starter_egg
            for petIndex, petData in pairs(playerData.inventory.pets) do
                if petData and petData.id and petData.unique then
                    petName = petData.id:lower()
                    if petName == "starter_egg" then
                        log("Found starter_egg")
                        return petData.unique
                    end
                end
            end
            -- Then 6yo dog
            for petIndex, petData in pairs(playerData.inventory.pets) do
                if petData and petData.id and petData.unique and petData.properties then
                    petName = petData.id:lower()
                    local age = petData.properties.age or 0
                    if string.find(petName, "dog") and age == 6 then
                        log("Found 6yo dog")
                        return petData.unique
                    end
                end
            end
            -- Then 6yo cat
            for petIndex, petData in pairs(playerData.inventory.pets) do
                if petData and petData.id and petData.unique and petData.properties then
                    petName = petData.id:lower()
                    local age = petData.properties.age or 0
                    if string.find(petName, "cat") and age == 6 then
                        log("Found 6yo cat")
                        return petData.unique
                    end
                end
            end
        end
    end)
    if not success then
        log("Error finding starter pet: " .. tostring(errorMsg))
    end
    log("No suitable starter pet found")
    return nil
end

-- Ensure pet equipped (simple version from w1)
local function ensurePetEquipped(petId, timeout)
    if not petId then return false end
    local startTime = tick()
    while tick() - startTime < (timeout or 10) do
        local success = pcall(function()
            ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Equip"):InvokeServer(petId, {use_sound_delay = true, equip_as_last = false})
        end)
        if success then
            task.wait(2)
            log("Pet equipped successfully")
            return true
        end
        task.wait(1)
    end
    log("Failed to equip pet after timeout")
    return false
end

-- Safely unequip food (from w1)
local function safelyUnequipFood(foodID)
    if foodID then
        log("Unequipping food: " .. foodID)
        local args = { foodID }
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(args))
        end)
        if success then
            log("Successfully unequipped food")
        else
            log("Failed to unequip food: " .. tostring(result))
        end
        task.wait(1)
        currentFoodID = nil
    end
end

-- Use food on pet (adapted from w1 usePetAgePotion for healing/feed logic)
local function useFoodOnPet(foodID, petID)
    if not foodID or not petID then
        log("Cannot use food: Missing foodID or petID")
        return false
    end
    safelyUnequipFood(currentFoodID)
    currentFoodID = foodID
    log("Using food " .. foodID .. " on pet " .. petID)
  
    -- Equip
    local args1 = {foodID, {use_sound_delay = true, equip_as_last = false}}
    local equipSuccess, equipResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Equip"):InvokeServer(unpack(args1))
    end)
    if not equipSuccess then
        log("Failed to equip food: " .. tostring(equipResult))
        return false
    end
    log("Food equipped")
    task.wait(1)
  
    -- Start
    local args2 = {foodID, "START"}
    local startSuccess, startResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/ServerUseTool"):FireServer(unpack(args2))
    end)
    if not startSuccess then
        log("Failed to start food: " .. tostring(startResult))
        safelyUnequipFood(foodID)
        return false
    end
    task.wait(1)
  
    -- Consume on pet
    local args3 = {"__Enum_PetObjectCreatorType_2", {additional_consume_uniques = {}, pet_unique = petID, unique_id = foodID}}
    local petObjSuccess, petObjResult = pcall(function()
        return ReplicatedStorage:WaitForChild("API"):WaitForChild("PetObjectAPI/CreatePetObject"):InvokeServer(unpack(args3))
    end)
    if not petObjSuccess then
        log("Failed to consume food on pet: " .. tostring(petObjResult))
        safelyUnequipFood(foodID)
        return false
    end
    task.wait(2)
  
    -- Unequip
    safelyUnequipFood(foodID)
    log("Successfully used food on pet")
    return true
end

-- Handle hungry on pet (buy + use like healing from w1)
local function handleHungryAilmentOnPet(petID)
    log("HUNGRY AILMENT DETECTED FOR PET! Feeding teachers_apple...")
    local foodID = findTeachersApple()
    if not foodID then
        log("No teachers_apple, purchasing...")
        local purchaseSuccess = buyTeachersApple()
        if not purchaseSuccess then return false end
        task.wait(2)
        foodID = findTeachersApple()
    end
    if foodID then
        return useFoodOnPet(foodID, petID)
    end
    return false
end

-- Handle thirsty on pet (buy + use like healing from w1)
local function handleThirstyAilmentOnPet(petID)
    log("THIRSTY AILMENT DETECTED FOR PET! Feeding water...")
    local foodID = findWater()
    if not foodID then
        log("No water, purchasing...")
        local purchaseSuccess = buyWater()
        if not purchaseSuccess then return false end
        task.wait(3)
        foodID = findWater()
    end
    if foodID then
        return useFoodOnPet(foodID, petID)
    end
    return false
end

-- Handle sick on pet (buy + use like healing from w1)
local function handleSickAilmentOnPet(petID)
    log("SICK AILMENT DETECTED FOR PET! Feeding healing_apple...")
    local foodID = findHealingApple()
    if not foodID then
        log("No healing_apple, purchasing...")
        local purchaseSuccess = buyHealingApple()
        if not purchaseSuccess then return false end
        task.wait(2)
        foodID = findHealingApple()
    end
    if foodID then
        return useFoodOnPet(foodID, petID)
    end
    return false
end

-- HARDCODED SQUEAKY BONE (from w1)
local SQUEAKY_BONE_ID = nil
local function getSqueakyBoneID()
    if SQUEAKY_BONE_ID then
        return SQUEAKY_BONE_ID
    end
 
    local success, data = pcall(function()
        return require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[player.Name]
    end)
 
    if not success or not data or not data.inventory or not data.inventory.toys then
        log("No inventory or toys data found!")
        return nil
    end
 
    for uniqueId, toyData in pairs(data.inventory.toys) do
        if toyData.id == "squeaky_bone_default" then
            log("Found squeaky_bone_default ‚Üí ID: " .. uniqueId)
            SQUEAKY_BONE_ID = uniqueId
            return uniqueId
        end
    end
 
    log("squeaky_bone_default NOT FOUND in inventory!")
    return nil
end

-- Safely unequip toy (from w1)
local function safelyUnequipToy()
    if currentToyID then
        log("Unequipping toy: " .. currentToyID)
        local args = { currentToyID }
        local success, result = pcall(function()
            return ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Unequip"):InvokeServer(unpack(args))
        end)
     
        if success then
            log("Successfully unequipped toy")
        else
            log("Failed to unequip toy: " .. tostring(result))
        end
     
        currentToyID = nil
        task.wait(1)
    else
        log("No toy equipped to unequip - skipping")
    end
end

-- Single throw function (from w1)
local function performThrowToy()
    local toyID = getSqueakyBoneID()
    if not toyID then
        log("NO squeaky_bone_default ‚Üí Play ailment skipped")
        return false
    end
 
    log("Using squeaky_bone_default ‚Üí " .. toyID)
    currentToyID = toyID
 
    -- EQUIP
    local success1, err1 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/Equip"]:InvokeServer(toyID, {
            use_sound_delay = true,
            equip_as_last = false
        })
    end)
 
    if not success1 then
        log("Failed to equip toy: " .. tostring(err1))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1.2)
 
    -- START
    local success2, err2 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/ServerUseTool"]:FireServer(toyID, "START")
    end)
 
    if not success2 then
        log("Failed to start using toy: " .. tostring(err2))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1)
 
    -- TRIGGER PET REACTION
    local success3, err3 = pcall(function()
        return ReplicatedStorage.API["PetObjectAPI/CreatePetObject"]:InvokeServer(
            "__Enum_PetObjectCreatorType_1",
            { reaction_name = "ThrowToyReaction", unique_id = toyID }
        )
    end)
 
    if not success3 then
        log("Failed to trigger pet reaction: " .. tostring(err3))
        safelyUnequipToy()
        return false
    end
 
    task.wait(1.1)
 
    -- END
    local success4, err4 = pcall(function()
        return ReplicatedStorage.API["ToolAPI/ServerUseTool"]:FireServer(toyID, "END")
    end)
 
    if not success4 then
        log("Failed to end using toy: " .. tostring(err4))
        safelyUnequipToy()
        return false
    end
 
    log("squeaky_bone_default throw SUCCESS")
    return true
end

-- Complete throw sequence (3 throws) (from w1)
local function performThrowToySequence()
    log("Starting squeaky_bone_default throw sequence (3x)...")
    local toyID = getSqueakyBoneID()
    if not toyID then
        log("NO squeaky_bone_default ‚Üí Play ailment skipped")
        return false
    end
 
    local successfulThrows = 0
 
    for i = 1, 3 do
        log("Throw #" .. i .. " with squeaky_bone_default")
        local success = performThrowToy()
     
        if success then
            successfulThrows += 1
            log("Throw #" .. i .. " SUCCESS")
        else
            log("Throw #" .. i .. " FAILED ‚Üí stopping sequence")
            safelyUnequipToy()
            return false
        end
     
        if i < 3 then
            task.wait(9)
        end
    end
 
    safelyUnequipToy()
    local cured = successfulThrows >= 2
    log("Throw sequence finished: " .. successfulThrows .. "/3 ‚Üí Play ailment " .. (cured and "CURED" or "NOT CURED"))
    return cured
end

-- Main play ailment handler (from w1)
local function handlePlayAilment()
    log("PLAY AILMENT DETECTED! ‚Üí Using squeaky_bone_default sequence")
    local success = performThrowToySequence()
 
    if success then
        log("Play ailment CURED with squeaky_bone_default")
        return true
    else
        log("Play ailment FAILED (no bone or interrupted)")
        safelyUnequipToy()
        return false
    end
end

-- Monitoring and handling loop for regular pet ailments (ported/adapted from w1)
local function monitorAndHandlePetAilments()
    log("Starting regular pet ailment monitoring and handling...")
    local lastScanTime = 0
    local SCAN_INTERVAL = 10 -- seconds
    local currentTime = os.time()
   
    while true do
        currentTime = os.time()
        if not PetID then
            task.wait(SCAN_INTERVAL)
            continue
        end
        local playerData = getPlayerData()
       
        if playerData and playerData.ailments_manager then
            local ailment = playerData.ailments_manager[PetID]
            if ailment then
                local ailmentKey = extractAilmentKey(ailment)
                local taskName = PET_AILMENT_TASKS[ailmentKey]
               
                if taskName then
                    -- Check cooldown
                    if not lastTaskTime[ailmentKey] or (currentTime - lastTaskTime[ailmentKey]) >= TASK_COOLDOWN then
                        local success = false
                        if taskName == "SleepingBag" or taskName == "CampingShower" or taskName == "AilmentsRefresh2024LitterBox" then
                            log("Pet " .. ailmentKey .. " ailment detected ‚Üí Using furniture " .. taskName)
                            success = useFurnitureWithLocalPlayer(taskName)
                        elseif taskName == "TEACHERS_APPLE" then
                            success = handleHungryAilmentOnPet(PetID)
                        elseif taskName == "WATER" then
                            success = handleThirstyAilmentOnPet(PetID)
                        elseif taskName == "HEALING_APPLE" then
                            success = handleSickAilmentOnPet(PetID)
                        elseif taskName == "TELEPORT_BORED" then
                            success = handleBoredAilment()
                        elseif taskName == "THROW_TOY" then
                            success = handlePlayAilment()
                        else
                            log("Handler for pet ailment task '" .. taskName .. "' not implemented")
                            success = false
                        end
                        if success then
                            lastTaskTime[ailmentKey] = currentTime
                        end
                    else
                        log(ailmentKey .. " on cooldown (" .. (TASK_COOLDOWN - (currentTime - lastTaskTime[ailmentKey])) .. "s remaining)")
                    end
                end
            end
           
            if currentTime - lastScanTime >= 60 then
                log("No pet ailments active")
                lastScanTime = currentTime
            end
        end
       
        task.wait(SCAN_INTERVAL)
    end
end

-----------------------------------------------------
-- SELECT BABY TEAM (from b1.txt)
-----------------------------------------------------
local function selectBabyTeam()
    log("Selecting Baby team...")
    local args = {
        "Babies",
        {
            dont_respawn = true,
            source_for_logging = "avatar_editor"
        }
    }
    local success, result = pcall(function()
        return API:WaitForChild("TeamAPI/ChooseTeam"):InvokeServer(unpack(args))
    end)
    if success then
        log("Successfully selected Baby team")
        return true
    else
        log("Failed to select Baby team: " .. tostring(result))
        return false
    end
end

-----------------------------------------------------
-- RESPAWN AND UNSUBSCRIBE AT BEGINNING
-----------------------------------------------------
log("Performing initial respawn and unsubscribe...")
-- Initial respawn using TeamAPI
pcall(function()
    API:WaitForChild("TeamAPI/Spawn"):InvokeServer()
end)
task.wait(9)
-- Initial unsubscribe from house
pcall(function()
    local unsubscribeAPI = API:FindFirstChild("HousingAPI/UnsubscribeFromHouse")
    if unsubscribeAPI then
        if unsubscribeAPI:IsA("RemoteFunction") then
            unsubscribeAPI:InvokeServer(player, true)
        elseif unsubscribeAPI:IsA("RemoteEvent") then
            unsubscribeAPI:FireServer(player, true)
        end
    end
end)
task.wait(7)
-- Select Baby team after respawn and unsubscribe
selectBabyTeam()
task.wait(2)

-- AUTO-SELECT AND EQUIP PET FOR PETFARM - FIXED
PetID = findBestStarterPet()
if PetID then
    local equipped = ensurePetEquipped(PetID)
    if equipped then
        log("PetFarm: Equipped starter pet " .. tostring(PetID))
    else
        log("PetFarm: Failed to equip pet, but continuing monitoring")
    end
else
    log("PetFarm: No suitable pet found, skipping regular pet monitoring")
end

-- GO TO HOME FOR FURNITURE-BASED AILMENTS - FIXED
local homeSuccess = goToHome()
if homeSuccess then
    log("Successfully went to home for furniture access")
else
    log("Failed to go to home, furniture-based ailments may not work")
end

-- BUY MISSING FURNITURE
checkAndBuyMissingFurniture()
task.wait(3)

-- START MONITORING COROUTINES
coroutine.wrap(monitorAndHandleBabyAilments)()
if PetID then
    coroutine.wrap(monitorAndHandlePetAilments)()
    log("PetFarm: Started monitoring for pet " .. tostring(PetID))
else
    log("PetFarm: No pet selected, skipping regular monitoring")
end

log("Baby + PetFarm system fully started! Monitoring both baby and regular pet ailments.")
