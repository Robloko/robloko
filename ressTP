-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
-- â•‘         Adopt Me Pet Recycler Script       â•‘
-- â•‘     (LocalScript - for your own pets)      â•‘
-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Players          = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace        = game:GetService("Workspace")

local player = Players.LocalPlayer
local API    = ReplicatedStorage:WaitForChild("API", 8)

-- List of pet IDs you want to release (common 2022 basic egg pets)
local TARGET_PET_IDS = {
    "basic_egg_2022_camel",
    "basic_egg_2022_poodle",
    "basic_egg_2022_donkey",
    "basic_egg_2022_zebra",
    "basic_egg_2022_orangutan",
    "basic_egg_2022_parakeet",
    "basic_egg_2022_swordfish",
    "basic_egg_2022_robot",
    "basic_egg_2022_corgi",
}

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  1. Get player data (inventory)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function getPlayerInventory()
    local success, result = pcall(function()
        local ClientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
        return ClientData.get_data()[player.Name]
    end)
    
    if not success or not result then
        warn("Failed to load ClientData")
        return nil
    end
    
    return result.inventory
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  2. Find matching pets to release
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function findPetsToRelease(petsTable)
    local toRelease = {}
    local count = 0
    
    for uniqueId, pet in pairs(petsTable or {}) do
        if table.find(TARGET_PET_IDS, pet.id) then
            -- You can add extra filters here if needed, e.g.
            -- if not pet.properties.neon and not pet.properties.mega_neon then
                toRelease[uniqueId] = true
                count += 1
            -- end
        end
    end
    
    return toRelease, count
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  3. Find PetRecycler in HouseInteriors (recursive)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function findPetRecycler()
    local houseInteriors = Workspace:FindFirstChild("HouseInteriors")
    if not houseInteriors then
        warn("HouseInteriors folder not found")
        return nil
    end
    
    local function recursiveSearch(folder)
        for _, child in ipairs(folder:GetChildren()) do
            if child.Name == "PetRecycler" then
                return child
            end
            if child:IsA("Folder") or child:IsA("Model") then
                local found = recursiveSearch(child)
                if found then return found end
            end
        end
        return nil
    end
    
    return recursiveSearch(houseInteriors)
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  Main logic
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local inventory = getPlayerInventory()

if not inventory or not inventory.pets then
    warn("No pets inventory found")
    return
end

print("ğŸ” Found " .. #TARGET_PET_IDS .. " target pet types")
local uniquesToRelease, matchCount = findPetsToRelease(inventory.pets)

print("ğŸ“Š Matching pets found: " .. matchCount)

if matchCount < 4 then
    print("Not enough matching pets (" .. matchCount .. "/4). Stopping.")
    return
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  Find recycler
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local petRecycler = findPetRecycler()

if not petRecycler then
    warn("PetRecycler not found in HouseInteriors!")
    return
end

print("âœ… PetRecycler found â†’ releasing " .. matchCount .. " pets")

-- Prepare remote arguments
local releaseArgs = {
    "f-39",                       -- furniture ID? (seems hardcoded in many scripts)
    "UseBlock",
    {
        uniques = uniquesToRelease
    },
    player.Character or player.CharacterAdded:Wait()
}

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  Release pets
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local successRelease, err = pcall(function()
    API:WaitForChild("HousingAPI"):WaitForChild("ActivateInteriorFurniture"):InvokeServer(unpack(releaseArgs))
end)

if successRelease then
    print("âœ… Release request sent (" .. matchCount .. " pets)")
else
    warn("Release failed: " .. tostring(err))
end

-- Small wait â€” sometimes server needs time to process
task.wait(1.2)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--  Collect tickets
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local successTickets, errTickets = pcall(function()
    API:WaitForChild("PetRecyclerAPI"):WaitForChild("TicketsCollected"):InvokeServer()
end)

if successTickets then
    print("ğŸŸï¸ Tickets collection request sent")
else
    warn("Tickets collection failed: " .. tostring(errTickets))
end

print("Script finished.")
